
/**
 * Client
**/

import * as runtime from './runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model users
 * *
 *  * ========= USERS =========
 */
export type users = $Result.DefaultSelection<Prisma.$usersPayload>
/**
 * Model brands
 * *
 *  * ========= BRANDS / MODELS / VARIANTS =========
 */
export type brands = $Result.DefaultSelection<Prisma.$brandsPayload>
/**
 * Model models
 * 
 */
export type models = $Result.DefaultSelection<Prisma.$modelsPayload>
/**
 * Model variants
 * 
 */
export type variants = $Result.DefaultSelection<Prisma.$variantsPayload>
/**
 * Model states
 * *
 *  * ========= STATES / CITIES =========
 */
export type states = $Result.DefaultSelection<Prisma.$statesPayload>
/**
 * Model cities
 * 
 */
export type cities = $Result.DefaultSelection<Prisma.$citiesPayload>
/**
 * Model checklist_categories
 * *
 *  * ========= CHECKLIST =========
 */
export type checklist_categories = $Result.DefaultSelection<Prisma.$checklist_categoriesPayload>
/**
 * Model checklist_options
 * 
 */
export type checklist_options = $Result.DefaultSelection<Prisma.$checklist_optionsPayload>
/**
 * Model vehicle
 * *
 *  * ========= VEHICLE & RELATED TABLES =========
 */
export type vehicle = $Result.DefaultSelection<Prisma.$vehiclePayload>
/**
 * Model vehicle_features
 * 
 */
export type vehicle_features = $Result.DefaultSelection<Prisma.$vehicle_featuresPayload>
/**
 * Model vehicle_images
 * 
 */
export type vehicle_images = $Result.DefaultSelection<Prisma.$vehicle_imagesPayload>
/**
 * Model vehicle_availability
 * 
 */
export type vehicle_availability = $Result.DefaultSelection<Prisma.$vehicle_availabilityPayload>
/**
 * Model vehicle_availability_history
 * 
 */
export type vehicle_availability_history = $Result.DefaultSelection<Prisma.$vehicle_availability_historyPayload>
/**
 * Model vehicle_inspection
 * 
 */
export type vehicle_inspection = $Result.DefaultSelection<Prisma.$vehicle_inspectionPayload>
/**
 * Model vehicle_inspection_details
 * 
 */
export type vehicle_inspection_details = $Result.DefaultSelection<Prisma.$vehicle_inspection_detailsPayload>
/**
 * Model vehicle_prices
 * 
 */
export type vehicle_prices = $Result.DefaultSelection<Prisma.$vehicle_pricesPayload>
/**
 * Model customer
 * *
 *  * ========= USERS / CUSTOMERS / PROVIDERS =========
 */
export type customer = $Result.DefaultSelection<Prisma.$customerPayload>
/**
 * Model providers
 * 
 */
export type providers = $Result.DefaultSelection<Prisma.$providersPayload>
/**
 * Model vehicle_bookings
 * *
 *  * ========= BOOKINGS / LOGS / BILLS / PAYMENTS =========
 */
export type vehicle_bookings = $Result.DefaultSelection<Prisma.$vehicle_bookingsPayload>
/**
 * Model vehicle_bookings_logs
 * 
 */
export type vehicle_bookings_logs = $Result.DefaultSelection<Prisma.$vehicle_bookings_logsPayload>
/**
 * Model vehicle_bookings_bills
 * 
 */
export type vehicle_bookings_bills = $Result.DefaultSelection<Prisma.$vehicle_bookings_billsPayload>
/**
 * Model bills_payment
 * 
 */
export type bills_payment = $Result.DefaultSelection<Prisma.$bills_paymentPayload>

/**
 * Enums
 */
export namespace $Enums {
  export const role: {
  ADMIN: 'ADMIN',
  HOSTER: 'HOSTER',
  CUSTOMER: 'CUSTOMER'
};

export type role = (typeof role)[keyof typeof role]

}

export type role = $Enums.role

export const role: typeof $Enums.role

/**
 * ##  Prisma Client ʲˢ
 *
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.users.findMany()
 * ```
 *
 *
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  const U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   *
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.users.findMany()
   * ```
   *
   *
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): PrismaClient;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

/**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P]): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number }): $Utils.JsPromise<R>

  /**
   * Executes a raw MongoDB command and returns the result of it.
   * @example
   * ```
   * const user = await prisma.$runCommandRaw({
   *   aggregate: 'User',
   *   pipeline: [{ $match: { name: 'Bob' } }, { $project: { email: true, _id: false } }],
   *   explain: false,
   * })
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $runCommandRaw(command: Prisma.InputJsonObject): Prisma.PrismaPromise<Prisma.JsonObject>

  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb<ClientOptions>, ExtArgs, $Utils.Call<Prisma.TypeMapCb<ClientOptions>, {
    extArgs: ExtArgs
  }>>

      /**
   * `prisma.users`: Exposes CRUD operations for the **users** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.users.findMany()
    * ```
    */
  get users(): Prisma.usersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.brands`: Exposes CRUD operations for the **brands** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Brands
    * const brands = await prisma.brands.findMany()
    * ```
    */
  get brands(): Prisma.brandsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.models`: Exposes CRUD operations for the **models** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Models
    * const models = await prisma.models.findMany()
    * ```
    */
  get models(): Prisma.modelsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.variants`: Exposes CRUD operations for the **variants** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Variants
    * const variants = await prisma.variants.findMany()
    * ```
    */
  get variants(): Prisma.variantsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.states`: Exposes CRUD operations for the **states** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more States
    * const states = await prisma.states.findMany()
    * ```
    */
  get states(): Prisma.statesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.cities`: Exposes CRUD operations for the **cities** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Cities
    * const cities = await prisma.cities.findMany()
    * ```
    */
  get cities(): Prisma.citiesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checklist_categories`: Exposes CRUD operations for the **checklist_categories** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checklist_categories
    * const checklist_categories = await prisma.checklist_categories.findMany()
    * ```
    */
  get checklist_categories(): Prisma.checklist_categoriesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.checklist_options`: Exposes CRUD operations for the **checklist_options** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Checklist_options
    * const checklist_options = await prisma.checklist_options.findMany()
    * ```
    */
  get checklist_options(): Prisma.checklist_optionsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle`: Exposes CRUD operations for the **vehicle** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicles
    * const vehicles = await prisma.vehicle.findMany()
    * ```
    */
  get vehicle(): Prisma.vehicleDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_features`: Exposes CRUD operations for the **vehicle_features** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_features
    * const vehicle_features = await prisma.vehicle_features.findMany()
    * ```
    */
  get vehicle_features(): Prisma.vehicle_featuresDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_images`: Exposes CRUD operations for the **vehicle_images** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_images
    * const vehicle_images = await prisma.vehicle_images.findMany()
    * ```
    */
  get vehicle_images(): Prisma.vehicle_imagesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_availability`: Exposes CRUD operations for the **vehicle_availability** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_availabilities
    * const vehicle_availabilities = await prisma.vehicle_availability.findMany()
    * ```
    */
  get vehicle_availability(): Prisma.vehicle_availabilityDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_availability_history`: Exposes CRUD operations for the **vehicle_availability_history** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_availability_histories
    * const vehicle_availability_histories = await prisma.vehicle_availability_history.findMany()
    * ```
    */
  get vehicle_availability_history(): Prisma.vehicle_availability_historyDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_inspection`: Exposes CRUD operations for the **vehicle_inspection** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_inspections
    * const vehicle_inspections = await prisma.vehicle_inspection.findMany()
    * ```
    */
  get vehicle_inspection(): Prisma.vehicle_inspectionDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_inspection_details`: Exposes CRUD operations for the **vehicle_inspection_details** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_inspection_details
    * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findMany()
    * ```
    */
  get vehicle_inspection_details(): Prisma.vehicle_inspection_detailsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_prices`: Exposes CRUD operations for the **vehicle_prices** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_prices
    * const vehicle_prices = await prisma.vehicle_prices.findMany()
    * ```
    */
  get vehicle_prices(): Prisma.vehicle_pricesDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.customer`: Exposes CRUD operations for the **customer** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Customers
    * const customers = await prisma.customer.findMany()
    * ```
    */
  get customer(): Prisma.customerDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.providers`: Exposes CRUD operations for the **providers** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Providers
    * const providers = await prisma.providers.findMany()
    * ```
    */
  get providers(): Prisma.providersDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_bookings`: Exposes CRUD operations for the **vehicle_bookings** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_bookings
    * const vehicle_bookings = await prisma.vehicle_bookings.findMany()
    * ```
    */
  get vehicle_bookings(): Prisma.vehicle_bookingsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_bookings_logs`: Exposes CRUD operations for the **vehicle_bookings_logs** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_bookings_logs
    * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findMany()
    * ```
    */
  get vehicle_bookings_logs(): Prisma.vehicle_bookings_logsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.vehicle_bookings_bills`: Exposes CRUD operations for the **vehicle_bookings_bills** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Vehicle_bookings_bills
    * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findMany()
    * ```
    */
  get vehicle_bookings_bills(): Prisma.vehicle_bookings_billsDelegate<ExtArgs, ClientOptions>;

  /**
   * `prisma.bills_payment`: Exposes CRUD operations for the **bills_payment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Bills_payments
    * const bills_payments = await prisma.bills_payment.findMany()
    * ```
    */
  get bills_payment(): Prisma.bills_paymentDelegate<ExtArgs, ClientOptions>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 6.18.0
   * Query Engine version: 34b5a692b7bd79939a9a2c3ef97d816e749cda2f
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion

  /**
   * Utility Types
   */


  export import Bytes = runtime.Bytes
  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    *
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    *
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   *
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? P : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    users: 'users',
    brands: 'brands',
    models: 'models',
    variants: 'variants',
    states: 'states',
    cities: 'cities',
    checklist_categories: 'checklist_categories',
    checklist_options: 'checklist_options',
    vehicle: 'vehicle',
    vehicle_features: 'vehicle_features',
    vehicle_images: 'vehicle_images',
    vehicle_availability: 'vehicle_availability',
    vehicle_availability_history: 'vehicle_availability_history',
    vehicle_inspection: 'vehicle_inspection',
    vehicle_inspection_details: 'vehicle_inspection_details',
    vehicle_prices: 'vehicle_prices',
    customer: 'customer',
    providers: 'providers',
    vehicle_bookings: 'vehicle_bookings',
    vehicle_bookings_logs: 'vehicle_bookings_logs',
    vehicle_bookings_bills: 'vehicle_bookings_bills',
    bills_payment: 'bills_payment'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb<ClientOptions = {}> extends $Utils.Fn<{extArgs: $Extensions.InternalArgs }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], ClientOptions extends { omit: infer OmitOptions } ? OmitOptions : {}>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> = {
    globalOmitOptions: {
      omit: GlobalOmitOptions
    }
    meta: {
      modelProps: "users" | "brands" | "models" | "variants" | "states" | "cities" | "checklist_categories" | "checklist_options" | "vehicle" | "vehicle_features" | "vehicle_images" | "vehicle_availability" | "vehicle_availability_history" | "vehicle_inspection" | "vehicle_inspection_details" | "vehicle_prices" | "customer" | "providers" | "vehicle_bookings" | "vehicle_bookings_logs" | "vehicle_bookings_bills" | "bills_payment"
      txIsolationLevel: never
    }
    model: {
      users: {
        payload: Prisma.$usersPayload<ExtArgs>
        fields: Prisma.usersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.usersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.usersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findFirst: {
            args: Prisma.usersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.usersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          findMany: {
            args: Prisma.usersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>[]
          }
          create: {
            args: Prisma.usersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          createMany: {
            args: Prisma.usersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.usersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          update: {
            args: Prisma.usersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          deleteMany: {
            args: Prisma.usersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.usersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.usersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$usersPayload>
          }
          aggregate: {
            args: Prisma.UsersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUsers>
          }
          groupBy: {
            args: Prisma.usersGroupByArgs<ExtArgs>
            result: $Utils.Optional<UsersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.usersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.usersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.usersCountArgs<ExtArgs>
            result: $Utils.Optional<UsersCountAggregateOutputType> | number
          }
        }
      }
      brands: {
        payload: Prisma.$brandsPayload<ExtArgs>
        fields: Prisma.brandsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.brandsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.brandsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findFirst: {
            args: Prisma.brandsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.brandsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          findMany: {
            args: Prisma.brandsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>[]
          }
          create: {
            args: Prisma.brandsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          createMany: {
            args: Prisma.brandsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.brandsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          update: {
            args: Prisma.brandsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          deleteMany: {
            args: Prisma.brandsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.brandsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.brandsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$brandsPayload>
          }
          aggregate: {
            args: Prisma.BrandsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBrands>
          }
          groupBy: {
            args: Prisma.brandsGroupByArgs<ExtArgs>
            result: $Utils.Optional<BrandsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.brandsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.brandsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.brandsCountArgs<ExtArgs>
            result: $Utils.Optional<BrandsCountAggregateOutputType> | number
          }
        }
      }
      models: {
        payload: Prisma.$modelsPayload<ExtArgs>
        fields: Prisma.modelsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.modelsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.modelsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          findFirst: {
            args: Prisma.modelsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.modelsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          findMany: {
            args: Prisma.modelsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>[]
          }
          create: {
            args: Prisma.modelsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          createMany: {
            args: Prisma.modelsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.modelsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          update: {
            args: Prisma.modelsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          deleteMany: {
            args: Prisma.modelsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.modelsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.modelsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$modelsPayload>
          }
          aggregate: {
            args: Prisma.ModelsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateModels>
          }
          groupBy: {
            args: Prisma.modelsGroupByArgs<ExtArgs>
            result: $Utils.Optional<ModelsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.modelsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.modelsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.modelsCountArgs<ExtArgs>
            result: $Utils.Optional<ModelsCountAggregateOutputType> | number
          }
        }
      }
      variants: {
        payload: Prisma.$variantsPayload<ExtArgs>
        fields: Prisma.variantsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.variantsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.variantsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          findFirst: {
            args: Prisma.variantsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.variantsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          findMany: {
            args: Prisma.variantsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>[]
          }
          create: {
            args: Prisma.variantsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          createMany: {
            args: Prisma.variantsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.variantsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          update: {
            args: Prisma.variantsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          deleteMany: {
            args: Prisma.variantsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.variantsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.variantsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$variantsPayload>
          }
          aggregate: {
            args: Prisma.VariantsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVariants>
          }
          groupBy: {
            args: Prisma.variantsGroupByArgs<ExtArgs>
            result: $Utils.Optional<VariantsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.variantsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.variantsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.variantsCountArgs<ExtArgs>
            result: $Utils.Optional<VariantsCountAggregateOutputType> | number
          }
        }
      }
      states: {
        payload: Prisma.$statesPayload<ExtArgs>
        fields: Prisma.statesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.statesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.statesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>
          }
          findFirst: {
            args: Prisma.statesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.statesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>
          }
          findMany: {
            args: Prisma.statesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>[]
          }
          create: {
            args: Prisma.statesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>
          }
          createMany: {
            args: Prisma.statesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.statesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>
          }
          update: {
            args: Prisma.statesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>
          }
          deleteMany: {
            args: Prisma.statesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.statesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.statesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$statesPayload>
          }
          aggregate: {
            args: Prisma.StatesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateStates>
          }
          groupBy: {
            args: Prisma.statesGroupByArgs<ExtArgs>
            result: $Utils.Optional<StatesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.statesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.statesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.statesCountArgs<ExtArgs>
            result: $Utils.Optional<StatesCountAggregateOutputType> | number
          }
        }
      }
      cities: {
        payload: Prisma.$citiesPayload<ExtArgs>
        fields: Prisma.citiesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.citiesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.citiesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          findFirst: {
            args: Prisma.citiesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.citiesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          findMany: {
            args: Prisma.citiesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>[]
          }
          create: {
            args: Prisma.citiesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          createMany: {
            args: Prisma.citiesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.citiesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          update: {
            args: Prisma.citiesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          deleteMany: {
            args: Prisma.citiesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.citiesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.citiesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$citiesPayload>
          }
          aggregate: {
            args: Prisma.CitiesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCities>
          }
          groupBy: {
            args: Prisma.citiesGroupByArgs<ExtArgs>
            result: $Utils.Optional<CitiesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.citiesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.citiesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.citiesCountArgs<ExtArgs>
            result: $Utils.Optional<CitiesCountAggregateOutputType> | number
          }
        }
      }
      checklist_categories: {
        payload: Prisma.$checklist_categoriesPayload<ExtArgs>
        fields: Prisma.checklist_categoriesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.checklist_categoriesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.checklist_categoriesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>
          }
          findFirst: {
            args: Prisma.checklist_categoriesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.checklist_categoriesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>
          }
          findMany: {
            args: Prisma.checklist_categoriesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>[]
          }
          create: {
            args: Prisma.checklist_categoriesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>
          }
          createMany: {
            args: Prisma.checklist_categoriesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.checklist_categoriesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>
          }
          update: {
            args: Prisma.checklist_categoriesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>
          }
          deleteMany: {
            args: Prisma.checklist_categoriesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.checklist_categoriesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.checklist_categoriesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_categoriesPayload>
          }
          aggregate: {
            args: Prisma.Checklist_categoriesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChecklist_categories>
          }
          groupBy: {
            args: Prisma.checklist_categoriesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Checklist_categoriesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.checklist_categoriesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.checklist_categoriesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.checklist_categoriesCountArgs<ExtArgs>
            result: $Utils.Optional<Checklist_categoriesCountAggregateOutputType> | number
          }
        }
      }
      checklist_options: {
        payload: Prisma.$checklist_optionsPayload<ExtArgs>
        fields: Prisma.checklist_optionsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.checklist_optionsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.checklist_optionsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>
          }
          findFirst: {
            args: Prisma.checklist_optionsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.checklist_optionsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>
          }
          findMany: {
            args: Prisma.checklist_optionsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>[]
          }
          create: {
            args: Prisma.checklist_optionsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>
          }
          createMany: {
            args: Prisma.checklist_optionsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.checklist_optionsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>
          }
          update: {
            args: Prisma.checklist_optionsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>
          }
          deleteMany: {
            args: Prisma.checklist_optionsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.checklist_optionsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.checklist_optionsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$checklist_optionsPayload>
          }
          aggregate: {
            args: Prisma.Checklist_optionsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateChecklist_options>
          }
          groupBy: {
            args: Prisma.checklist_optionsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Checklist_optionsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.checklist_optionsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.checklist_optionsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.checklist_optionsCountArgs<ExtArgs>
            result: $Utils.Optional<Checklist_optionsCountAggregateOutputType> | number
          }
        }
      }
      vehicle: {
        payload: Prisma.$vehiclePayload<ExtArgs>
        fields: Prisma.vehicleFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicleFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicleFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>
          }
          findFirst: {
            args: Prisma.vehicleFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicleFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>
          }
          findMany: {
            args: Prisma.vehicleFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>[]
          }
          create: {
            args: Prisma.vehicleCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>
          }
          createMany: {
            args: Prisma.vehicleCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicleDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>
          }
          update: {
            args: Prisma.vehicleUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>
          }
          deleteMany: {
            args: Prisma.vehicleDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicleUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicleUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehiclePayload>
          }
          aggregate: {
            args: Prisma.VehicleAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle>
          }
          groupBy: {
            args: Prisma.vehicleGroupByArgs<ExtArgs>
            result: $Utils.Optional<VehicleGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicleFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicleAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicleCountArgs<ExtArgs>
            result: $Utils.Optional<VehicleCountAggregateOutputType> | number
          }
        }
      }
      vehicle_features: {
        payload: Prisma.$vehicle_featuresPayload<ExtArgs>
        fields: Prisma.vehicle_featuresFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_featuresFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_featuresFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>
          }
          findFirst: {
            args: Prisma.vehicle_featuresFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_featuresFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>
          }
          findMany: {
            args: Prisma.vehicle_featuresFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>[]
          }
          create: {
            args: Prisma.vehicle_featuresCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>
          }
          createMany: {
            args: Prisma.vehicle_featuresCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_featuresDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>
          }
          update: {
            args: Prisma.vehicle_featuresUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_featuresDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_featuresUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_featuresUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_featuresPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_featuresAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_features>
          }
          groupBy: {
            args: Prisma.vehicle_featuresGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_featuresGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_featuresFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_featuresAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_featuresCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_featuresCountAggregateOutputType> | number
          }
        }
      }
      vehicle_images: {
        payload: Prisma.$vehicle_imagesPayload<ExtArgs>
        fields: Prisma.vehicle_imagesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_imagesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_imagesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>
          }
          findFirst: {
            args: Prisma.vehicle_imagesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_imagesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>
          }
          findMany: {
            args: Prisma.vehicle_imagesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>[]
          }
          create: {
            args: Prisma.vehicle_imagesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>
          }
          createMany: {
            args: Prisma.vehicle_imagesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_imagesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>
          }
          update: {
            args: Prisma.vehicle_imagesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_imagesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_imagesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_imagesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_imagesPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_imagesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_images>
          }
          groupBy: {
            args: Prisma.vehicle_imagesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_imagesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_imagesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_imagesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_imagesCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_imagesCountAggregateOutputType> | number
          }
        }
      }
      vehicle_availability: {
        payload: Prisma.$vehicle_availabilityPayload<ExtArgs>
        fields: Prisma.vehicle_availabilityFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_availabilityFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_availabilityFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>
          }
          findFirst: {
            args: Prisma.vehicle_availabilityFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_availabilityFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>
          }
          findMany: {
            args: Prisma.vehicle_availabilityFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>[]
          }
          create: {
            args: Prisma.vehicle_availabilityCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>
          }
          createMany: {
            args: Prisma.vehicle_availabilityCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_availabilityDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>
          }
          update: {
            args: Prisma.vehicle_availabilityUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_availabilityDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_availabilityUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_availabilityUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availabilityPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_availabilityAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_availability>
          }
          groupBy: {
            args: Prisma.vehicle_availabilityGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_availabilityGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_availabilityFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_availabilityAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_availabilityCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_availabilityCountAggregateOutputType> | number
          }
        }
      }
      vehicle_availability_history: {
        payload: Prisma.$vehicle_availability_historyPayload<ExtArgs>
        fields: Prisma.vehicle_availability_historyFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_availability_historyFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_availability_historyFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>
          }
          findFirst: {
            args: Prisma.vehicle_availability_historyFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_availability_historyFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>
          }
          findMany: {
            args: Prisma.vehicle_availability_historyFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>[]
          }
          create: {
            args: Prisma.vehicle_availability_historyCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>
          }
          createMany: {
            args: Prisma.vehicle_availability_historyCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_availability_historyDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>
          }
          update: {
            args: Prisma.vehicle_availability_historyUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_availability_historyDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_availability_historyUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_availability_historyUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_availability_historyPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_availability_historyAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_availability_history>
          }
          groupBy: {
            args: Prisma.vehicle_availability_historyGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_availability_historyGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_availability_historyFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_availability_historyAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_availability_historyCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_availability_historyCountAggregateOutputType> | number
          }
        }
      }
      vehicle_inspection: {
        payload: Prisma.$vehicle_inspectionPayload<ExtArgs>
        fields: Prisma.vehicle_inspectionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_inspectionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_inspectionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>
          }
          findFirst: {
            args: Prisma.vehicle_inspectionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_inspectionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>
          }
          findMany: {
            args: Prisma.vehicle_inspectionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>[]
          }
          create: {
            args: Prisma.vehicle_inspectionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>
          }
          createMany: {
            args: Prisma.vehicle_inspectionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_inspectionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>
          }
          update: {
            args: Prisma.vehicle_inspectionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_inspectionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_inspectionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_inspectionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspectionPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_inspectionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_inspection>
          }
          groupBy: {
            args: Prisma.vehicle_inspectionGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_inspectionGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_inspectionFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_inspectionAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_inspectionCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_inspectionCountAggregateOutputType> | number
          }
        }
      }
      vehicle_inspection_details: {
        payload: Prisma.$vehicle_inspection_detailsPayload<ExtArgs>
        fields: Prisma.vehicle_inspection_detailsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_inspection_detailsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_inspection_detailsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>
          }
          findFirst: {
            args: Prisma.vehicle_inspection_detailsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_inspection_detailsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>
          }
          findMany: {
            args: Prisma.vehicle_inspection_detailsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>[]
          }
          create: {
            args: Prisma.vehicle_inspection_detailsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>
          }
          createMany: {
            args: Prisma.vehicle_inspection_detailsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_inspection_detailsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>
          }
          update: {
            args: Prisma.vehicle_inspection_detailsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_inspection_detailsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_inspection_detailsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_inspection_detailsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_inspection_detailsPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_inspection_detailsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_inspection_details>
          }
          groupBy: {
            args: Prisma.vehicle_inspection_detailsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_inspection_detailsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_inspection_detailsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_inspection_detailsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_inspection_detailsCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_inspection_detailsCountAggregateOutputType> | number
          }
        }
      }
      vehicle_prices: {
        payload: Prisma.$vehicle_pricesPayload<ExtArgs>
        fields: Prisma.vehicle_pricesFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_pricesFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_pricesFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>
          }
          findFirst: {
            args: Prisma.vehicle_pricesFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_pricesFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>
          }
          findMany: {
            args: Prisma.vehicle_pricesFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>[]
          }
          create: {
            args: Prisma.vehicle_pricesCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>
          }
          createMany: {
            args: Prisma.vehicle_pricesCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_pricesDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>
          }
          update: {
            args: Prisma.vehicle_pricesUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_pricesDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_pricesUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_pricesUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_pricesPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_pricesAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_prices>
          }
          groupBy: {
            args: Prisma.vehicle_pricesGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_pricesGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_pricesFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_pricesAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_pricesCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_pricesCountAggregateOutputType> | number
          }
        }
      }
      customer: {
        payload: Prisma.$customerPayload<ExtArgs>
        fields: Prisma.customerFieldRefs
        operations: {
          findUnique: {
            args: Prisma.customerFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.customerFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findFirst: {
            args: Prisma.customerFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.customerFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          findMany: {
            args: Prisma.customerFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>[]
          }
          create: {
            args: Prisma.customerCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          createMany: {
            args: Prisma.customerCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.customerDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          update: {
            args: Prisma.customerUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          deleteMany: {
            args: Prisma.customerDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.customerUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.customerUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$customerPayload>
          }
          aggregate: {
            args: Prisma.CustomerAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateCustomer>
          }
          groupBy: {
            args: Prisma.customerGroupByArgs<ExtArgs>
            result: $Utils.Optional<CustomerGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.customerFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.customerAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.customerCountArgs<ExtArgs>
            result: $Utils.Optional<CustomerCountAggregateOutputType> | number
          }
        }
      }
      providers: {
        payload: Prisma.$providersPayload<ExtArgs>
        fields: Prisma.providersFieldRefs
        operations: {
          findUnique: {
            args: Prisma.providersFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.providersFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          findFirst: {
            args: Prisma.providersFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.providersFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          findMany: {
            args: Prisma.providersFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>[]
          }
          create: {
            args: Prisma.providersCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          createMany: {
            args: Prisma.providersCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.providersDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          update: {
            args: Prisma.providersUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          deleteMany: {
            args: Prisma.providersDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.providersUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.providersUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$providersPayload>
          }
          aggregate: {
            args: Prisma.ProvidersAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateProviders>
          }
          groupBy: {
            args: Prisma.providersGroupByArgs<ExtArgs>
            result: $Utils.Optional<ProvidersGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.providersFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.providersAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.providersCountArgs<ExtArgs>
            result: $Utils.Optional<ProvidersCountAggregateOutputType> | number
          }
        }
      }
      vehicle_bookings: {
        payload: Prisma.$vehicle_bookingsPayload<ExtArgs>
        fields: Prisma.vehicle_bookingsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_bookingsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_bookingsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>
          }
          findFirst: {
            args: Prisma.vehicle_bookingsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_bookingsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>
          }
          findMany: {
            args: Prisma.vehicle_bookingsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>[]
          }
          create: {
            args: Prisma.vehicle_bookingsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>
          }
          createMany: {
            args: Prisma.vehicle_bookingsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_bookingsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>
          }
          update: {
            args: Prisma.vehicle_bookingsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_bookingsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_bookingsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_bookingsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookingsPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_bookingsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_bookings>
          }
          groupBy: {
            args: Prisma.vehicle_bookingsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_bookingsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_bookingsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_bookingsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_bookingsCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_bookingsCountAggregateOutputType> | number
          }
        }
      }
      vehicle_bookings_logs: {
        payload: Prisma.$vehicle_bookings_logsPayload<ExtArgs>
        fields: Prisma.vehicle_bookings_logsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_bookings_logsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_bookings_logsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>
          }
          findFirst: {
            args: Prisma.vehicle_bookings_logsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_bookings_logsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>
          }
          findMany: {
            args: Prisma.vehicle_bookings_logsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>[]
          }
          create: {
            args: Prisma.vehicle_bookings_logsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>
          }
          createMany: {
            args: Prisma.vehicle_bookings_logsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_bookings_logsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>
          }
          update: {
            args: Prisma.vehicle_bookings_logsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_bookings_logsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_bookings_logsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_bookings_logsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_logsPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_bookings_logsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_bookings_logs>
          }
          groupBy: {
            args: Prisma.vehicle_bookings_logsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_bookings_logsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_bookings_logsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_bookings_logsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_bookings_logsCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_bookings_logsCountAggregateOutputType> | number
          }
        }
      }
      vehicle_bookings_bills: {
        payload: Prisma.$vehicle_bookings_billsPayload<ExtArgs>
        fields: Prisma.vehicle_bookings_billsFieldRefs
        operations: {
          findUnique: {
            args: Prisma.vehicle_bookings_billsFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.vehicle_bookings_billsFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>
          }
          findFirst: {
            args: Prisma.vehicle_bookings_billsFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.vehicle_bookings_billsFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>
          }
          findMany: {
            args: Prisma.vehicle_bookings_billsFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>[]
          }
          create: {
            args: Prisma.vehicle_bookings_billsCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>
          }
          createMany: {
            args: Prisma.vehicle_bookings_billsCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.vehicle_bookings_billsDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>
          }
          update: {
            args: Prisma.vehicle_bookings_billsUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>
          }
          deleteMany: {
            args: Prisma.vehicle_bookings_billsDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.vehicle_bookings_billsUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.vehicle_bookings_billsUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$vehicle_bookings_billsPayload>
          }
          aggregate: {
            args: Prisma.Vehicle_bookings_billsAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateVehicle_bookings_bills>
          }
          groupBy: {
            args: Prisma.vehicle_bookings_billsGroupByArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_bookings_billsGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.vehicle_bookings_billsFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.vehicle_bookings_billsAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.vehicle_bookings_billsCountArgs<ExtArgs>
            result: $Utils.Optional<Vehicle_bookings_billsCountAggregateOutputType> | number
          }
        }
      }
      bills_payment: {
        payload: Prisma.$bills_paymentPayload<ExtArgs>
        fields: Prisma.bills_paymentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.bills_paymentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.bills_paymentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>
          }
          findFirst: {
            args: Prisma.bills_paymentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.bills_paymentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>
          }
          findMany: {
            args: Prisma.bills_paymentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>[]
          }
          create: {
            args: Prisma.bills_paymentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>
          }
          createMany: {
            args: Prisma.bills_paymentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          delete: {
            args: Prisma.bills_paymentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>
          }
          update: {
            args: Prisma.bills_paymentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>
          }
          deleteMany: {
            args: Prisma.bills_paymentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.bills_paymentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.bills_paymentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$bills_paymentPayload>
          }
          aggregate: {
            args: Prisma.Bills_paymentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBills_payment>
          }
          groupBy: {
            args: Prisma.bills_paymentGroupByArgs<ExtArgs>
            result: $Utils.Optional<Bills_paymentGroupByOutputType>[]
          }
          findRaw: {
            args: Prisma.bills_paymentFindRawArgs<ExtArgs>
            result: JsonObject
          }
          aggregateRaw: {
            args: Prisma.bills_paymentAggregateRawArgs<ExtArgs>
            result: JsonObject
          }
          count: {
            args: Prisma.bills_paymentCountArgs<ExtArgs>
            result: $Utils.Optional<Bills_paymentCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $runCommandRaw: {
          args: Prisma.InputJsonObject,
          result: Prisma.JsonObject
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Shorthand for `emit: 'stdout'`
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events only
     * log: [
     *   { emit: 'event', level: 'query' },
     *   { emit: 'event', level: 'info' },
     *   { emit: 'event', level: 'warn' }
     *   { emit: 'event', level: 'error' }
     * ]
     * 
     * / Emit as events and log to stdout
     * og: [
     *  { emit: 'stdout', level: 'query' },
     *  { emit: 'stdout', level: 'info' },
     *  { emit: 'stdout', level: 'warn' }
     *  { emit: 'stdout', level: 'error' }
     * 
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
    }
    /**
     * Global configuration for omitting model fields by default.
     * 
     * @example
     * ```
     * const prisma = new PrismaClient({
     *   omit: {
     *     user: {
     *       password: true
     *     }
     *   }
     * })
     * ```
     */
    omit?: Prisma.GlobalOmitConfig
  }
  export type GlobalOmitConfig = {
    users?: usersOmit
    brands?: brandsOmit
    models?: modelsOmit
    variants?: variantsOmit
    states?: statesOmit
    cities?: citiesOmit
    checklist_categories?: checklist_categoriesOmit
    checklist_options?: checklist_optionsOmit
    vehicle?: vehicleOmit
    vehicle_features?: vehicle_featuresOmit
    vehicle_images?: vehicle_imagesOmit
    vehicle_availability?: vehicle_availabilityOmit
    vehicle_availability_history?: vehicle_availability_historyOmit
    vehicle_inspection?: vehicle_inspectionOmit
    vehicle_inspection_details?: vehicle_inspection_detailsOmit
    vehicle_prices?: vehicle_pricesOmit
    customer?: customerOmit
    providers?: providersOmit
    vehicle_bookings?: vehicle_bookingsOmit
    vehicle_bookings_logs?: vehicle_bookings_logsOmit
    vehicle_bookings_bills?: vehicle_bookings_billsOmit
    bills_payment?: bills_paymentOmit
  }

  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type CheckIsLogLevel<T> = T extends LogLevel ? T : never;

  export type GetLogType<T> = CheckIsLogLevel<
    T extends LogDefinition ? T['level'] : T
  >;

  export type GetEvents<T extends any[]> = T extends Array<LogLevel | LogDefinition>
    ? GetLogType<T[number]>
    : never;

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'updateManyAndReturn'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type BrandsCountOutputType
   */

  export type BrandsCountOutputType = {
    models: number
    variants: number
    vehicle: number
  }

  export type BrandsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | BrandsCountOutputTypeCountModelsArgs
    variants?: boolean | BrandsCountOutputTypeCountVariantsArgs
    vehicle?: boolean | BrandsCountOutputTypeCountVehicleArgs
  }

  // Custom InputTypes
  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BrandsCountOutputType
     */
    select?: BrandsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountModelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: variantsWhereInput
  }

  /**
   * BrandsCountOutputType without action
   */
  export type BrandsCountOutputTypeCountVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicleWhereInput
  }


  /**
   * Count Type ModelsCountOutputType
   */

  export type ModelsCountOutputType = {
    variants: number
    vehicle: number
  }

  export type ModelsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    variants?: boolean | ModelsCountOutputTypeCountVariantsArgs
    vehicle?: boolean | ModelsCountOutputTypeCountVehicleArgs
  }

  // Custom InputTypes
  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ModelsCountOutputType
     */
    select?: ModelsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeCountVariantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: variantsWhereInput
  }

  /**
   * ModelsCountOutputType without action
   */
  export type ModelsCountOutputTypeCountVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicleWhereInput
  }


  /**
   * Count Type VariantsCountOutputType
   */

  export type VariantsCountOutputType = {
    vehicle: number
  }

  export type VariantsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | VariantsCountOutputTypeCountVehicleArgs
  }

  // Custom InputTypes
  /**
   * VariantsCountOutputType without action
   */
  export type VariantsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VariantsCountOutputType
     */
    select?: VariantsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VariantsCountOutputType without action
   */
  export type VariantsCountOutputTypeCountVehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicleWhereInput
  }


  /**
   * Count Type StatesCountOutputType
   */

  export type StatesCountOutputType = {
    cities: number
    customers: number
    providers: number
  }

  export type StatesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | StatesCountOutputTypeCountCitiesArgs
    customers?: boolean | StatesCountOutputTypeCountCustomersArgs
    providers?: boolean | StatesCountOutputTypeCountProvidersArgs
  }

  // Custom InputTypes
  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the StatesCountOutputType
     */
    select?: StatesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeCountCitiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citiesWhereInput
  }

  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * StatesCountOutputType without action
   */
  export type StatesCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
  }


  /**
   * Count Type CitiesCountOutputType
   */

  export type CitiesCountOutputType = {
    customers: number
    providers: number
  }

  export type CitiesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    customers?: boolean | CitiesCountOutputTypeCountCustomersArgs
    providers?: boolean | CitiesCountOutputTypeCountProvidersArgs
  }

  // Custom InputTypes
  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CitiesCountOutputType
     */
    select?: CitiesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeCountCustomersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
  }

  /**
   * CitiesCountOutputType without action
   */
  export type CitiesCountOutputTypeCountProvidersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
  }


  /**
   * Count Type Checklist_categoriesCountOutputType
   */

  export type Checklist_categoriesCountOutputType = {
    options: number
  }

  export type Checklist_categoriesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | Checklist_categoriesCountOutputTypeCountOptionsArgs
  }

  // Custom InputTypes
  /**
   * Checklist_categoriesCountOutputType without action
   */
  export type Checklist_categoriesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist_categoriesCountOutputType
     */
    select?: Checklist_categoriesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Checklist_categoriesCountOutputType without action
   */
  export type Checklist_categoriesCountOutputTypeCountOptionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checklist_optionsWhereInput
  }


  /**
   * Count Type Checklist_optionsCountOutputType
   */

  export type Checklist_optionsCountOutputType = {
    inspectionDetails: number
  }

  export type Checklist_optionsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    inspectionDetails?: boolean | Checklist_optionsCountOutputTypeCountInspectionDetailsArgs
  }

  // Custom InputTypes
  /**
   * Checklist_optionsCountOutputType without action
   */
  export type Checklist_optionsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Checklist_optionsCountOutputType
     */
    select?: Checklist_optionsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Checklist_optionsCountOutputType without action
   */
  export type Checklist_optionsCountOutputTypeCountInspectionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_inspection_detailsWhereInput
  }


  /**
   * Count Type VehicleCountOutputType
   */

  export type VehicleCountOutputType = {
    features: number
    images: number
    availability: number
    availability_history: number
    inspections: number
    prices: number
    bookings: number
    booking_logs: number
  }

  export type VehicleCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    features?: boolean | VehicleCountOutputTypeCountFeaturesArgs
    images?: boolean | VehicleCountOutputTypeCountImagesArgs
    availability?: boolean | VehicleCountOutputTypeCountAvailabilityArgs
    availability_history?: boolean | VehicleCountOutputTypeCountAvailability_historyArgs
    inspections?: boolean | VehicleCountOutputTypeCountInspectionsArgs
    prices?: boolean | VehicleCountOutputTypeCountPricesArgs
    bookings?: boolean | VehicleCountOutputTypeCountBookingsArgs
    booking_logs?: boolean | VehicleCountOutputTypeCountBooking_logsArgs
  }

  // Custom InputTypes
  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the VehicleCountOutputType
     */
    select?: VehicleCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountFeaturesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_featuresWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountImagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_imagesWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountAvailabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_availabilityWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountAvailability_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_availability_historyWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountInspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_inspectionWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountPricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_pricesWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookingsWhereInput
  }

  /**
   * VehicleCountOutputType without action
   */
  export type VehicleCountOutputTypeCountBooking_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_logsWhereInput
  }


  /**
   * Count Type Vehicle_inspectionCountOutputType
   */

  export type Vehicle_inspectionCountOutputType = {
    details: number
  }

  export type Vehicle_inspectionCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    details?: boolean | Vehicle_inspectionCountOutputTypeCountDetailsArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_inspectionCountOutputType without action
   */
  export type Vehicle_inspectionCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_inspectionCountOutputType
     */
    select?: Vehicle_inspectionCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_inspectionCountOutputType without action
   */
  export type Vehicle_inspectionCountOutputTypeCountDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_inspection_detailsWhereInput
  }


  /**
   * Count Type Vehicle_pricesCountOutputType
   */

  export type Vehicle_pricesCountOutputType = {
    bills: number
  }

  export type Vehicle_pricesCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills?: boolean | Vehicle_pricesCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_pricesCountOutputType without action
   */
  export type Vehicle_pricesCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_pricesCountOutputType
     */
    select?: Vehicle_pricesCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_pricesCountOutputType without action
   */
  export type Vehicle_pricesCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_billsWhereInput
  }


  /**
   * Count Type CustomerCountOutputType
   */

  export type CustomerCountOutputType = {
    vehicle_bookings: number
    vehicle_bookings_logs: number
    vehicle_bookings_bills: number
  }

  export type CustomerCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_bookings?: boolean | CustomerCountOutputTypeCountVehicle_bookingsArgs
    vehicle_bookings_logs?: boolean | CustomerCountOutputTypeCountVehicle_bookings_logsArgs
    vehicle_bookings_bills?: boolean | CustomerCountOutputTypeCountVehicle_bookings_billsArgs
  }

  // Custom InputTypes
  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the CustomerCountOutputType
     */
    select?: CustomerCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVehicle_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookingsWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVehicle_bookings_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_logsWhereInput
  }

  /**
   * CustomerCountOutputType without action
   */
  export type CustomerCountOutputTypeCountVehicle_bookings_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_billsWhereInput
  }


  /**
   * Count Type Vehicle_bookingsCountOutputType
   */

  export type Vehicle_bookingsCountOutputType = {
    vehicle_inspection: number
    booking_logs: number
    bills: number
  }

  export type Vehicle_bookingsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_inspection?: boolean | Vehicle_bookingsCountOutputTypeCountVehicle_inspectionArgs
    booking_logs?: boolean | Vehicle_bookingsCountOutputTypeCountBooking_logsArgs
    bills?: boolean | Vehicle_bookingsCountOutputTypeCountBillsArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_bookingsCountOutputType without action
   */
  export type Vehicle_bookingsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_bookingsCountOutputType
     */
    select?: Vehicle_bookingsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_bookingsCountOutputType without action
   */
  export type Vehicle_bookingsCountOutputTypeCountVehicle_inspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_inspectionWhereInput
  }

  /**
   * Vehicle_bookingsCountOutputType without action
   */
  export type Vehicle_bookingsCountOutputTypeCountBooking_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_logsWhereInput
  }

  /**
   * Vehicle_bookingsCountOutputType without action
   */
  export type Vehicle_bookingsCountOutputTypeCountBillsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_billsWhereInput
  }


  /**
   * Count Type Vehicle_bookings_billsCountOutputType
   */

  export type Vehicle_bookings_billsCountOutputType = {
    bills_payment: number
  }

  export type Vehicle_bookings_billsCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bills_payment?: boolean | Vehicle_bookings_billsCountOutputTypeCountBills_paymentArgs
  }

  // Custom InputTypes
  /**
   * Vehicle_bookings_billsCountOutputType without action
   */
  export type Vehicle_bookings_billsCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Vehicle_bookings_billsCountOutputType
     */
    select?: Vehicle_bookings_billsCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * Vehicle_bookings_billsCountOutputType without action
   */
  export type Vehicle_bookings_billsCountOutputTypeCountBills_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bills_paymentWhereInput
  }


  /**
   * Models
   */

  /**
   * Model users
   */

  export type AggregateUsers = {
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  export type UsersMinAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    role_id: $Enums.role | null
    is_active: boolean | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    username: string | null
    role_id: $Enums.role | null
    is_active: boolean | null
    password: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UsersCountAggregateOutputType = {
    id: number
    name: number
    username: number
    role_id: number
    is_active: number
    password: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UsersMinAggregateInputType = {
    id?: true
    name?: true
    username?: true
    role_id?: true
    is_active?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersMaxAggregateInputType = {
    id?: true
    name?: true
    username?: true
    role_id?: true
    is_active?: true
    password?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UsersCountAggregateInputType = {
    id?: true
    name?: true
    username?: true
    role_id?: true
    is_active?: true
    password?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UsersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to aggregate.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned users
    **/
    _count?: true | UsersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UsersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UsersMaxAggregateInputType
  }

  export type GetUsersAggregateType<T extends UsersAggregateArgs> = {
        [P in keyof T & keyof AggregateUsers]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUsers[P]>
      : GetScalarType<T[P], AggregateUsers[P]>
  }




  export type usersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: usersWhereInput
    orderBy?: usersOrderByWithAggregationInput | usersOrderByWithAggregationInput[]
    by: UsersScalarFieldEnum[] | UsersScalarFieldEnum
    having?: usersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UsersCountAggregateInputType | true
    _min?: UsersMinAggregateInputType
    _max?: UsersMaxAggregateInputType
  }

  export type UsersGroupByOutputType = {
    id: string
    name: string
    username: string
    role_id: $Enums.role
    is_active: boolean
    password: string
    createdAt: Date
    updatedAt: Date
    _count: UsersCountAggregateOutputType | null
    _min: UsersMinAggregateOutputType | null
    _max: UsersMaxAggregateOutputType | null
  }

  type GetUsersGroupByPayload<T extends usersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UsersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UsersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UsersGroupByOutputType[P]>
            : GetScalarType<T[P], UsersGroupByOutputType[P]>
        }
      >
    >


  export type usersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    username?: boolean
    role_id?: boolean
    is_active?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["users"]>



  export type usersSelectScalar = {
    id?: boolean
    name?: boolean
    username?: boolean
    role_id?: boolean
    is_active?: boolean
    password?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type usersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "username" | "role_id" | "is_active" | "password" | "createdAt" | "updatedAt", ExtArgs["result"]["users"]>

  export type $usersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "users"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      username: string
      role_id: $Enums.role
      is_active: boolean
      password: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["users"]>
    composites: {}
  }

  type usersGetPayload<S extends boolean | null | undefined | usersDefaultArgs> = $Result.GetResult<Prisma.$usersPayload, S>

  type usersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<usersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: UsersCountAggregateInputType | true
    }

  export interface usersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['users'], meta: { name: 'users' } }
    /**
     * Find zero or one Users that matches the filter.
     * @param {usersFindUniqueArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends usersFindUniqueArgs>(args: SelectSubset<T, usersFindUniqueArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Users that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {usersFindUniqueOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends usersFindUniqueOrThrowArgs>(args: SelectSubset<T, usersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends usersFindFirstArgs>(args?: SelectSubset<T, usersFindFirstArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Users that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindFirstOrThrowArgs} args - Arguments to find a Users
     * @example
     * // Get one Users
     * const users = await prisma.users.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends usersFindFirstOrThrowArgs>(args?: SelectSubset<T, usersFindFirstOrThrowArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.users.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.users.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const usersWithIdOnly = await prisma.users.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends usersFindManyArgs>(args?: SelectSubset<T, usersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Users.
     * @param {usersCreateArgs} args - Arguments to create a Users.
     * @example
     * // Create one Users
     * const Users = await prisma.users.create({
     *   data: {
     *     // ... data to create a Users
     *   }
     * })
     * 
     */
    create<T extends usersCreateArgs>(args: SelectSubset<T, usersCreateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Users.
     * @param {usersCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const users = await prisma.users.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends usersCreateManyArgs>(args?: SelectSubset<T, usersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Users.
     * @param {usersDeleteArgs} args - Arguments to delete one Users.
     * @example
     * // Delete one Users
     * const Users = await prisma.users.delete({
     *   where: {
     *     // ... filter to delete one Users
     *   }
     * })
     * 
     */
    delete<T extends usersDeleteArgs>(args: SelectSubset<T, usersDeleteArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Users.
     * @param {usersUpdateArgs} args - Arguments to update one Users.
     * @example
     * // Update one Users
     * const users = await prisma.users.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends usersUpdateArgs>(args: SelectSubset<T, usersUpdateArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Users.
     * @param {usersDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.users.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends usersDeleteManyArgs>(args?: SelectSubset<T, usersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const users = await prisma.users.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends usersUpdateManyArgs>(args: SelectSubset<T, usersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Users.
     * @param {usersUpsertArgs} args - Arguments to update or create a Users.
     * @example
     * // Update or create a Users
     * const users = await prisma.users.upsert({
     *   create: {
     *     // ... data to create a Users
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Users we want to update
     *   }
     * })
     */
    upsert<T extends usersUpsertArgs>(args: SelectSubset<T, usersUpsertArgs<ExtArgs>>): Prisma__usersClient<$Result.GetResult<Prisma.$usersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Users that matches the filter.
     * @param {usersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const users = await prisma.users.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: usersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Users.
     * @param {usersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const users = await prisma.users.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: usersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.users.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends usersCountArgs>(
      args?: Subset<T, usersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UsersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UsersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UsersAggregateArgs>(args: Subset<T, UsersAggregateArgs>): Prisma.PrismaPromise<GetUsersAggregateType<T>>

    /**
     * Group by Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {usersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends usersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: usersGroupByArgs['orderBy'] }
        : { orderBy?: usersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, usersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUsersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the users model
   */
  readonly fields: usersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for users.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__usersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the users model
   */
  interface usersFieldRefs {
    readonly id: FieldRef<"users", 'String'>
    readonly name: FieldRef<"users", 'String'>
    readonly username: FieldRef<"users", 'String'>
    readonly role_id: FieldRef<"users", 'role'>
    readonly is_active: FieldRef<"users", 'Boolean'>
    readonly password: FieldRef<"users", 'String'>
    readonly createdAt: FieldRef<"users", 'DateTime'>
    readonly updatedAt: FieldRef<"users", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * users findUnique
   */
  export type usersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findUniqueOrThrow
   */
  export type usersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users findFirst
   */
  export type usersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findFirstOrThrow
   */
  export type usersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of users.
     */
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users findMany
   */
  export type usersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter, which users to fetch.
     */
    where?: usersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of users to fetch.
     */
    orderBy?: usersOrderByWithRelationInput | usersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing users.
     */
    cursor?: usersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` users.
     */
    skip?: number
    distinct?: UsersScalarFieldEnum | UsersScalarFieldEnum[]
  }

  /**
   * users create
   */
  export type usersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to create a users.
     */
    data: XOR<usersCreateInput, usersUncheckedCreateInput>
  }

  /**
   * users createMany
   */
  export type usersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many users.
     */
    data: usersCreateManyInput | usersCreateManyInput[]
  }

  /**
   * users update
   */
  export type usersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The data needed to update a users.
     */
    data: XOR<usersUpdateInput, usersUncheckedUpdateInput>
    /**
     * Choose, which users to update.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users updateMany
   */
  export type usersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update users.
     */
    data: XOR<usersUpdateManyMutationInput, usersUncheckedUpdateManyInput>
    /**
     * Filter which users to update
     */
    where?: usersWhereInput
    /**
     * Limit how many users to update.
     */
    limit?: number
  }

  /**
   * users upsert
   */
  export type usersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * The filter to search for the users to update in case it exists.
     */
    where: usersWhereUniqueInput
    /**
     * In case the users found by the `where` argument doesn't exist, create a new users with this data.
     */
    create: XOR<usersCreateInput, usersUncheckedCreateInput>
    /**
     * In case the users was found with the provided `where` argument, update it with this data.
     */
    update: XOR<usersUpdateInput, usersUncheckedUpdateInput>
  }

  /**
   * users delete
   */
  export type usersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
    /**
     * Filter which users to delete.
     */
    where: usersWhereUniqueInput
  }

  /**
   * users deleteMany
   */
  export type usersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which users to delete
     */
    where?: usersWhereInput
    /**
     * Limit how many users to delete.
     */
    limit?: number
  }

  /**
   * users findRaw
   */
  export type usersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users aggregateRaw
   */
  export type usersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * users without action
   */
  export type usersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the users
     */
    select?: usersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the users
     */
    omit?: usersOmit<ExtArgs> | null
  }


  /**
   * Model brands
   */

  export type AggregateBrands = {
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  export type BrandsMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type BrandsCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type BrandsMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type BrandsCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type BrandsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to aggregate.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned brands
    **/
    _count?: true | BrandsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BrandsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BrandsMaxAggregateInputType
  }

  export type GetBrandsAggregateType<T extends BrandsAggregateArgs> = {
        [P in keyof T & keyof AggregateBrands]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBrands[P]>
      : GetScalarType<T[P], AggregateBrands[P]>
  }




  export type brandsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: brandsWhereInput
    orderBy?: brandsOrderByWithAggregationInput | brandsOrderByWithAggregationInput[]
    by: BrandsScalarFieldEnum[] | BrandsScalarFieldEnum
    having?: brandsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BrandsCountAggregateInputType | true
    _min?: BrandsMinAggregateInputType
    _max?: BrandsMaxAggregateInputType
  }

  export type BrandsGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: BrandsCountAggregateOutputType | null
    _min: BrandsMinAggregateOutputType | null
    _max: BrandsMaxAggregateOutputType | null
  }

  type GetBrandsGroupByPayload<T extends brandsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BrandsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BrandsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BrandsGroupByOutputType[P]>
            : GetScalarType<T[P], BrandsGroupByOutputType[P]>
        }
      >
    >


  export type brandsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    models?: boolean | brands$modelsArgs<ExtArgs>
    variants?: boolean | brands$variantsArgs<ExtArgs>
    vehicle?: boolean | brands$vehicleArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["brands"]>



  export type brandsSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type brandsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["brands"]>
  export type brandsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    models?: boolean | brands$modelsArgs<ExtArgs>
    variants?: boolean | brands$variantsArgs<ExtArgs>
    vehicle?: boolean | brands$vehicleArgs<ExtArgs>
    _count?: boolean | BrandsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $brandsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "brands"
    objects: {
      models: Prisma.$modelsPayload<ExtArgs>[]
      variants: Prisma.$variantsPayload<ExtArgs>[]
      vehicle: Prisma.$vehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["brands"]>
    composites: {}
  }

  type brandsGetPayload<S extends boolean | null | undefined | brandsDefaultArgs> = $Result.GetResult<Prisma.$brandsPayload, S>

  type brandsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<brandsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: BrandsCountAggregateInputType | true
    }

  export interface brandsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['brands'], meta: { name: 'brands' } }
    /**
     * Find zero or one Brands that matches the filter.
     * @param {brandsFindUniqueArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends brandsFindUniqueArgs>(args: SelectSubset<T, brandsFindUniqueArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Brands that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {brandsFindUniqueOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends brandsFindUniqueOrThrowArgs>(args: SelectSubset<T, brandsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends brandsFindFirstArgs>(args?: SelectSubset<T, brandsFindFirstArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Brands that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindFirstOrThrowArgs} args - Arguments to find a Brands
     * @example
     * // Get one Brands
     * const brands = await prisma.brands.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends brandsFindFirstOrThrowArgs>(args?: SelectSubset<T, brandsFindFirstOrThrowArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Brands
     * const brands = await prisma.brands.findMany()
     * 
     * // Get first 10 Brands
     * const brands = await prisma.brands.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const brandsWithIdOnly = await prisma.brands.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends brandsFindManyArgs>(args?: SelectSubset<T, brandsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Brands.
     * @param {brandsCreateArgs} args - Arguments to create a Brands.
     * @example
     * // Create one Brands
     * const Brands = await prisma.brands.create({
     *   data: {
     *     // ... data to create a Brands
     *   }
     * })
     * 
     */
    create<T extends brandsCreateArgs>(args: SelectSubset<T, brandsCreateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Brands.
     * @param {brandsCreateManyArgs} args - Arguments to create many Brands.
     * @example
     * // Create many Brands
     * const brands = await prisma.brands.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends brandsCreateManyArgs>(args?: SelectSubset<T, brandsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Brands.
     * @param {brandsDeleteArgs} args - Arguments to delete one Brands.
     * @example
     * // Delete one Brands
     * const Brands = await prisma.brands.delete({
     *   where: {
     *     // ... filter to delete one Brands
     *   }
     * })
     * 
     */
    delete<T extends brandsDeleteArgs>(args: SelectSubset<T, brandsDeleteArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Brands.
     * @param {brandsUpdateArgs} args - Arguments to update one Brands.
     * @example
     * // Update one Brands
     * const brands = await prisma.brands.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends brandsUpdateArgs>(args: SelectSubset<T, brandsUpdateArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Brands.
     * @param {brandsDeleteManyArgs} args - Arguments to filter Brands to delete.
     * @example
     * // Delete a few Brands
     * const { count } = await prisma.brands.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends brandsDeleteManyArgs>(args?: SelectSubset<T, brandsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Brands
     * const brands = await prisma.brands.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends brandsUpdateManyArgs>(args: SelectSubset<T, brandsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Brands.
     * @param {brandsUpsertArgs} args - Arguments to update or create a Brands.
     * @example
     * // Update or create a Brands
     * const brands = await prisma.brands.upsert({
     *   create: {
     *     // ... data to create a Brands
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Brands we want to update
     *   }
     * })
     */
    upsert<T extends brandsUpsertArgs>(args: SelectSubset<T, brandsUpsertArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Brands that matches the filter.
     * @param {brandsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const brands = await prisma.brands.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: brandsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Brands.
     * @param {brandsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const brands = await prisma.brands.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: brandsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsCountArgs} args - Arguments to filter Brands to count.
     * @example
     * // Count the number of Brands
     * const count = await prisma.brands.count({
     *   where: {
     *     // ... the filter for the Brands we want to count
     *   }
     * })
    **/
    count<T extends brandsCountArgs>(
      args?: Subset<T, brandsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BrandsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BrandsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BrandsAggregateArgs>(args: Subset<T, BrandsAggregateArgs>): Prisma.PrismaPromise<GetBrandsAggregateType<T>>

    /**
     * Group by Brands.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {brandsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends brandsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: brandsGroupByArgs['orderBy'] }
        : { orderBy?: brandsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, brandsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBrandsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the brands model
   */
  readonly fields: brandsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for brands.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__brandsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    models<T extends brands$modelsArgs<ExtArgs> = {}>(args?: Subset<T, brands$modelsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    variants<T extends brands$variantsArgs<ExtArgs> = {}>(args?: Subset<T, brands$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle<T extends brands$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, brands$vehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the brands model
   */
  interface brandsFieldRefs {
    readonly id: FieldRef<"brands", 'String'>
    readonly name: FieldRef<"brands", 'String'>
    readonly createdAt: FieldRef<"brands", 'DateTime'>
    readonly updatedAt: FieldRef<"brands", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * brands findUnique
   */
  export type brandsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findUniqueOrThrow
   */
  export type brandsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands findFirst
   */
  export type brandsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findFirstOrThrow
   */
  export type brandsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of brands.
     */
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands findMany
   */
  export type brandsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter, which brands to fetch.
     */
    where?: brandsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of brands to fetch.
     */
    orderBy?: brandsOrderByWithRelationInput | brandsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing brands.
     */
    cursor?: brandsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` brands from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` brands.
     */
    skip?: number
    distinct?: BrandsScalarFieldEnum | BrandsScalarFieldEnum[]
  }

  /**
   * brands create
   */
  export type brandsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to create a brands.
     */
    data: XOR<brandsCreateInput, brandsUncheckedCreateInput>
  }

  /**
   * brands createMany
   */
  export type brandsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many brands.
     */
    data: brandsCreateManyInput | brandsCreateManyInput[]
  }

  /**
   * brands update
   */
  export type brandsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The data needed to update a brands.
     */
    data: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
    /**
     * Choose, which brands to update.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands updateMany
   */
  export type brandsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update brands.
     */
    data: XOR<brandsUpdateManyMutationInput, brandsUncheckedUpdateManyInput>
    /**
     * Filter which brands to update
     */
    where?: brandsWhereInput
    /**
     * Limit how many brands to update.
     */
    limit?: number
  }

  /**
   * brands upsert
   */
  export type brandsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * The filter to search for the brands to update in case it exists.
     */
    where: brandsWhereUniqueInput
    /**
     * In case the brands found by the `where` argument doesn't exist, create a new brands with this data.
     */
    create: XOR<brandsCreateInput, brandsUncheckedCreateInput>
    /**
     * In case the brands was found with the provided `where` argument, update it with this data.
     */
    update: XOR<brandsUpdateInput, brandsUncheckedUpdateInput>
  }

  /**
   * brands delete
   */
  export type brandsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    /**
     * Filter which brands to delete.
     */
    where: brandsWhereUniqueInput
  }

  /**
   * brands deleteMany
   */
  export type brandsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which brands to delete
     */
    where?: brandsWhereInput
    /**
     * Limit how many brands to delete.
     */
    limit?: number
  }

  /**
   * brands findRaw
   */
  export type brandsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brands aggregateRaw
   */
  export type brandsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * brands.models
   */
  export type brands$modelsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    where?: modelsWhereInput
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    cursor?: modelsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * brands.variants
   */
  export type brands$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    where?: variantsWhereInput
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    cursor?: variantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * brands.vehicle
   */
  export type brands$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    where?: vehicleWhereInput
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    cursor?: vehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * brands without action
   */
  export type brandsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
  }


  /**
   * Model models
   */

  export type AggregateModels = {
    _count: ModelsCountAggregateOutputType | null
    _min: ModelsMinAggregateOutputType | null
    _max: ModelsMaxAggregateOutputType | null
  }

  export type ModelsMinAggregateOutputType = {
    id: string | null
    name: string | null
    brand_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    brand_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ModelsCountAggregateOutputType = {
    id: number
    name: number
    brand_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ModelsMinAggregateInputType = {
    id?: true
    name?: true
    brand_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelsMaxAggregateInputType = {
    id?: true
    name?: true
    brand_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ModelsCountAggregateInputType = {
    id?: true
    name?: true
    brand_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ModelsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which models to aggregate.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned models
    **/
    _count?: true | ModelsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ModelsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ModelsMaxAggregateInputType
  }

  export type GetModelsAggregateType<T extends ModelsAggregateArgs> = {
        [P in keyof T & keyof AggregateModels]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateModels[P]>
      : GetScalarType<T[P], AggregateModels[P]>
  }




  export type modelsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: modelsWhereInput
    orderBy?: modelsOrderByWithAggregationInput | modelsOrderByWithAggregationInput[]
    by: ModelsScalarFieldEnum[] | ModelsScalarFieldEnum
    having?: modelsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ModelsCountAggregateInputType | true
    _min?: ModelsMinAggregateInputType
    _max?: ModelsMaxAggregateInputType
  }

  export type ModelsGroupByOutputType = {
    id: string
    name: string
    brand_id: string
    createdAt: Date
    updatedAt: Date
    _count: ModelsCountAggregateOutputType | null
    _min: ModelsMinAggregateOutputType | null
    _max: ModelsMaxAggregateOutputType | null
  }

  type GetModelsGroupByPayload<T extends modelsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ModelsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ModelsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ModelsGroupByOutputType[P]>
            : GetScalarType<T[P], ModelsGroupByOutputType[P]>
        }
      >
    >


  export type modelsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    brand_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    variants?: boolean | models$variantsArgs<ExtArgs>
    vehicle?: boolean | models$vehicleArgs<ExtArgs>
    _count?: boolean | ModelsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["models"]>



  export type modelsSelectScalar = {
    id?: boolean
    name?: boolean
    brand_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type modelsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "brand_id" | "createdAt" | "updatedAt", ExtArgs["result"]["models"]>
  export type modelsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    variants?: boolean | models$variantsArgs<ExtArgs>
    vehicle?: boolean | models$vehicleArgs<ExtArgs>
    _count?: boolean | ModelsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $modelsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "models"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs>
      variants: Prisma.$variantsPayload<ExtArgs>[]
      vehicle: Prisma.$vehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      brand_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["models"]>
    composites: {}
  }

  type modelsGetPayload<S extends boolean | null | undefined | modelsDefaultArgs> = $Result.GetResult<Prisma.$modelsPayload, S>

  type modelsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<modelsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ModelsCountAggregateInputType | true
    }

  export interface modelsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['models'], meta: { name: 'models' } }
    /**
     * Find zero or one Models that matches the filter.
     * @param {modelsFindUniqueArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends modelsFindUniqueArgs>(args: SelectSubset<T, modelsFindUniqueArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Models that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {modelsFindUniqueOrThrowArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends modelsFindUniqueOrThrowArgs>(args: SelectSubset<T, modelsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsFindFirstArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends modelsFindFirstArgs>(args?: SelectSubset<T, modelsFindFirstArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Models that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsFindFirstOrThrowArgs} args - Arguments to find a Models
     * @example
     * // Get one Models
     * const models = await prisma.models.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends modelsFindFirstOrThrowArgs>(args?: SelectSubset<T, modelsFindFirstOrThrowArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Models that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Models
     * const models = await prisma.models.findMany()
     * 
     * // Get first 10 Models
     * const models = await prisma.models.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const modelsWithIdOnly = await prisma.models.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends modelsFindManyArgs>(args?: SelectSubset<T, modelsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Models.
     * @param {modelsCreateArgs} args - Arguments to create a Models.
     * @example
     * // Create one Models
     * const Models = await prisma.models.create({
     *   data: {
     *     // ... data to create a Models
     *   }
     * })
     * 
     */
    create<T extends modelsCreateArgs>(args: SelectSubset<T, modelsCreateArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Models.
     * @param {modelsCreateManyArgs} args - Arguments to create many Models.
     * @example
     * // Create many Models
     * const models = await prisma.models.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends modelsCreateManyArgs>(args?: SelectSubset<T, modelsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Models.
     * @param {modelsDeleteArgs} args - Arguments to delete one Models.
     * @example
     * // Delete one Models
     * const Models = await prisma.models.delete({
     *   where: {
     *     // ... filter to delete one Models
     *   }
     * })
     * 
     */
    delete<T extends modelsDeleteArgs>(args: SelectSubset<T, modelsDeleteArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Models.
     * @param {modelsUpdateArgs} args - Arguments to update one Models.
     * @example
     * // Update one Models
     * const models = await prisma.models.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends modelsUpdateArgs>(args: SelectSubset<T, modelsUpdateArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Models.
     * @param {modelsDeleteManyArgs} args - Arguments to filter Models to delete.
     * @example
     * // Delete a few Models
     * const { count } = await prisma.models.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends modelsDeleteManyArgs>(args?: SelectSubset<T, modelsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Models
     * const models = await prisma.models.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends modelsUpdateManyArgs>(args: SelectSubset<T, modelsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Models.
     * @param {modelsUpsertArgs} args - Arguments to update or create a Models.
     * @example
     * // Update or create a Models
     * const models = await prisma.models.upsert({
     *   create: {
     *     // ... data to create a Models
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Models we want to update
     *   }
     * })
     */
    upsert<T extends modelsUpsertArgs>(args: SelectSubset<T, modelsUpsertArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Models that matches the filter.
     * @param {modelsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const models = await prisma.models.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: modelsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Models.
     * @param {modelsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const models = await prisma.models.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: modelsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsCountArgs} args - Arguments to filter Models to count.
     * @example
     * // Count the number of Models
     * const count = await prisma.models.count({
     *   where: {
     *     // ... the filter for the Models we want to count
     *   }
     * })
    **/
    count<T extends modelsCountArgs>(
      args?: Subset<T, modelsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ModelsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ModelsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ModelsAggregateArgs>(args: Subset<T, ModelsAggregateArgs>): Prisma.PrismaPromise<GetModelsAggregateType<T>>

    /**
     * Group by Models.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {modelsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends modelsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: modelsGroupByArgs['orderBy'] }
        : { orderBy?: modelsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, modelsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetModelsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the models model
   */
  readonly fields: modelsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for models.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__modelsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variants<T extends models$variantsArgs<ExtArgs> = {}>(args?: Subset<T, models$variantsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle<T extends models$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, models$vehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the models model
   */
  interface modelsFieldRefs {
    readonly id: FieldRef<"models", 'String'>
    readonly name: FieldRef<"models", 'String'>
    readonly brand_id: FieldRef<"models", 'String'>
    readonly createdAt: FieldRef<"models", 'DateTime'>
    readonly updatedAt: FieldRef<"models", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * models findUnique
   */
  export type modelsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models findUniqueOrThrow
   */
  export type modelsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models findFirst
   */
  export type modelsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for models.
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of models.
     */
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * models findFirstOrThrow
   */
  export type modelsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for models.
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of models.
     */
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * models findMany
   */
  export type modelsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter, which models to fetch.
     */
    where?: modelsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of models to fetch.
     */
    orderBy?: modelsOrderByWithRelationInput | modelsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing models.
     */
    cursor?: modelsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` models from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` models.
     */
    skip?: number
    distinct?: ModelsScalarFieldEnum | ModelsScalarFieldEnum[]
  }

  /**
   * models create
   */
  export type modelsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * The data needed to create a models.
     */
    data: XOR<modelsCreateInput, modelsUncheckedCreateInput>
  }

  /**
   * models createMany
   */
  export type modelsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many models.
     */
    data: modelsCreateManyInput | modelsCreateManyInput[]
  }

  /**
   * models update
   */
  export type modelsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * The data needed to update a models.
     */
    data: XOR<modelsUpdateInput, modelsUncheckedUpdateInput>
    /**
     * Choose, which models to update.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models updateMany
   */
  export type modelsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update models.
     */
    data: XOR<modelsUpdateManyMutationInput, modelsUncheckedUpdateManyInput>
    /**
     * Filter which models to update
     */
    where?: modelsWhereInput
    /**
     * Limit how many models to update.
     */
    limit?: number
  }

  /**
   * models upsert
   */
  export type modelsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * The filter to search for the models to update in case it exists.
     */
    where: modelsWhereUniqueInput
    /**
     * In case the models found by the `where` argument doesn't exist, create a new models with this data.
     */
    create: XOR<modelsCreateInput, modelsUncheckedCreateInput>
    /**
     * In case the models was found with the provided `where` argument, update it with this data.
     */
    update: XOR<modelsUpdateInput, modelsUncheckedUpdateInput>
  }

  /**
   * models delete
   */
  export type modelsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
    /**
     * Filter which models to delete.
     */
    where: modelsWhereUniqueInput
  }

  /**
   * models deleteMany
   */
  export type modelsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which models to delete
     */
    where?: modelsWhereInput
    /**
     * Limit how many models to delete.
     */
    limit?: number
  }

  /**
   * models findRaw
   */
  export type modelsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * models aggregateRaw
   */
  export type modelsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * models.variants
   */
  export type models$variantsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    where?: variantsWhereInput
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    cursor?: variantsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * models.vehicle
   */
  export type models$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    where?: vehicleWhereInput
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    cursor?: vehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * models without action
   */
  export type modelsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the models
     */
    select?: modelsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the models
     */
    omit?: modelsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: modelsInclude<ExtArgs> | null
  }


  /**
   * Model variants
   */

  export type AggregateVariants = {
    _count: VariantsCountAggregateOutputType | null
    _min: VariantsMinAggregateOutputType | null
    _max: VariantsMaxAggregateOutputType | null
  }

  export type VariantsMinAggregateOutputType = {
    id: string | null
    name: string | null
    model_id: string | null
    brand_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariantsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    model_id: string | null
    brand_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VariantsCountAggregateOutputType = {
    id: number
    name: number
    model_id: number
    brand_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VariantsMinAggregateInputType = {
    id?: true
    name?: true
    model_id?: true
    brand_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariantsMaxAggregateInputType = {
    id?: true
    name?: true
    model_id?: true
    brand_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VariantsCountAggregateInputType = {
    id?: true
    name?: true
    model_id?: true
    brand_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VariantsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which variants to aggregate.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned variants
    **/
    _count?: true | VariantsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VariantsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VariantsMaxAggregateInputType
  }

  export type GetVariantsAggregateType<T extends VariantsAggregateArgs> = {
        [P in keyof T & keyof AggregateVariants]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVariants[P]>
      : GetScalarType<T[P], AggregateVariants[P]>
  }




  export type variantsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: variantsWhereInput
    orderBy?: variantsOrderByWithAggregationInput | variantsOrderByWithAggregationInput[]
    by: VariantsScalarFieldEnum[] | VariantsScalarFieldEnum
    having?: variantsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VariantsCountAggregateInputType | true
    _min?: VariantsMinAggregateInputType
    _max?: VariantsMaxAggregateInputType
  }

  export type VariantsGroupByOutputType = {
    id: string
    name: string
    model_id: string
    brand_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: VariantsCountAggregateOutputType | null
    _min: VariantsMinAggregateOutputType | null
    _max: VariantsMaxAggregateOutputType | null
  }

  type GetVariantsGroupByPayload<T extends variantsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VariantsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VariantsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VariantsGroupByOutputType[P]>
            : GetScalarType<T[P], VariantsGroupByOutputType[P]>
        }
      >
    >


  export type variantsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    model_id?: boolean
    brand_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    model?: boolean | modelsDefaultArgs<ExtArgs>
    brand?: boolean | variants$brandArgs<ExtArgs>
    vehicle?: boolean | variants$vehicleArgs<ExtArgs>
    _count?: boolean | VariantsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["variants"]>



  export type variantsSelectScalar = {
    id?: boolean
    name?: boolean
    model_id?: boolean
    brand_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type variantsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "model_id" | "brand_id" | "createdAt" | "updatedAt", ExtArgs["result"]["variants"]>
  export type variantsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    model?: boolean | modelsDefaultArgs<ExtArgs>
    brand?: boolean | variants$brandArgs<ExtArgs>
    vehicle?: boolean | variants$vehicleArgs<ExtArgs>
    _count?: boolean | VariantsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $variantsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "variants"
    objects: {
      model: Prisma.$modelsPayload<ExtArgs>
      brand: Prisma.$brandsPayload<ExtArgs> | null
      vehicle: Prisma.$vehiclePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      model_id: string
      brand_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["variants"]>
    composites: {}
  }

  type variantsGetPayload<S extends boolean | null | undefined | variantsDefaultArgs> = $Result.GetResult<Prisma.$variantsPayload, S>

  type variantsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<variantsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VariantsCountAggregateInputType | true
    }

  export interface variantsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['variants'], meta: { name: 'variants' } }
    /**
     * Find zero or one Variants that matches the filter.
     * @param {variantsFindUniqueArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends variantsFindUniqueArgs>(args: SelectSubset<T, variantsFindUniqueArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Variants that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {variantsFindUniqueOrThrowArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends variantsFindUniqueOrThrowArgs>(args: SelectSubset<T, variantsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsFindFirstArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends variantsFindFirstArgs>(args?: SelectSubset<T, variantsFindFirstArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Variants that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsFindFirstOrThrowArgs} args - Arguments to find a Variants
     * @example
     * // Get one Variants
     * const variants = await prisma.variants.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends variantsFindFirstOrThrowArgs>(args?: SelectSubset<T, variantsFindFirstOrThrowArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variants that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Variants
     * const variants = await prisma.variants.findMany()
     * 
     * // Get first 10 Variants
     * const variants = await prisma.variants.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const variantsWithIdOnly = await prisma.variants.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends variantsFindManyArgs>(args?: SelectSubset<T, variantsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Variants.
     * @param {variantsCreateArgs} args - Arguments to create a Variants.
     * @example
     * // Create one Variants
     * const Variants = await prisma.variants.create({
     *   data: {
     *     // ... data to create a Variants
     *   }
     * })
     * 
     */
    create<T extends variantsCreateArgs>(args: SelectSubset<T, variantsCreateArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Variants.
     * @param {variantsCreateManyArgs} args - Arguments to create many Variants.
     * @example
     * // Create many Variants
     * const variants = await prisma.variants.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends variantsCreateManyArgs>(args?: SelectSubset<T, variantsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Variants.
     * @param {variantsDeleteArgs} args - Arguments to delete one Variants.
     * @example
     * // Delete one Variants
     * const Variants = await prisma.variants.delete({
     *   where: {
     *     // ... filter to delete one Variants
     *   }
     * })
     * 
     */
    delete<T extends variantsDeleteArgs>(args: SelectSubset<T, variantsDeleteArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Variants.
     * @param {variantsUpdateArgs} args - Arguments to update one Variants.
     * @example
     * // Update one Variants
     * const variants = await prisma.variants.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends variantsUpdateArgs>(args: SelectSubset<T, variantsUpdateArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Variants.
     * @param {variantsDeleteManyArgs} args - Arguments to filter Variants to delete.
     * @example
     * // Delete a few Variants
     * const { count } = await prisma.variants.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends variantsDeleteManyArgs>(args?: SelectSubset<T, variantsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Variants
     * const variants = await prisma.variants.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends variantsUpdateManyArgs>(args: SelectSubset<T, variantsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Variants.
     * @param {variantsUpsertArgs} args - Arguments to update or create a Variants.
     * @example
     * // Update or create a Variants
     * const variants = await prisma.variants.upsert({
     *   create: {
     *     // ... data to create a Variants
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Variants we want to update
     *   }
     * })
     */
    upsert<T extends variantsUpsertArgs>(args: SelectSubset<T, variantsUpsertArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Variants that matches the filter.
     * @param {variantsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const variants = await prisma.variants.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: variantsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Variants.
     * @param {variantsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const variants = await prisma.variants.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: variantsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsCountArgs} args - Arguments to filter Variants to count.
     * @example
     * // Count the number of Variants
     * const count = await prisma.variants.count({
     *   where: {
     *     // ... the filter for the Variants we want to count
     *   }
     * })
    **/
    count<T extends variantsCountArgs>(
      args?: Subset<T, variantsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VariantsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VariantsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VariantsAggregateArgs>(args: Subset<T, VariantsAggregateArgs>): Prisma.PrismaPromise<GetVariantsAggregateType<T>>

    /**
     * Group by Variants.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {variantsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends variantsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: variantsGroupByArgs['orderBy'] }
        : { orderBy?: variantsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, variantsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVariantsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the variants model
   */
  readonly fields: variantsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for variants.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__variantsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    model<T extends modelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, modelsDefaultArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    brand<T extends variants$brandArgs<ExtArgs> = {}>(args?: Subset<T, variants$brandArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle<T extends variants$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, variants$vehicleArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the variants model
   */
  interface variantsFieldRefs {
    readonly id: FieldRef<"variants", 'String'>
    readonly name: FieldRef<"variants", 'String'>
    readonly model_id: FieldRef<"variants", 'String'>
    readonly brand_id: FieldRef<"variants", 'String'>
    readonly createdAt: FieldRef<"variants", 'DateTime'>
    readonly updatedAt: FieldRef<"variants", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * variants findUnique
   */
  export type variantsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants findUniqueOrThrow
   */
  export type variantsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants findFirst
   */
  export type variantsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for variants.
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of variants.
     */
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * variants findFirstOrThrow
   */
  export type variantsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for variants.
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of variants.
     */
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * variants findMany
   */
  export type variantsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter, which variants to fetch.
     */
    where?: variantsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of variants to fetch.
     */
    orderBy?: variantsOrderByWithRelationInput | variantsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing variants.
     */
    cursor?: variantsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` variants from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` variants.
     */
    skip?: number
    distinct?: VariantsScalarFieldEnum | VariantsScalarFieldEnum[]
  }

  /**
   * variants create
   */
  export type variantsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * The data needed to create a variants.
     */
    data: XOR<variantsCreateInput, variantsUncheckedCreateInput>
  }

  /**
   * variants createMany
   */
  export type variantsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many variants.
     */
    data: variantsCreateManyInput | variantsCreateManyInput[]
  }

  /**
   * variants update
   */
  export type variantsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * The data needed to update a variants.
     */
    data: XOR<variantsUpdateInput, variantsUncheckedUpdateInput>
    /**
     * Choose, which variants to update.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants updateMany
   */
  export type variantsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update variants.
     */
    data: XOR<variantsUpdateManyMutationInput, variantsUncheckedUpdateManyInput>
    /**
     * Filter which variants to update
     */
    where?: variantsWhereInput
    /**
     * Limit how many variants to update.
     */
    limit?: number
  }

  /**
   * variants upsert
   */
  export type variantsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * The filter to search for the variants to update in case it exists.
     */
    where: variantsWhereUniqueInput
    /**
     * In case the variants found by the `where` argument doesn't exist, create a new variants with this data.
     */
    create: XOR<variantsCreateInput, variantsUncheckedCreateInput>
    /**
     * In case the variants was found with the provided `where` argument, update it with this data.
     */
    update: XOR<variantsUpdateInput, variantsUncheckedUpdateInput>
  }

  /**
   * variants delete
   */
  export type variantsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
    /**
     * Filter which variants to delete.
     */
    where: variantsWhereUniqueInput
  }

  /**
   * variants deleteMany
   */
  export type variantsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which variants to delete
     */
    where?: variantsWhereInput
    /**
     * Limit how many variants to delete.
     */
    limit?: number
  }

  /**
   * variants findRaw
   */
  export type variantsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * variants aggregateRaw
   */
  export type variantsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * variants.brand
   */
  export type variants$brandArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the brands
     */
    select?: brandsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the brands
     */
    omit?: brandsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: brandsInclude<ExtArgs> | null
    where?: brandsWhereInput
  }

  /**
   * variants.vehicle
   */
  export type variants$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    where?: vehicleWhereInput
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    cursor?: vehicleWhereUniqueInput
    take?: number
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * variants without action
   */
  export type variantsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the variants
     */
    select?: variantsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the variants
     */
    omit?: variantsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: variantsInclude<ExtArgs> | null
  }


  /**
   * Model states
   */

  export type AggregateStates = {
    _count: StatesCountAggregateOutputType | null
    _min: StatesMinAggregateOutputType | null
    _max: StatesMaxAggregateOutputType | null
  }

  export type StatesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type StatesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type StatesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type StatesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type StatesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which states to aggregate.
     */
    where?: statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: statesOrderByWithRelationInput | statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned states
    **/
    _count?: true | StatesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: StatesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: StatesMaxAggregateInputType
  }

  export type GetStatesAggregateType<T extends StatesAggregateArgs> = {
        [P in keyof T & keyof AggregateStates]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateStates[P]>
      : GetScalarType<T[P], AggregateStates[P]>
  }




  export type statesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: statesWhereInput
    orderBy?: statesOrderByWithAggregationInput | statesOrderByWithAggregationInput[]
    by: StatesScalarFieldEnum[] | StatesScalarFieldEnum
    having?: statesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: StatesCountAggregateInputType | true
    _min?: StatesMinAggregateInputType
    _max?: StatesMaxAggregateInputType
  }

  export type StatesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: StatesCountAggregateOutputType | null
    _min: StatesMinAggregateOutputType | null
    _max: StatesMaxAggregateOutputType | null
  }

  type GetStatesGroupByPayload<T extends statesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<StatesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof StatesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], StatesGroupByOutputType[P]>
            : GetScalarType<T[P], StatesGroupByOutputType[P]>
        }
      >
    >


  export type statesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    cities?: boolean | states$citiesArgs<ExtArgs>
    customers?: boolean | states$customersArgs<ExtArgs>
    providers?: boolean | states$providersArgs<ExtArgs>
    _count?: boolean | StatesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["states"]>



  export type statesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type statesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["states"]>
  export type statesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    cities?: boolean | states$citiesArgs<ExtArgs>
    customers?: boolean | states$customersArgs<ExtArgs>
    providers?: boolean | states$providersArgs<ExtArgs>
    _count?: boolean | StatesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $statesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "states"
    objects: {
      cities: Prisma.$citiesPayload<ExtArgs>[]
      customers: Prisma.$customerPayload<ExtArgs>[]
      providers: Prisma.$providersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["states"]>
    composites: {}
  }

  type statesGetPayload<S extends boolean | null | undefined | statesDefaultArgs> = $Result.GetResult<Prisma.$statesPayload, S>

  type statesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<statesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: StatesCountAggregateInputType | true
    }

  export interface statesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['states'], meta: { name: 'states' } }
    /**
     * Find zero or one States that matches the filter.
     * @param {statesFindUniqueArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends statesFindUniqueArgs>(args: SelectSubset<T, statesFindUniqueArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one States that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {statesFindUniqueOrThrowArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends statesFindUniqueOrThrowArgs>(args: SelectSubset<T, statesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statesFindFirstArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends statesFindFirstArgs>(args?: SelectSubset<T, statesFindFirstArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first States that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statesFindFirstOrThrowArgs} args - Arguments to find a States
     * @example
     * // Get one States
     * const states = await prisma.states.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends statesFindFirstOrThrowArgs>(args?: SelectSubset<T, statesFindFirstOrThrowArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more States that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all States
     * const states = await prisma.states.findMany()
     * 
     * // Get first 10 States
     * const states = await prisma.states.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const statesWithIdOnly = await prisma.states.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends statesFindManyArgs>(args?: SelectSubset<T, statesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a States.
     * @param {statesCreateArgs} args - Arguments to create a States.
     * @example
     * // Create one States
     * const States = await prisma.states.create({
     *   data: {
     *     // ... data to create a States
     *   }
     * })
     * 
     */
    create<T extends statesCreateArgs>(args: SelectSubset<T, statesCreateArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many States.
     * @param {statesCreateManyArgs} args - Arguments to create many States.
     * @example
     * // Create many States
     * const states = await prisma.states.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends statesCreateManyArgs>(args?: SelectSubset<T, statesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a States.
     * @param {statesDeleteArgs} args - Arguments to delete one States.
     * @example
     * // Delete one States
     * const States = await prisma.states.delete({
     *   where: {
     *     // ... filter to delete one States
     *   }
     * })
     * 
     */
    delete<T extends statesDeleteArgs>(args: SelectSubset<T, statesDeleteArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one States.
     * @param {statesUpdateArgs} args - Arguments to update one States.
     * @example
     * // Update one States
     * const states = await prisma.states.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends statesUpdateArgs>(args: SelectSubset<T, statesUpdateArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more States.
     * @param {statesDeleteManyArgs} args - Arguments to filter States to delete.
     * @example
     * // Delete a few States
     * const { count } = await prisma.states.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends statesDeleteManyArgs>(args?: SelectSubset<T, statesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many States
     * const states = await prisma.states.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends statesUpdateManyArgs>(args: SelectSubset<T, statesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one States.
     * @param {statesUpsertArgs} args - Arguments to update or create a States.
     * @example
     * // Update or create a States
     * const states = await prisma.states.upsert({
     *   create: {
     *     // ... data to create a States
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the States we want to update
     *   }
     * })
     */
    upsert<T extends statesUpsertArgs>(args: SelectSubset<T, statesUpsertArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more States that matches the filter.
     * @param {statesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const states = await prisma.states.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: statesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a States.
     * @param {statesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const states = await prisma.states.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: statesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statesCountArgs} args - Arguments to filter States to count.
     * @example
     * // Count the number of States
     * const count = await prisma.states.count({
     *   where: {
     *     // ... the filter for the States we want to count
     *   }
     * })
    **/
    count<T extends statesCountArgs>(
      args?: Subset<T, statesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], StatesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {StatesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends StatesAggregateArgs>(args: Subset<T, StatesAggregateArgs>): Prisma.PrismaPromise<GetStatesAggregateType<T>>

    /**
     * Group by States.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {statesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends statesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: statesGroupByArgs['orderBy'] }
        : { orderBy?: statesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, statesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetStatesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the states model
   */
  readonly fields: statesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for states.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__statesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    cities<T extends states$citiesArgs<ExtArgs> = {}>(args?: Subset<T, states$citiesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    customers<T extends states$customersArgs<ExtArgs> = {}>(args?: Subset<T, states$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providers<T extends states$providersArgs<ExtArgs> = {}>(args?: Subset<T, states$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the states model
   */
  interface statesFieldRefs {
    readonly id: FieldRef<"states", 'String'>
    readonly name: FieldRef<"states", 'String'>
    readonly createdAt: FieldRef<"states", 'DateTime'>
    readonly updatedAt: FieldRef<"states", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * states findUnique
   */
  export type statesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where: statesWhereUniqueInput
  }

  /**
   * states findUniqueOrThrow
   */
  export type statesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where: statesWhereUniqueInput
  }

  /**
   * states findFirst
   */
  export type statesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where?: statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: statesOrderByWithRelationInput | statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for states.
     */
    cursor?: statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of states.
     */
    distinct?: StatesScalarFieldEnum | StatesScalarFieldEnum[]
  }

  /**
   * states findFirstOrThrow
   */
  export type statesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where?: statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: statesOrderByWithRelationInput | statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for states.
     */
    cursor?: statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of states.
     */
    distinct?: StatesScalarFieldEnum | StatesScalarFieldEnum[]
  }

  /**
   * states findMany
   */
  export type statesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * Filter, which states to fetch.
     */
    where?: statesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of states to fetch.
     */
    orderBy?: statesOrderByWithRelationInput | statesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing states.
     */
    cursor?: statesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` states from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` states.
     */
    skip?: number
    distinct?: StatesScalarFieldEnum | StatesScalarFieldEnum[]
  }

  /**
   * states create
   */
  export type statesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * The data needed to create a states.
     */
    data: XOR<statesCreateInput, statesUncheckedCreateInput>
  }

  /**
   * states createMany
   */
  export type statesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many states.
     */
    data: statesCreateManyInput | statesCreateManyInput[]
  }

  /**
   * states update
   */
  export type statesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * The data needed to update a states.
     */
    data: XOR<statesUpdateInput, statesUncheckedUpdateInput>
    /**
     * Choose, which states to update.
     */
    where: statesWhereUniqueInput
  }

  /**
   * states updateMany
   */
  export type statesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update states.
     */
    data: XOR<statesUpdateManyMutationInput, statesUncheckedUpdateManyInput>
    /**
     * Filter which states to update
     */
    where?: statesWhereInput
    /**
     * Limit how many states to update.
     */
    limit?: number
  }

  /**
   * states upsert
   */
  export type statesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * The filter to search for the states to update in case it exists.
     */
    where: statesWhereUniqueInput
    /**
     * In case the states found by the `where` argument doesn't exist, create a new states with this data.
     */
    create: XOR<statesCreateInput, statesUncheckedCreateInput>
    /**
     * In case the states was found with the provided `where` argument, update it with this data.
     */
    update: XOR<statesUpdateInput, statesUncheckedUpdateInput>
  }

  /**
   * states delete
   */
  export type statesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
    /**
     * Filter which states to delete.
     */
    where: statesWhereUniqueInput
  }

  /**
   * states deleteMany
   */
  export type statesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which states to delete
     */
    where?: statesWhereInput
    /**
     * Limit how many states to delete.
     */
    limit?: number
  }

  /**
   * states findRaw
   */
  export type statesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * states aggregateRaw
   */
  export type statesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * states.cities
   */
  export type states$citiesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    where?: citiesWhereInput
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    cursor?: citiesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * states.customers
   */
  export type states$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * states.providers
   */
  export type states$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    cursor?: providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * states without action
   */
  export type statesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the states
     */
    select?: statesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the states
     */
    omit?: statesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: statesInclude<ExtArgs> | null
  }


  /**
   * Model cities
   */

  export type AggregateCities = {
    _count: CitiesCountAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  export type CitiesMinAggregateOutputType = {
    id: string | null
    name: string | null
    stateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CitiesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    stateId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CitiesCountAggregateOutputType = {
    id: number
    name: number
    stateId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CitiesMinAggregateInputType = {
    id?: true
    name?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CitiesMaxAggregateInputType = {
    id?: true
    name?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CitiesCountAggregateInputType = {
    id?: true
    name?: true
    stateId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CitiesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to aggregate.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned cities
    **/
    _count?: true | CitiesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CitiesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CitiesMaxAggregateInputType
  }

  export type GetCitiesAggregateType<T extends CitiesAggregateArgs> = {
        [P in keyof T & keyof AggregateCities]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCities[P]>
      : GetScalarType<T[P], AggregateCities[P]>
  }




  export type citiesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: citiesWhereInput
    orderBy?: citiesOrderByWithAggregationInput | citiesOrderByWithAggregationInput[]
    by: CitiesScalarFieldEnum[] | CitiesScalarFieldEnum
    having?: citiesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CitiesCountAggregateInputType | true
    _min?: CitiesMinAggregateInputType
    _max?: CitiesMaxAggregateInputType
  }

  export type CitiesGroupByOutputType = {
    id: string
    name: string
    stateId: string
    createdAt: Date
    updatedAt: Date
    _count: CitiesCountAggregateOutputType | null
    _min: CitiesMinAggregateOutputType | null
    _max: CitiesMaxAggregateOutputType | null
  }

  type GetCitiesGroupByPayload<T extends citiesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CitiesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CitiesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CitiesGroupByOutputType[P]>
            : GetScalarType<T[P], CitiesGroupByOutputType[P]>
        }
      >
    >


  export type citiesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    stateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    state?: boolean | statesDefaultArgs<ExtArgs>
    customers?: boolean | cities$customersArgs<ExtArgs>
    providers?: boolean | cities$providersArgs<ExtArgs>
    _count?: boolean | CitiesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["cities"]>



  export type citiesSelectScalar = {
    id?: boolean
    name?: boolean
    stateId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type citiesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "stateId" | "createdAt" | "updatedAt", ExtArgs["result"]["cities"]>
  export type citiesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    state?: boolean | statesDefaultArgs<ExtArgs>
    customers?: boolean | cities$customersArgs<ExtArgs>
    providers?: boolean | cities$providersArgs<ExtArgs>
    _count?: boolean | CitiesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $citiesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "cities"
    objects: {
      state: Prisma.$statesPayload<ExtArgs>
      customers: Prisma.$customerPayload<ExtArgs>[]
      providers: Prisma.$providersPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      stateId: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["cities"]>
    composites: {}
  }

  type citiesGetPayload<S extends boolean | null | undefined | citiesDefaultArgs> = $Result.GetResult<Prisma.$citiesPayload, S>

  type citiesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<citiesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CitiesCountAggregateInputType | true
    }

  export interface citiesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['cities'], meta: { name: 'cities' } }
    /**
     * Find zero or one Cities that matches the filter.
     * @param {citiesFindUniqueArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends citiesFindUniqueArgs>(args: SelectSubset<T, citiesFindUniqueArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Cities that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {citiesFindUniqueOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends citiesFindUniqueOrThrowArgs>(args: SelectSubset<T, citiesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends citiesFindFirstArgs>(args?: SelectSubset<T, citiesFindFirstArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Cities that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindFirstOrThrowArgs} args - Arguments to find a Cities
     * @example
     * // Get one Cities
     * const cities = await prisma.cities.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends citiesFindFirstOrThrowArgs>(args?: SelectSubset<T, citiesFindFirstOrThrowArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Cities
     * const cities = await prisma.cities.findMany()
     * 
     * // Get first 10 Cities
     * const cities = await prisma.cities.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const citiesWithIdOnly = await prisma.cities.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends citiesFindManyArgs>(args?: SelectSubset<T, citiesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Cities.
     * @param {citiesCreateArgs} args - Arguments to create a Cities.
     * @example
     * // Create one Cities
     * const Cities = await prisma.cities.create({
     *   data: {
     *     // ... data to create a Cities
     *   }
     * })
     * 
     */
    create<T extends citiesCreateArgs>(args: SelectSubset<T, citiesCreateArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Cities.
     * @param {citiesCreateManyArgs} args - Arguments to create many Cities.
     * @example
     * // Create many Cities
     * const cities = await prisma.cities.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends citiesCreateManyArgs>(args?: SelectSubset<T, citiesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Cities.
     * @param {citiesDeleteArgs} args - Arguments to delete one Cities.
     * @example
     * // Delete one Cities
     * const Cities = await prisma.cities.delete({
     *   where: {
     *     // ... filter to delete one Cities
     *   }
     * })
     * 
     */
    delete<T extends citiesDeleteArgs>(args: SelectSubset<T, citiesDeleteArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Cities.
     * @param {citiesUpdateArgs} args - Arguments to update one Cities.
     * @example
     * // Update one Cities
     * const cities = await prisma.cities.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends citiesUpdateArgs>(args: SelectSubset<T, citiesUpdateArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Cities.
     * @param {citiesDeleteManyArgs} args - Arguments to filter Cities to delete.
     * @example
     * // Delete a few Cities
     * const { count } = await prisma.cities.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends citiesDeleteManyArgs>(args?: SelectSubset<T, citiesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Cities
     * const cities = await prisma.cities.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends citiesUpdateManyArgs>(args: SelectSubset<T, citiesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Cities.
     * @param {citiesUpsertArgs} args - Arguments to update or create a Cities.
     * @example
     * // Update or create a Cities
     * const cities = await prisma.cities.upsert({
     *   create: {
     *     // ... data to create a Cities
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Cities we want to update
     *   }
     * })
     */
    upsert<T extends citiesUpsertArgs>(args: SelectSubset<T, citiesUpsertArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Cities that matches the filter.
     * @param {citiesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const cities = await prisma.cities.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: citiesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Cities.
     * @param {citiesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const cities = await prisma.cities.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: citiesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesCountArgs} args - Arguments to filter Cities to count.
     * @example
     * // Count the number of Cities
     * const count = await prisma.cities.count({
     *   where: {
     *     // ... the filter for the Cities we want to count
     *   }
     * })
    **/
    count<T extends citiesCountArgs>(
      args?: Subset<T, citiesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CitiesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CitiesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CitiesAggregateArgs>(args: Subset<T, CitiesAggregateArgs>): Prisma.PrismaPromise<GetCitiesAggregateType<T>>

    /**
     * Group by Cities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {citiesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends citiesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: citiesGroupByArgs['orderBy'] }
        : { orderBy?: citiesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, citiesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCitiesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the cities model
   */
  readonly fields: citiesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for cities.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__citiesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    state<T extends statesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statesDefaultArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customers<T extends cities$customersArgs<ExtArgs> = {}>(args?: Subset<T, cities$customersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    providers<T extends cities$providersArgs<ExtArgs> = {}>(args?: Subset<T, cities$providersArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the cities model
   */
  interface citiesFieldRefs {
    readonly id: FieldRef<"cities", 'String'>
    readonly name: FieldRef<"cities", 'String'>
    readonly stateId: FieldRef<"cities", 'String'>
    readonly createdAt: FieldRef<"cities", 'DateTime'>
    readonly updatedAt: FieldRef<"cities", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * cities findUnique
   */
  export type citiesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities findUniqueOrThrow
   */
  export type citiesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities findFirst
   */
  export type citiesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities findFirstOrThrow
   */
  export type citiesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of cities.
     */
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities findMany
   */
  export type citiesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter, which cities to fetch.
     */
    where?: citiesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of cities to fetch.
     */
    orderBy?: citiesOrderByWithRelationInput | citiesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing cities.
     */
    cursor?: citiesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` cities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` cities.
     */
    skip?: number
    distinct?: CitiesScalarFieldEnum | CitiesScalarFieldEnum[]
  }

  /**
   * cities create
   */
  export type citiesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The data needed to create a cities.
     */
    data: XOR<citiesCreateInput, citiesUncheckedCreateInput>
  }

  /**
   * cities createMany
   */
  export type citiesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many cities.
     */
    data: citiesCreateManyInput | citiesCreateManyInput[]
  }

  /**
   * cities update
   */
  export type citiesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The data needed to update a cities.
     */
    data: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
    /**
     * Choose, which cities to update.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities updateMany
   */
  export type citiesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update cities.
     */
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyInput>
    /**
     * Filter which cities to update
     */
    where?: citiesWhereInput
    /**
     * Limit how many cities to update.
     */
    limit?: number
  }

  /**
   * cities upsert
   */
  export type citiesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * The filter to search for the cities to update in case it exists.
     */
    where: citiesWhereUniqueInput
    /**
     * In case the cities found by the `where` argument doesn't exist, create a new cities with this data.
     */
    create: XOR<citiesCreateInput, citiesUncheckedCreateInput>
    /**
     * In case the cities was found with the provided `where` argument, update it with this data.
     */
    update: XOR<citiesUpdateInput, citiesUncheckedUpdateInput>
  }

  /**
   * cities delete
   */
  export type citiesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
    /**
     * Filter which cities to delete.
     */
    where: citiesWhereUniqueInput
  }

  /**
   * cities deleteMany
   */
  export type citiesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which cities to delete
     */
    where?: citiesWhereInput
    /**
     * Limit how many cities to delete.
     */
    limit?: number
  }

  /**
   * cities findRaw
   */
  export type citiesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * cities aggregateRaw
   */
  export type citiesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * cities.customers
   */
  export type cities$customersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    cursor?: customerWhereUniqueInput
    take?: number
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * cities.providers
   */
  export type cities$providersArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    where?: providersWhereInput
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    cursor?: providersWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * cities without action
   */
  export type citiesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the cities
     */
    select?: citiesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the cities
     */
    omit?: citiesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: citiesInclude<ExtArgs> | null
  }


  /**
   * Model checklist_categories
   */

  export type AggregateChecklist_categories = {
    _count: Checklist_categoriesCountAggregateOutputType | null
    _min: Checklist_categoriesMinAggregateOutputType | null
    _max: Checklist_categoriesMaxAggregateOutputType | null
  }

  export type Checklist_categoriesMinAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Checklist_categoriesMaxAggregateOutputType = {
    id: string | null
    name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Checklist_categoriesCountAggregateOutputType = {
    id: number
    name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Checklist_categoriesMinAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Checklist_categoriesMaxAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Checklist_categoriesCountAggregateInputType = {
    id?: true
    name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Checklist_categoriesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checklist_categories to aggregate.
     */
    where?: checklist_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_categories to fetch.
     */
    orderBy?: checklist_categoriesOrderByWithRelationInput | checklist_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: checklist_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checklist_categories
    **/
    _count?: true | Checklist_categoriesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Checklist_categoriesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Checklist_categoriesMaxAggregateInputType
  }

  export type GetChecklist_categoriesAggregateType<T extends Checklist_categoriesAggregateArgs> = {
        [P in keyof T & keyof AggregateChecklist_categories]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecklist_categories[P]>
      : GetScalarType<T[P], AggregateChecklist_categories[P]>
  }




  export type checklist_categoriesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checklist_categoriesWhereInput
    orderBy?: checklist_categoriesOrderByWithAggregationInput | checklist_categoriesOrderByWithAggregationInput[]
    by: Checklist_categoriesScalarFieldEnum[] | Checklist_categoriesScalarFieldEnum
    having?: checklist_categoriesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Checklist_categoriesCountAggregateInputType | true
    _min?: Checklist_categoriesMinAggregateInputType
    _max?: Checklist_categoriesMaxAggregateInputType
  }

  export type Checklist_categoriesGroupByOutputType = {
    id: string
    name: string
    createdAt: Date
    updatedAt: Date
    _count: Checklist_categoriesCountAggregateOutputType | null
    _min: Checklist_categoriesMinAggregateOutputType | null
    _max: Checklist_categoriesMaxAggregateOutputType | null
  }

  type GetChecklist_categoriesGroupByPayload<T extends checklist_categoriesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Checklist_categoriesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Checklist_categoriesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Checklist_categoriesGroupByOutputType[P]>
            : GetScalarType<T[P], Checklist_categoriesGroupByOutputType[P]>
        }
      >
    >


  export type checklist_categoriesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    options?: boolean | checklist_categories$optionsArgs<ExtArgs>
    _count?: boolean | Checklist_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklist_categories"]>



  export type checklist_categoriesSelectScalar = {
    id?: boolean
    name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type checklist_categoriesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "createdAt" | "updatedAt", ExtArgs["result"]["checklist_categories"]>
  export type checklist_categoriesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    options?: boolean | checklist_categories$optionsArgs<ExtArgs>
    _count?: boolean | Checklist_categoriesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $checklist_categoriesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "checklist_categories"
    objects: {
      options: Prisma.$checklist_optionsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["checklist_categories"]>
    composites: {}
  }

  type checklist_categoriesGetPayload<S extends boolean | null | undefined | checklist_categoriesDefaultArgs> = $Result.GetResult<Prisma.$checklist_categoriesPayload, S>

  type checklist_categoriesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<checklist_categoriesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Checklist_categoriesCountAggregateInputType | true
    }

  export interface checklist_categoriesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['checklist_categories'], meta: { name: 'checklist_categories' } }
    /**
     * Find zero or one Checklist_categories that matches the filter.
     * @param {checklist_categoriesFindUniqueArgs} args - Arguments to find a Checklist_categories
     * @example
     * // Get one Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends checklist_categoriesFindUniqueArgs>(args: SelectSubset<T, checklist_categoriesFindUniqueArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Checklist_categories that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {checklist_categoriesFindUniqueOrThrowArgs} args - Arguments to find a Checklist_categories
     * @example
     * // Get one Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends checklist_categoriesFindUniqueOrThrowArgs>(args: SelectSubset<T, checklist_categoriesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checklist_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_categoriesFindFirstArgs} args - Arguments to find a Checklist_categories
     * @example
     * // Get one Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends checklist_categoriesFindFirstArgs>(args?: SelectSubset<T, checklist_categoriesFindFirstArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checklist_categories that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_categoriesFindFirstOrThrowArgs} args - Arguments to find a Checklist_categories
     * @example
     * // Get one Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends checklist_categoriesFindFirstOrThrowArgs>(args?: SelectSubset<T, checklist_categoriesFindFirstOrThrowArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checklist_categories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_categoriesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.findMany()
     * 
     * // Get first 10 Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checklist_categoriesWithIdOnly = await prisma.checklist_categories.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends checklist_categoriesFindManyArgs>(args?: SelectSubset<T, checklist_categoriesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Checklist_categories.
     * @param {checklist_categoriesCreateArgs} args - Arguments to create a Checklist_categories.
     * @example
     * // Create one Checklist_categories
     * const Checklist_categories = await prisma.checklist_categories.create({
     *   data: {
     *     // ... data to create a Checklist_categories
     *   }
     * })
     * 
     */
    create<T extends checklist_categoriesCreateArgs>(args: SelectSubset<T, checklist_categoriesCreateArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Checklist_categories.
     * @param {checklist_categoriesCreateManyArgs} args - Arguments to create many Checklist_categories.
     * @example
     * // Create many Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends checklist_categoriesCreateManyArgs>(args?: SelectSubset<T, checklist_categoriesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Checklist_categories.
     * @param {checklist_categoriesDeleteArgs} args - Arguments to delete one Checklist_categories.
     * @example
     * // Delete one Checklist_categories
     * const Checklist_categories = await prisma.checklist_categories.delete({
     *   where: {
     *     // ... filter to delete one Checklist_categories
     *   }
     * })
     * 
     */
    delete<T extends checklist_categoriesDeleteArgs>(args: SelectSubset<T, checklist_categoriesDeleteArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Checklist_categories.
     * @param {checklist_categoriesUpdateArgs} args - Arguments to update one Checklist_categories.
     * @example
     * // Update one Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends checklist_categoriesUpdateArgs>(args: SelectSubset<T, checklist_categoriesUpdateArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Checklist_categories.
     * @param {checklist_categoriesDeleteManyArgs} args - Arguments to filter Checklist_categories to delete.
     * @example
     * // Delete a few Checklist_categories
     * const { count } = await prisma.checklist_categories.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends checklist_categoriesDeleteManyArgs>(args?: SelectSubset<T, checklist_categoriesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checklist_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_categoriesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends checklist_categoriesUpdateManyArgs>(args: SelectSubset<T, checklist_categoriesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Checklist_categories.
     * @param {checklist_categoriesUpsertArgs} args - Arguments to update or create a Checklist_categories.
     * @example
     * // Update or create a Checklist_categories
     * const checklist_categories = await prisma.checklist_categories.upsert({
     *   create: {
     *     // ... data to create a Checklist_categories
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checklist_categories we want to update
     *   }
     * })
     */
    upsert<T extends checklist_categoriesUpsertArgs>(args: SelectSubset<T, checklist_categoriesUpsertArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checklist_categories that matches the filter.
     * @param {checklist_categoriesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const checklist_categories = await prisma.checklist_categories.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: checklist_categoriesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Checklist_categories.
     * @param {checklist_categoriesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const checklist_categories = await prisma.checklist_categories.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: checklist_categoriesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Checklist_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_categoriesCountArgs} args - Arguments to filter Checklist_categories to count.
     * @example
     * // Count the number of Checklist_categories
     * const count = await prisma.checklist_categories.count({
     *   where: {
     *     // ... the filter for the Checklist_categories we want to count
     *   }
     * })
    **/
    count<T extends checklist_categoriesCountArgs>(
      args?: Subset<T, checklist_categoriesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Checklist_categoriesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checklist_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Checklist_categoriesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Checklist_categoriesAggregateArgs>(args: Subset<T, Checklist_categoriesAggregateArgs>): Prisma.PrismaPromise<GetChecklist_categoriesAggregateType<T>>

    /**
     * Group by Checklist_categories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_categoriesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends checklist_categoriesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: checklist_categoriesGroupByArgs['orderBy'] }
        : { orderBy?: checklist_categoriesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, checklist_categoriesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecklist_categoriesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the checklist_categories model
   */
  readonly fields: checklist_categoriesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for checklist_categories.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__checklist_categoriesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    options<T extends checklist_categories$optionsArgs<ExtArgs> = {}>(args?: Subset<T, checklist_categories$optionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the checklist_categories model
   */
  interface checklist_categoriesFieldRefs {
    readonly id: FieldRef<"checklist_categories", 'String'>
    readonly name: FieldRef<"checklist_categories", 'String'>
    readonly createdAt: FieldRef<"checklist_categories", 'DateTime'>
    readonly updatedAt: FieldRef<"checklist_categories", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * checklist_categories findUnique
   */
  export type checklist_categoriesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which checklist_categories to fetch.
     */
    where: checklist_categoriesWhereUniqueInput
  }

  /**
   * checklist_categories findUniqueOrThrow
   */
  export type checklist_categoriesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which checklist_categories to fetch.
     */
    where: checklist_categoriesWhereUniqueInput
  }

  /**
   * checklist_categories findFirst
   */
  export type checklist_categoriesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which checklist_categories to fetch.
     */
    where?: checklist_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_categories to fetch.
     */
    orderBy?: checklist_categoriesOrderByWithRelationInput | checklist_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checklist_categories.
     */
    cursor?: checklist_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checklist_categories.
     */
    distinct?: Checklist_categoriesScalarFieldEnum | Checklist_categoriesScalarFieldEnum[]
  }

  /**
   * checklist_categories findFirstOrThrow
   */
  export type checklist_categoriesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which checklist_categories to fetch.
     */
    where?: checklist_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_categories to fetch.
     */
    orderBy?: checklist_categoriesOrderByWithRelationInput | checklist_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checklist_categories.
     */
    cursor?: checklist_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_categories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checklist_categories.
     */
    distinct?: Checklist_categoriesScalarFieldEnum | Checklist_categoriesScalarFieldEnum[]
  }

  /**
   * checklist_categories findMany
   */
  export type checklist_categoriesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * Filter, which checklist_categories to fetch.
     */
    where?: checklist_categoriesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_categories to fetch.
     */
    orderBy?: checklist_categoriesOrderByWithRelationInput | checklist_categoriesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checklist_categories.
     */
    cursor?: checklist_categoriesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_categories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_categories.
     */
    skip?: number
    distinct?: Checklist_categoriesScalarFieldEnum | Checklist_categoriesScalarFieldEnum[]
  }

  /**
   * checklist_categories create
   */
  export type checklist_categoriesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to create a checklist_categories.
     */
    data: XOR<checklist_categoriesCreateInput, checklist_categoriesUncheckedCreateInput>
  }

  /**
   * checklist_categories createMany
   */
  export type checklist_categoriesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many checklist_categories.
     */
    data: checklist_categoriesCreateManyInput | checklist_categoriesCreateManyInput[]
  }

  /**
   * checklist_categories update
   */
  export type checklist_categoriesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * The data needed to update a checklist_categories.
     */
    data: XOR<checklist_categoriesUpdateInput, checklist_categoriesUncheckedUpdateInput>
    /**
     * Choose, which checklist_categories to update.
     */
    where: checklist_categoriesWhereUniqueInput
  }

  /**
   * checklist_categories updateMany
   */
  export type checklist_categoriesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update checklist_categories.
     */
    data: XOR<checklist_categoriesUpdateManyMutationInput, checklist_categoriesUncheckedUpdateManyInput>
    /**
     * Filter which checklist_categories to update
     */
    where?: checklist_categoriesWhereInput
    /**
     * Limit how many checklist_categories to update.
     */
    limit?: number
  }

  /**
   * checklist_categories upsert
   */
  export type checklist_categoriesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * The filter to search for the checklist_categories to update in case it exists.
     */
    where: checklist_categoriesWhereUniqueInput
    /**
     * In case the checklist_categories found by the `where` argument doesn't exist, create a new checklist_categories with this data.
     */
    create: XOR<checklist_categoriesCreateInput, checklist_categoriesUncheckedCreateInput>
    /**
     * In case the checklist_categories was found with the provided `where` argument, update it with this data.
     */
    update: XOR<checklist_categoriesUpdateInput, checklist_categoriesUncheckedUpdateInput>
  }

  /**
   * checklist_categories delete
   */
  export type checklist_categoriesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
    /**
     * Filter which checklist_categories to delete.
     */
    where: checklist_categoriesWhereUniqueInput
  }

  /**
   * checklist_categories deleteMany
   */
  export type checklist_categoriesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checklist_categories to delete
     */
    where?: checklist_categoriesWhereInput
    /**
     * Limit how many checklist_categories to delete.
     */
    limit?: number
  }

  /**
   * checklist_categories findRaw
   */
  export type checklist_categoriesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * checklist_categories aggregateRaw
   */
  export type checklist_categoriesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * checklist_categories.options
   */
  export type checklist_categories$optionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    where?: checklist_optionsWhereInput
    orderBy?: checklist_optionsOrderByWithRelationInput | checklist_optionsOrderByWithRelationInput[]
    cursor?: checklist_optionsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Checklist_optionsScalarFieldEnum | Checklist_optionsScalarFieldEnum[]
  }

  /**
   * checklist_categories without action
   */
  export type checklist_categoriesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_categories
     */
    select?: checklist_categoriesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_categories
     */
    omit?: checklist_categoriesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_categoriesInclude<ExtArgs> | null
  }


  /**
   * Model checklist_options
   */

  export type AggregateChecklist_options = {
    _count: Checklist_optionsCountAggregateOutputType | null
    _min: Checklist_optionsMinAggregateOutputType | null
    _max: Checklist_optionsMaxAggregateOutputType | null
  }

  export type Checklist_optionsMinAggregateOutputType = {
    id: string | null
    name: string | null
    category_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Checklist_optionsMaxAggregateOutputType = {
    id: string | null
    name: string | null
    category_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Checklist_optionsCountAggregateOutputType = {
    id: number
    name: number
    category_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Checklist_optionsMinAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Checklist_optionsMaxAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Checklist_optionsCountAggregateInputType = {
    id?: true
    name?: true
    category_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Checklist_optionsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checklist_options to aggregate.
     */
    where?: checklist_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_options to fetch.
     */
    orderBy?: checklist_optionsOrderByWithRelationInput | checklist_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: checklist_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned checklist_options
    **/
    _count?: true | Checklist_optionsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Checklist_optionsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Checklist_optionsMaxAggregateInputType
  }

  export type GetChecklist_optionsAggregateType<T extends Checklist_optionsAggregateArgs> = {
        [P in keyof T & keyof AggregateChecklist_options]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateChecklist_options[P]>
      : GetScalarType<T[P], AggregateChecklist_options[P]>
  }




  export type checklist_optionsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: checklist_optionsWhereInput
    orderBy?: checklist_optionsOrderByWithAggregationInput | checklist_optionsOrderByWithAggregationInput[]
    by: Checklist_optionsScalarFieldEnum[] | Checklist_optionsScalarFieldEnum
    having?: checklist_optionsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Checklist_optionsCountAggregateInputType | true
    _min?: Checklist_optionsMinAggregateInputType
    _max?: Checklist_optionsMaxAggregateInputType
  }

  export type Checklist_optionsGroupByOutputType = {
    id: string
    name: string
    category_id: string
    createdAt: Date
    updatedAt: Date
    _count: Checklist_optionsCountAggregateOutputType | null
    _min: Checklist_optionsMinAggregateOutputType | null
    _max: Checklist_optionsMaxAggregateOutputType | null
  }

  type GetChecklist_optionsGroupByPayload<T extends checklist_optionsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Checklist_optionsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Checklist_optionsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Checklist_optionsGroupByOutputType[P]>
            : GetScalarType<T[P], Checklist_optionsGroupByOutputType[P]>
        }
      >
    >


  export type checklist_optionsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    category_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    category?: boolean | checklist_categoriesDefaultArgs<ExtArgs>
    inspectionDetails?: boolean | checklist_options$inspectionDetailsArgs<ExtArgs>
    _count?: boolean | Checklist_optionsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["checklist_options"]>



  export type checklist_optionsSelectScalar = {
    id?: boolean
    name?: boolean
    category_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type checklist_optionsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "category_id" | "createdAt" | "updatedAt", ExtArgs["result"]["checklist_options"]>
  export type checklist_optionsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    category?: boolean | checklist_categoriesDefaultArgs<ExtArgs>
    inspectionDetails?: boolean | checklist_options$inspectionDetailsArgs<ExtArgs>
    _count?: boolean | Checklist_optionsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $checklist_optionsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "checklist_options"
    objects: {
      category: Prisma.$checklist_categoriesPayload<ExtArgs>
      inspectionDetails: Prisma.$vehicle_inspection_detailsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      category_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["checklist_options"]>
    composites: {}
  }

  type checklist_optionsGetPayload<S extends boolean | null | undefined | checklist_optionsDefaultArgs> = $Result.GetResult<Prisma.$checklist_optionsPayload, S>

  type checklist_optionsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<checklist_optionsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Checklist_optionsCountAggregateInputType | true
    }

  export interface checklist_optionsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['checklist_options'], meta: { name: 'checklist_options' } }
    /**
     * Find zero or one Checklist_options that matches the filter.
     * @param {checklist_optionsFindUniqueArgs} args - Arguments to find a Checklist_options
     * @example
     * // Get one Checklist_options
     * const checklist_options = await prisma.checklist_options.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends checklist_optionsFindUniqueArgs>(args: SelectSubset<T, checklist_optionsFindUniqueArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Checklist_options that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {checklist_optionsFindUniqueOrThrowArgs} args - Arguments to find a Checklist_options
     * @example
     * // Get one Checklist_options
     * const checklist_options = await prisma.checklist_options.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends checklist_optionsFindUniqueOrThrowArgs>(args: SelectSubset<T, checklist_optionsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checklist_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_optionsFindFirstArgs} args - Arguments to find a Checklist_options
     * @example
     * // Get one Checklist_options
     * const checklist_options = await prisma.checklist_options.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends checklist_optionsFindFirstArgs>(args?: SelectSubset<T, checklist_optionsFindFirstArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Checklist_options that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_optionsFindFirstOrThrowArgs} args - Arguments to find a Checklist_options
     * @example
     * // Get one Checklist_options
     * const checklist_options = await prisma.checklist_options.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends checklist_optionsFindFirstOrThrowArgs>(args?: SelectSubset<T, checklist_optionsFindFirstOrThrowArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checklist_options that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_optionsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Checklist_options
     * const checklist_options = await prisma.checklist_options.findMany()
     * 
     * // Get first 10 Checklist_options
     * const checklist_options = await prisma.checklist_options.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const checklist_optionsWithIdOnly = await prisma.checklist_options.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends checklist_optionsFindManyArgs>(args?: SelectSubset<T, checklist_optionsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Checklist_options.
     * @param {checklist_optionsCreateArgs} args - Arguments to create a Checklist_options.
     * @example
     * // Create one Checklist_options
     * const Checklist_options = await prisma.checklist_options.create({
     *   data: {
     *     // ... data to create a Checklist_options
     *   }
     * })
     * 
     */
    create<T extends checklist_optionsCreateArgs>(args: SelectSubset<T, checklist_optionsCreateArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Checklist_options.
     * @param {checklist_optionsCreateManyArgs} args - Arguments to create many Checklist_options.
     * @example
     * // Create many Checklist_options
     * const checklist_options = await prisma.checklist_options.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends checklist_optionsCreateManyArgs>(args?: SelectSubset<T, checklist_optionsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Checklist_options.
     * @param {checklist_optionsDeleteArgs} args - Arguments to delete one Checklist_options.
     * @example
     * // Delete one Checklist_options
     * const Checklist_options = await prisma.checklist_options.delete({
     *   where: {
     *     // ... filter to delete one Checklist_options
     *   }
     * })
     * 
     */
    delete<T extends checklist_optionsDeleteArgs>(args: SelectSubset<T, checklist_optionsDeleteArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Checklist_options.
     * @param {checklist_optionsUpdateArgs} args - Arguments to update one Checklist_options.
     * @example
     * // Update one Checklist_options
     * const checklist_options = await prisma.checklist_options.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends checklist_optionsUpdateArgs>(args: SelectSubset<T, checklist_optionsUpdateArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Checklist_options.
     * @param {checklist_optionsDeleteManyArgs} args - Arguments to filter Checklist_options to delete.
     * @example
     * // Delete a few Checklist_options
     * const { count } = await prisma.checklist_options.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends checklist_optionsDeleteManyArgs>(args?: SelectSubset<T, checklist_optionsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Checklist_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_optionsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Checklist_options
     * const checklist_options = await prisma.checklist_options.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends checklist_optionsUpdateManyArgs>(args: SelectSubset<T, checklist_optionsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Checklist_options.
     * @param {checklist_optionsUpsertArgs} args - Arguments to update or create a Checklist_options.
     * @example
     * // Update or create a Checklist_options
     * const checklist_options = await prisma.checklist_options.upsert({
     *   create: {
     *     // ... data to create a Checklist_options
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Checklist_options we want to update
     *   }
     * })
     */
    upsert<T extends checklist_optionsUpsertArgs>(args: SelectSubset<T, checklist_optionsUpsertArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Checklist_options that matches the filter.
     * @param {checklist_optionsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const checklist_options = await prisma.checklist_options.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: checklist_optionsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Checklist_options.
     * @param {checklist_optionsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const checklist_options = await prisma.checklist_options.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: checklist_optionsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Checklist_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_optionsCountArgs} args - Arguments to filter Checklist_options to count.
     * @example
     * // Count the number of Checklist_options
     * const count = await prisma.checklist_options.count({
     *   where: {
     *     // ... the filter for the Checklist_options we want to count
     *   }
     * })
    **/
    count<T extends checklist_optionsCountArgs>(
      args?: Subset<T, checklist_optionsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Checklist_optionsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Checklist_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Checklist_optionsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Checklist_optionsAggregateArgs>(args: Subset<T, Checklist_optionsAggregateArgs>): Prisma.PrismaPromise<GetChecklist_optionsAggregateType<T>>

    /**
     * Group by Checklist_options.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {checklist_optionsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends checklist_optionsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: checklist_optionsGroupByArgs['orderBy'] }
        : { orderBy?: checklist_optionsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, checklist_optionsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetChecklist_optionsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the checklist_options model
   */
  readonly fields: checklist_optionsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for checklist_options.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__checklist_optionsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    category<T extends checklist_categoriesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, checklist_categoriesDefaultArgs<ExtArgs>>): Prisma__checklist_categoriesClient<$Result.GetResult<Prisma.$checklist_categoriesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    inspectionDetails<T extends checklist_options$inspectionDetailsArgs<ExtArgs> = {}>(args?: Subset<T, checklist_options$inspectionDetailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the checklist_options model
   */
  interface checklist_optionsFieldRefs {
    readonly id: FieldRef<"checklist_options", 'String'>
    readonly name: FieldRef<"checklist_options", 'String'>
    readonly category_id: FieldRef<"checklist_options", 'String'>
    readonly createdAt: FieldRef<"checklist_options", 'DateTime'>
    readonly updatedAt: FieldRef<"checklist_options", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * checklist_options findUnique
   */
  export type checklist_optionsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * Filter, which checklist_options to fetch.
     */
    where: checklist_optionsWhereUniqueInput
  }

  /**
   * checklist_options findUniqueOrThrow
   */
  export type checklist_optionsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * Filter, which checklist_options to fetch.
     */
    where: checklist_optionsWhereUniqueInput
  }

  /**
   * checklist_options findFirst
   */
  export type checklist_optionsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * Filter, which checklist_options to fetch.
     */
    where?: checklist_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_options to fetch.
     */
    orderBy?: checklist_optionsOrderByWithRelationInput | checklist_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checklist_options.
     */
    cursor?: checklist_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checklist_options.
     */
    distinct?: Checklist_optionsScalarFieldEnum | Checklist_optionsScalarFieldEnum[]
  }

  /**
   * checklist_options findFirstOrThrow
   */
  export type checklist_optionsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * Filter, which checklist_options to fetch.
     */
    where?: checklist_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_options to fetch.
     */
    orderBy?: checklist_optionsOrderByWithRelationInput | checklist_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for checklist_options.
     */
    cursor?: checklist_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_options.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of checklist_options.
     */
    distinct?: Checklist_optionsScalarFieldEnum | Checklist_optionsScalarFieldEnum[]
  }

  /**
   * checklist_options findMany
   */
  export type checklist_optionsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * Filter, which checklist_options to fetch.
     */
    where?: checklist_optionsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of checklist_options to fetch.
     */
    orderBy?: checklist_optionsOrderByWithRelationInput | checklist_optionsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing checklist_options.
     */
    cursor?: checklist_optionsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` checklist_options from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` checklist_options.
     */
    skip?: number
    distinct?: Checklist_optionsScalarFieldEnum | Checklist_optionsScalarFieldEnum[]
  }

  /**
   * checklist_options create
   */
  export type checklist_optionsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * The data needed to create a checklist_options.
     */
    data: XOR<checklist_optionsCreateInput, checklist_optionsUncheckedCreateInput>
  }

  /**
   * checklist_options createMany
   */
  export type checklist_optionsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many checklist_options.
     */
    data: checklist_optionsCreateManyInput | checklist_optionsCreateManyInput[]
  }

  /**
   * checklist_options update
   */
  export type checklist_optionsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * The data needed to update a checklist_options.
     */
    data: XOR<checklist_optionsUpdateInput, checklist_optionsUncheckedUpdateInput>
    /**
     * Choose, which checklist_options to update.
     */
    where: checklist_optionsWhereUniqueInput
  }

  /**
   * checklist_options updateMany
   */
  export type checklist_optionsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update checklist_options.
     */
    data: XOR<checklist_optionsUpdateManyMutationInput, checklist_optionsUncheckedUpdateManyInput>
    /**
     * Filter which checklist_options to update
     */
    where?: checklist_optionsWhereInput
    /**
     * Limit how many checklist_options to update.
     */
    limit?: number
  }

  /**
   * checklist_options upsert
   */
  export type checklist_optionsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * The filter to search for the checklist_options to update in case it exists.
     */
    where: checklist_optionsWhereUniqueInput
    /**
     * In case the checklist_options found by the `where` argument doesn't exist, create a new checklist_options with this data.
     */
    create: XOR<checklist_optionsCreateInput, checklist_optionsUncheckedCreateInput>
    /**
     * In case the checklist_options was found with the provided `where` argument, update it with this data.
     */
    update: XOR<checklist_optionsUpdateInput, checklist_optionsUncheckedUpdateInput>
  }

  /**
   * checklist_options delete
   */
  export type checklist_optionsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
    /**
     * Filter which checklist_options to delete.
     */
    where: checklist_optionsWhereUniqueInput
  }

  /**
   * checklist_options deleteMany
   */
  export type checklist_optionsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which checklist_options to delete
     */
    where?: checklist_optionsWhereInput
    /**
     * Limit how many checklist_options to delete.
     */
    limit?: number
  }

  /**
   * checklist_options findRaw
   */
  export type checklist_optionsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * checklist_options aggregateRaw
   */
  export type checklist_optionsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * checklist_options.inspectionDetails
   */
  export type checklist_options$inspectionDetailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    where?: vehicle_inspection_detailsWhereInput
    orderBy?: vehicle_inspection_detailsOrderByWithRelationInput | vehicle_inspection_detailsOrderByWithRelationInput[]
    cursor?: vehicle_inspection_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_inspection_detailsScalarFieldEnum | Vehicle_inspection_detailsScalarFieldEnum[]
  }

  /**
   * checklist_options without action
   */
  export type checklist_optionsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the checklist_options
     */
    select?: checklist_optionsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the checklist_options
     */
    omit?: checklist_optionsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: checklist_optionsInclude<ExtArgs> | null
  }


  /**
   * Model vehicle
   */

  export type AggregateVehicle = {
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  export type VehicleAvgAggregateOutputType = {
    kms_driven: number | null
    mileage: number | null
    engine_capacity: number | null
  }

  export type VehicleSumAggregateOutputType = {
    kms_driven: number | null
    mileage: number | null
    engine_capacity: number | null
  }

  export type VehicleMinAggregateOutputType = {
    id: string | null
    registration_number: string | null
    owner_name: string | null
    insurance_company: string | null
    insurance_number: string | null
    chassis_number: string | null
    rc_image: string | null
    insurance_image: string | null
    brand_id: string | null
    model_id: string | null
    variant_id: string | null
    kms_driven: number | null
    color: string | null
    mileage: number | null
    engine_capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleMaxAggregateOutputType = {
    id: string | null
    registration_number: string | null
    owner_name: string | null
    insurance_company: string | null
    insurance_number: string | null
    chassis_number: string | null
    rc_image: string | null
    insurance_image: string | null
    brand_id: string | null
    model_id: string | null
    variant_id: string | null
    kms_driven: number | null
    color: string | null
    mileage: number | null
    engine_capacity: number | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type VehicleCountAggregateOutputType = {
    id: number
    registration_number: number
    owner_name: number
    insurance_company: number
    insurance_number: number
    chassis_number: number
    rc_image: number
    insurance_image: number
    brand_id: number
    model_id: number
    variant_id: number
    kms_driven: number
    color: number
    mileage: number
    engine_capacity: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type VehicleAvgAggregateInputType = {
    kms_driven?: true
    mileage?: true
    engine_capacity?: true
  }

  export type VehicleSumAggregateInputType = {
    kms_driven?: true
    mileage?: true
    engine_capacity?: true
  }

  export type VehicleMinAggregateInputType = {
    id?: true
    registration_number?: true
    owner_name?: true
    insurance_company?: true
    insurance_number?: true
    chassis_number?: true
    rc_image?: true
    insurance_image?: true
    brand_id?: true
    model_id?: true
    variant_id?: true
    kms_driven?: true
    color?: true
    mileage?: true
    engine_capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleMaxAggregateInputType = {
    id?: true
    registration_number?: true
    owner_name?: true
    insurance_company?: true
    insurance_number?: true
    chassis_number?: true
    rc_image?: true
    insurance_image?: true
    brand_id?: true
    model_id?: true
    variant_id?: true
    kms_driven?: true
    color?: true
    mileage?: true
    engine_capacity?: true
    createdAt?: true
    updatedAt?: true
  }

  export type VehicleCountAggregateInputType = {
    id?: true
    registration_number?: true
    owner_name?: true
    insurance_company?: true
    insurance_number?: true
    chassis_number?: true
    rc_image?: true
    insurance_image?: true
    brand_id?: true
    model_id?: true
    variant_id?: true
    kms_driven?: true
    color?: true
    mileage?: true
    engine_capacity?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type VehicleAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle to aggregate.
     */
    where?: vehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicles
    **/
    _count?: true | VehicleCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: VehicleAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: VehicleSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: VehicleMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: VehicleMaxAggregateInputType
  }

  export type GetVehicleAggregateType<T extends VehicleAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle[P]>
      : GetScalarType<T[P], AggregateVehicle[P]>
  }




  export type vehicleGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicleWhereInput
    orderBy?: vehicleOrderByWithAggregationInput | vehicleOrderByWithAggregationInput[]
    by: VehicleScalarFieldEnum[] | VehicleScalarFieldEnum
    having?: vehicleScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: VehicleCountAggregateInputType | true
    _avg?: VehicleAvgAggregateInputType
    _sum?: VehicleSumAggregateInputType
    _min?: VehicleMinAggregateInputType
    _max?: VehicleMaxAggregateInputType
  }

  export type VehicleGroupByOutputType = {
    id: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt: Date
    updatedAt: Date
    _count: VehicleCountAggregateOutputType | null
    _avg: VehicleAvgAggregateOutputType | null
    _sum: VehicleSumAggregateOutputType | null
    _min: VehicleMinAggregateOutputType | null
    _max: VehicleMaxAggregateOutputType | null
  }

  type GetVehicleGroupByPayload<T extends vehicleGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<VehicleGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof VehicleGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], VehicleGroupByOutputType[P]>
            : GetScalarType<T[P], VehicleGroupByOutputType[P]>
        }
      >
    >


  export type vehicleSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    registration_number?: boolean
    owner_name?: boolean
    insurance_company?: boolean
    insurance_number?: boolean
    chassis_number?: boolean
    rc_image?: boolean
    insurance_image?: boolean
    brand_id?: boolean
    model_id?: boolean
    variant_id?: boolean
    kms_driven?: boolean
    color?: boolean
    mileage?: boolean
    engine_capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    model?: boolean | modelsDefaultArgs<ExtArgs>
    variant?: boolean | variantsDefaultArgs<ExtArgs>
    features?: boolean | vehicle$featuresArgs<ExtArgs>
    images?: boolean | vehicle$imagesArgs<ExtArgs>
    availability?: boolean | vehicle$availabilityArgs<ExtArgs>
    availability_history?: boolean | vehicle$availability_historyArgs<ExtArgs>
    inspections?: boolean | vehicle$inspectionsArgs<ExtArgs>
    prices?: boolean | vehicle$pricesArgs<ExtArgs>
    bookings?: boolean | vehicle$bookingsArgs<ExtArgs>
    booking_logs?: boolean | vehicle$booking_logsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle"]>



  export type vehicleSelectScalar = {
    id?: boolean
    registration_number?: boolean
    owner_name?: boolean
    insurance_company?: boolean
    insurance_number?: boolean
    chassis_number?: boolean
    rc_image?: boolean
    insurance_image?: boolean
    brand_id?: boolean
    model_id?: boolean
    variant_id?: boolean
    kms_driven?: boolean
    color?: boolean
    mileage?: boolean
    engine_capacity?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicleOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "registration_number" | "owner_name" | "insurance_company" | "insurance_number" | "chassis_number" | "rc_image" | "insurance_image" | "brand_id" | "model_id" | "variant_id" | "kms_driven" | "color" | "mileage" | "engine_capacity" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle"]>
  export type vehicleInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    brand?: boolean | brandsDefaultArgs<ExtArgs>
    model?: boolean | modelsDefaultArgs<ExtArgs>
    variant?: boolean | variantsDefaultArgs<ExtArgs>
    features?: boolean | vehicle$featuresArgs<ExtArgs>
    images?: boolean | vehicle$imagesArgs<ExtArgs>
    availability?: boolean | vehicle$availabilityArgs<ExtArgs>
    availability_history?: boolean | vehicle$availability_historyArgs<ExtArgs>
    inspections?: boolean | vehicle$inspectionsArgs<ExtArgs>
    prices?: boolean | vehicle$pricesArgs<ExtArgs>
    bookings?: boolean | vehicle$bookingsArgs<ExtArgs>
    booking_logs?: boolean | vehicle$booking_logsArgs<ExtArgs>
    _count?: boolean | VehicleCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $vehiclePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle"
    objects: {
      brand: Prisma.$brandsPayload<ExtArgs>
      model: Prisma.$modelsPayload<ExtArgs>
      variant: Prisma.$variantsPayload<ExtArgs>
      features: Prisma.$vehicle_featuresPayload<ExtArgs>[]
      images: Prisma.$vehicle_imagesPayload<ExtArgs>[]
      availability: Prisma.$vehicle_availabilityPayload<ExtArgs>[]
      availability_history: Prisma.$vehicle_availability_historyPayload<ExtArgs>[]
      inspections: Prisma.$vehicle_inspectionPayload<ExtArgs>[]
      prices: Prisma.$vehicle_pricesPayload<ExtArgs>[]
      bookings: Prisma.$vehicle_bookingsPayload<ExtArgs>[]
      booking_logs: Prisma.$vehicle_bookings_logsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      registration_number: string
      owner_name: string
      insurance_company: string
      insurance_number: string
      chassis_number: string
      rc_image: string
      insurance_image: string
      brand_id: string
      model_id: string
      variant_id: string
      kms_driven: number
      color: string
      mileage: number
      engine_capacity: number
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle"]>
    composites: {}
  }

  type vehicleGetPayload<S extends boolean | null | undefined | vehicleDefaultArgs> = $Result.GetResult<Prisma.$vehiclePayload, S>

  type vehicleCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicleFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: VehicleCountAggregateInputType | true
    }

  export interface vehicleDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle'], meta: { name: 'vehicle' } }
    /**
     * Find zero or one Vehicle that matches the filter.
     * @param {vehicleFindUniqueArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicleFindUniqueArgs>(args: SelectSubset<T, vehicleFindUniqueArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicleFindUniqueOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicleFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicleFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicleFindFirstArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicleFindFirstArgs>(args?: SelectSubset<T, vehicleFindFirstArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicleFindFirstOrThrowArgs} args - Arguments to find a Vehicle
     * @example
     * // Get one Vehicle
     * const vehicle = await prisma.vehicle.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicleFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicleFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicleFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicles
     * const vehicles = await prisma.vehicle.findMany()
     * 
     * // Get first 10 Vehicles
     * const vehicles = await prisma.vehicle.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicleWithIdOnly = await prisma.vehicle.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicleFindManyArgs>(args?: SelectSubset<T, vehicleFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle.
     * @param {vehicleCreateArgs} args - Arguments to create a Vehicle.
     * @example
     * // Create one Vehicle
     * const Vehicle = await prisma.vehicle.create({
     *   data: {
     *     // ... data to create a Vehicle
     *   }
     * })
     * 
     */
    create<T extends vehicleCreateArgs>(args: SelectSubset<T, vehicleCreateArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicles.
     * @param {vehicleCreateManyArgs} args - Arguments to create many Vehicles.
     * @example
     * // Create many Vehicles
     * const vehicle = await prisma.vehicle.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicleCreateManyArgs>(args?: SelectSubset<T, vehicleCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle.
     * @param {vehicleDeleteArgs} args - Arguments to delete one Vehicle.
     * @example
     * // Delete one Vehicle
     * const Vehicle = await prisma.vehicle.delete({
     *   where: {
     *     // ... filter to delete one Vehicle
     *   }
     * })
     * 
     */
    delete<T extends vehicleDeleteArgs>(args: SelectSubset<T, vehicleDeleteArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle.
     * @param {vehicleUpdateArgs} args - Arguments to update one Vehicle.
     * @example
     * // Update one Vehicle
     * const vehicle = await prisma.vehicle.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicleUpdateArgs>(args: SelectSubset<T, vehicleUpdateArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicles.
     * @param {vehicleDeleteManyArgs} args - Arguments to filter Vehicles to delete.
     * @example
     * // Delete a few Vehicles
     * const { count } = await prisma.vehicle.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicleDeleteManyArgs>(args?: SelectSubset<T, vehicleDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicleUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicles
     * const vehicle = await prisma.vehicle.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicleUpdateManyArgs>(args: SelectSubset<T, vehicleUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle.
     * @param {vehicleUpsertArgs} args - Arguments to update or create a Vehicle.
     * @example
     * // Update or create a Vehicle
     * const vehicle = await prisma.vehicle.upsert({
     *   create: {
     *     // ... data to create a Vehicle
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle we want to update
     *   }
     * })
     */
    upsert<T extends vehicleUpsertArgs>(args: SelectSubset<T, vehicleUpsertArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicles that matches the filter.
     * @param {vehicleFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle = await prisma.vehicle.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicleFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle.
     * @param {vehicleAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle = await prisma.vehicle.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicleAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicles.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicleCountArgs} args - Arguments to filter Vehicles to count.
     * @example
     * // Count the number of Vehicles
     * const count = await prisma.vehicle.count({
     *   where: {
     *     // ... the filter for the Vehicles we want to count
     *   }
     * })
    **/
    count<T extends vehicleCountArgs>(
      args?: Subset<T, vehicleCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], VehicleCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {VehicleAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends VehicleAggregateArgs>(args: Subset<T, VehicleAggregateArgs>): Prisma.PrismaPromise<GetVehicleAggregateType<T>>

    /**
     * Group by Vehicle.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicleGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicleGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicleGroupByArgs['orderBy'] }
        : { orderBy?: vehicleGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicleGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicleGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle model
   */
  readonly fields: vehicleFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicleClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    brand<T extends brandsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, brandsDefaultArgs<ExtArgs>>): Prisma__brandsClient<$Result.GetResult<Prisma.$brandsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    model<T extends modelsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, modelsDefaultArgs<ExtArgs>>): Prisma__modelsClient<$Result.GetResult<Prisma.$modelsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    variant<T extends variantsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, variantsDefaultArgs<ExtArgs>>): Prisma__variantsClient<$Result.GetResult<Prisma.$variantsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    features<T extends vehicle$featuresArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$featuresArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    images<T extends vehicle$imagesArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$imagesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability<T extends vehicle$availabilityArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$availabilityArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    availability_history<T extends vehicle$availability_historyArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$availability_historyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    inspections<T extends vehicle$inspectionsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$inspectionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    prices<T extends vehicle$pricesArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$pricesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bookings<T extends vehicle$bookingsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_logs<T extends vehicle$booking_logsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle$booking_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle model
   */
  interface vehicleFieldRefs {
    readonly id: FieldRef<"vehicle", 'String'>
    readonly registration_number: FieldRef<"vehicle", 'String'>
    readonly owner_name: FieldRef<"vehicle", 'String'>
    readonly insurance_company: FieldRef<"vehicle", 'String'>
    readonly insurance_number: FieldRef<"vehicle", 'String'>
    readonly chassis_number: FieldRef<"vehicle", 'String'>
    readonly rc_image: FieldRef<"vehicle", 'String'>
    readonly insurance_image: FieldRef<"vehicle", 'String'>
    readonly brand_id: FieldRef<"vehicle", 'String'>
    readonly model_id: FieldRef<"vehicle", 'String'>
    readonly variant_id: FieldRef<"vehicle", 'String'>
    readonly kms_driven: FieldRef<"vehicle", 'Int'>
    readonly color: FieldRef<"vehicle", 'String'>
    readonly mileage: FieldRef<"vehicle", 'Float'>
    readonly engine_capacity: FieldRef<"vehicle", 'Int'>
    readonly createdAt: FieldRef<"vehicle", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle findUnique
   */
  export type vehicleFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * Filter, which vehicle to fetch.
     */
    where: vehicleWhereUniqueInput
  }

  /**
   * vehicle findUniqueOrThrow
   */
  export type vehicleFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * Filter, which vehicle to fetch.
     */
    where: vehicleWhereUniqueInput
  }

  /**
   * vehicle findFirst
   */
  export type vehicleFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * Filter, which vehicle to fetch.
     */
    where?: vehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * vehicle findFirstOrThrow
   */
  export type vehicleFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * Filter, which vehicle to fetch.
     */
    where?: vehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicles.
     */
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicles.
     */
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * vehicle findMany
   */
  export type vehicleFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * Filter, which vehicles to fetch.
     */
    where?: vehicleWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicles to fetch.
     */
    orderBy?: vehicleOrderByWithRelationInput | vehicleOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicles.
     */
    cursor?: vehicleWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicles from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicles.
     */
    skip?: number
    distinct?: VehicleScalarFieldEnum | VehicleScalarFieldEnum[]
  }

  /**
   * vehicle create
   */
  export type vehicleCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle.
     */
    data: XOR<vehicleCreateInput, vehicleUncheckedCreateInput>
  }

  /**
   * vehicle createMany
   */
  export type vehicleCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicles.
     */
    data: vehicleCreateManyInput | vehicleCreateManyInput[]
  }

  /**
   * vehicle update
   */
  export type vehicleUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle.
     */
    data: XOR<vehicleUpdateInput, vehicleUncheckedUpdateInput>
    /**
     * Choose, which vehicle to update.
     */
    where: vehicleWhereUniqueInput
  }

  /**
   * vehicle updateMany
   */
  export type vehicleUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicles.
     */
    data: XOR<vehicleUpdateManyMutationInput, vehicleUncheckedUpdateManyInput>
    /**
     * Filter which vehicles to update
     */
    where?: vehicleWhereInput
    /**
     * Limit how many vehicles to update.
     */
    limit?: number
  }

  /**
   * vehicle upsert
   */
  export type vehicleUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle to update in case it exists.
     */
    where: vehicleWhereUniqueInput
    /**
     * In case the vehicle found by the `where` argument doesn't exist, create a new vehicle with this data.
     */
    create: XOR<vehicleCreateInput, vehicleUncheckedCreateInput>
    /**
     * In case the vehicle was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicleUpdateInput, vehicleUncheckedUpdateInput>
  }

  /**
   * vehicle delete
   */
  export type vehicleDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    /**
     * Filter which vehicle to delete.
     */
    where: vehicleWhereUniqueInput
  }

  /**
   * vehicle deleteMany
   */
  export type vehicleDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicles to delete
     */
    where?: vehicleWhereInput
    /**
     * Limit how many vehicles to delete.
     */
    limit?: number
  }

  /**
   * vehicle findRaw
   */
  export type vehicleFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle aggregateRaw
   */
  export type vehicleAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle.features
   */
  export type vehicle$featuresArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    where?: vehicle_featuresWhereInput
    orderBy?: vehicle_featuresOrderByWithRelationInput | vehicle_featuresOrderByWithRelationInput[]
    cursor?: vehicle_featuresWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_featuresScalarFieldEnum | Vehicle_featuresScalarFieldEnum[]
  }

  /**
   * vehicle.images
   */
  export type vehicle$imagesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    where?: vehicle_imagesWhereInput
    orderBy?: vehicle_imagesOrderByWithRelationInput | vehicle_imagesOrderByWithRelationInput[]
    cursor?: vehicle_imagesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_imagesScalarFieldEnum | Vehicle_imagesScalarFieldEnum[]
  }

  /**
   * vehicle.availability
   */
  export type vehicle$availabilityArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    where?: vehicle_availabilityWhereInput
    orderBy?: vehicle_availabilityOrderByWithRelationInput | vehicle_availabilityOrderByWithRelationInput[]
    cursor?: vehicle_availabilityWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_availabilityScalarFieldEnum | Vehicle_availabilityScalarFieldEnum[]
  }

  /**
   * vehicle.availability_history
   */
  export type vehicle$availability_historyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    where?: vehicle_availability_historyWhereInput
    orderBy?: vehicle_availability_historyOrderByWithRelationInput | vehicle_availability_historyOrderByWithRelationInput[]
    cursor?: vehicle_availability_historyWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_availability_historyScalarFieldEnum | Vehicle_availability_historyScalarFieldEnum[]
  }

  /**
   * vehicle.inspections
   */
  export type vehicle$inspectionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    where?: vehicle_inspectionWhereInput
    orderBy?: vehicle_inspectionOrderByWithRelationInput | vehicle_inspectionOrderByWithRelationInput[]
    cursor?: vehicle_inspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_inspectionScalarFieldEnum | Vehicle_inspectionScalarFieldEnum[]
  }

  /**
   * vehicle.prices
   */
  export type vehicle$pricesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    where?: vehicle_pricesWhereInput
    orderBy?: vehicle_pricesOrderByWithRelationInput | vehicle_pricesOrderByWithRelationInput[]
    cursor?: vehicle_pricesWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_pricesScalarFieldEnum | Vehicle_pricesScalarFieldEnum[]
  }

  /**
   * vehicle.bookings
   */
  export type vehicle$bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    where?: vehicle_bookingsWhereInput
    orderBy?: vehicle_bookingsOrderByWithRelationInput | vehicle_bookingsOrderByWithRelationInput[]
    cursor?: vehicle_bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookingsScalarFieldEnum | Vehicle_bookingsScalarFieldEnum[]
  }

  /**
   * vehicle.booking_logs
   */
  export type vehicle$booking_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    where?: vehicle_bookings_logsWhereInput
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    cursor?: vehicle_bookings_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookings_logsScalarFieldEnum | Vehicle_bookings_logsScalarFieldEnum[]
  }

  /**
   * vehicle without action
   */
  export type vehicleDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_features
   */

  export type AggregateVehicle_features = {
    _count: Vehicle_featuresCountAggregateOutputType | null
    _min: Vehicle_featuresMinAggregateOutputType | null
    _max: Vehicle_featuresMaxAggregateOutputType | null
  }

  export type Vehicle_featuresMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    feature_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_featuresMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    feature_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_featuresCountAggregateOutputType = {
    id: number
    vehicle_id: number
    feature_name: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_featuresMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    feature_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_featuresMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    feature_name?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_featuresCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    feature_name?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_featuresAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_features to aggregate.
     */
    where?: vehicle_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_features to fetch.
     */
    orderBy?: vehicle_featuresOrderByWithRelationInput | vehicle_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_features
    **/
    _count?: true | Vehicle_featuresCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_featuresMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_featuresMaxAggregateInputType
  }

  export type GetVehicle_featuresAggregateType<T extends Vehicle_featuresAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_features]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_features[P]>
      : GetScalarType<T[P], AggregateVehicle_features[P]>
  }




  export type vehicle_featuresGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_featuresWhereInput
    orderBy?: vehicle_featuresOrderByWithAggregationInput | vehicle_featuresOrderByWithAggregationInput[]
    by: Vehicle_featuresScalarFieldEnum[] | Vehicle_featuresScalarFieldEnum
    having?: vehicle_featuresScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_featuresCountAggregateInputType | true
    _min?: Vehicle_featuresMinAggregateInputType
    _max?: Vehicle_featuresMaxAggregateInputType
  }

  export type Vehicle_featuresGroupByOutputType = {
    id: string
    vehicle_id: string
    feature_name: string
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_featuresCountAggregateOutputType | null
    _min: Vehicle_featuresMinAggregateOutputType | null
    _max: Vehicle_featuresMaxAggregateOutputType | null
  }

  type GetVehicle_featuresGroupByPayload<T extends vehicle_featuresGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_featuresGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_featuresGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_featuresGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_featuresGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_featuresSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    feature_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_features"]>



  export type vehicle_featuresSelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    feature_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_featuresOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "feature_name" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_features"]>
  export type vehicle_featuresInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }

  export type $vehicle_featuresPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_features"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string
      feature_name: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_features"]>
    composites: {}
  }

  type vehicle_featuresGetPayload<S extends boolean | null | undefined | vehicle_featuresDefaultArgs> = $Result.GetResult<Prisma.$vehicle_featuresPayload, S>

  type vehicle_featuresCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_featuresFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_featuresCountAggregateInputType | true
    }

  export interface vehicle_featuresDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_features'], meta: { name: 'vehicle_features' } }
    /**
     * Find zero or one Vehicle_features that matches the filter.
     * @param {vehicle_featuresFindUniqueArgs} args - Arguments to find a Vehicle_features
     * @example
     * // Get one Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_featuresFindUniqueArgs>(args: SelectSubset<T, vehicle_featuresFindUniqueArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_features that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_featuresFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_features
     * @example
     * // Get one Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_featuresFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_featuresFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_featuresFindFirstArgs} args - Arguments to find a Vehicle_features
     * @example
     * // Get one Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_featuresFindFirstArgs>(args?: SelectSubset<T, vehicle_featuresFindFirstArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_features that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_featuresFindFirstOrThrowArgs} args - Arguments to find a Vehicle_features
     * @example
     * // Get one Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_featuresFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_featuresFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_features that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_featuresFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.findMany()
     * 
     * // Get first 10 Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_featuresWithIdOnly = await prisma.vehicle_features.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_featuresFindManyArgs>(args?: SelectSubset<T, vehicle_featuresFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_features.
     * @param {vehicle_featuresCreateArgs} args - Arguments to create a Vehicle_features.
     * @example
     * // Create one Vehicle_features
     * const Vehicle_features = await prisma.vehicle_features.create({
     *   data: {
     *     // ... data to create a Vehicle_features
     *   }
     * })
     * 
     */
    create<T extends vehicle_featuresCreateArgs>(args: SelectSubset<T, vehicle_featuresCreateArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_features.
     * @param {vehicle_featuresCreateManyArgs} args - Arguments to create many Vehicle_features.
     * @example
     * // Create many Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_featuresCreateManyArgs>(args?: SelectSubset<T, vehicle_featuresCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_features.
     * @param {vehicle_featuresDeleteArgs} args - Arguments to delete one Vehicle_features.
     * @example
     * // Delete one Vehicle_features
     * const Vehicle_features = await prisma.vehicle_features.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_features
     *   }
     * })
     * 
     */
    delete<T extends vehicle_featuresDeleteArgs>(args: SelectSubset<T, vehicle_featuresDeleteArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_features.
     * @param {vehicle_featuresUpdateArgs} args - Arguments to update one Vehicle_features.
     * @example
     * // Update one Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_featuresUpdateArgs>(args: SelectSubset<T, vehicle_featuresUpdateArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_features.
     * @param {vehicle_featuresDeleteManyArgs} args - Arguments to filter Vehicle_features to delete.
     * @example
     * // Delete a few Vehicle_features
     * const { count } = await prisma.vehicle_features.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_featuresDeleteManyArgs>(args?: SelectSubset<T, vehicle_featuresDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_featuresUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_featuresUpdateManyArgs>(args: SelectSubset<T, vehicle_featuresUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_features.
     * @param {vehicle_featuresUpsertArgs} args - Arguments to update or create a Vehicle_features.
     * @example
     * // Update or create a Vehicle_features
     * const vehicle_features = await prisma.vehicle_features.upsert({
     *   create: {
     *     // ... data to create a Vehicle_features
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_features we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_featuresUpsertArgs>(args: SelectSubset<T, vehicle_featuresUpsertArgs<ExtArgs>>): Prisma__vehicle_featuresClient<$Result.GetResult<Prisma.$vehicle_featuresPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_features that matches the filter.
     * @param {vehicle_featuresFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_features = await prisma.vehicle_features.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_featuresFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_features.
     * @param {vehicle_featuresAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_features = await prisma.vehicle_features.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_featuresAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_featuresCountArgs} args - Arguments to filter Vehicle_features to count.
     * @example
     * // Count the number of Vehicle_features
     * const count = await prisma.vehicle_features.count({
     *   where: {
     *     // ... the filter for the Vehicle_features we want to count
     *   }
     * })
    **/
    count<T extends vehicle_featuresCountArgs>(
      args?: Subset<T, vehicle_featuresCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_featuresCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_featuresAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_featuresAggregateArgs>(args: Subset<T, Vehicle_featuresAggregateArgs>): Prisma.PrismaPromise<GetVehicle_featuresAggregateType<T>>

    /**
     * Group by Vehicle_features.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_featuresGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_featuresGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_featuresGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_featuresGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_featuresGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_featuresGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_features model
   */
  readonly fields: vehicle_featuresFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_features.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_featuresClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_features model
   */
  interface vehicle_featuresFieldRefs {
    readonly id: FieldRef<"vehicle_features", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_features", 'String'>
    readonly feature_name: FieldRef<"vehicle_features", 'String'>
    readonly createdAt: FieldRef<"vehicle_features", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_features", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_features findUnique
   */
  export type vehicle_featuresFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_features to fetch.
     */
    where: vehicle_featuresWhereUniqueInput
  }

  /**
   * vehicle_features findUniqueOrThrow
   */
  export type vehicle_featuresFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_features to fetch.
     */
    where: vehicle_featuresWhereUniqueInput
  }

  /**
   * vehicle_features findFirst
   */
  export type vehicle_featuresFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_features to fetch.
     */
    where?: vehicle_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_features to fetch.
     */
    orderBy?: vehicle_featuresOrderByWithRelationInput | vehicle_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_features.
     */
    cursor?: vehicle_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_features.
     */
    distinct?: Vehicle_featuresScalarFieldEnum | Vehicle_featuresScalarFieldEnum[]
  }

  /**
   * vehicle_features findFirstOrThrow
   */
  export type vehicle_featuresFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_features to fetch.
     */
    where?: vehicle_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_features to fetch.
     */
    orderBy?: vehicle_featuresOrderByWithRelationInput | vehicle_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_features.
     */
    cursor?: vehicle_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_features.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_features.
     */
    distinct?: Vehicle_featuresScalarFieldEnum | Vehicle_featuresScalarFieldEnum[]
  }

  /**
   * vehicle_features findMany
   */
  export type vehicle_featuresFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_features to fetch.
     */
    where?: vehicle_featuresWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_features to fetch.
     */
    orderBy?: vehicle_featuresOrderByWithRelationInput | vehicle_featuresOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_features.
     */
    cursor?: vehicle_featuresWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_features from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_features.
     */
    skip?: number
    distinct?: Vehicle_featuresScalarFieldEnum | Vehicle_featuresScalarFieldEnum[]
  }

  /**
   * vehicle_features create
   */
  export type vehicle_featuresCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_features.
     */
    data: XOR<vehicle_featuresCreateInput, vehicle_featuresUncheckedCreateInput>
  }

  /**
   * vehicle_features createMany
   */
  export type vehicle_featuresCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_features.
     */
    data: vehicle_featuresCreateManyInput | vehicle_featuresCreateManyInput[]
  }

  /**
   * vehicle_features update
   */
  export type vehicle_featuresUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_features.
     */
    data: XOR<vehicle_featuresUpdateInput, vehicle_featuresUncheckedUpdateInput>
    /**
     * Choose, which vehicle_features to update.
     */
    where: vehicle_featuresWhereUniqueInput
  }

  /**
   * vehicle_features updateMany
   */
  export type vehicle_featuresUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_features.
     */
    data: XOR<vehicle_featuresUpdateManyMutationInput, vehicle_featuresUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_features to update
     */
    where?: vehicle_featuresWhereInput
    /**
     * Limit how many vehicle_features to update.
     */
    limit?: number
  }

  /**
   * vehicle_features upsert
   */
  export type vehicle_featuresUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_features to update in case it exists.
     */
    where: vehicle_featuresWhereUniqueInput
    /**
     * In case the vehicle_features found by the `where` argument doesn't exist, create a new vehicle_features with this data.
     */
    create: XOR<vehicle_featuresCreateInput, vehicle_featuresUncheckedCreateInput>
    /**
     * In case the vehicle_features was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_featuresUpdateInput, vehicle_featuresUncheckedUpdateInput>
  }

  /**
   * vehicle_features delete
   */
  export type vehicle_featuresDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
    /**
     * Filter which vehicle_features to delete.
     */
    where: vehicle_featuresWhereUniqueInput
  }

  /**
   * vehicle_features deleteMany
   */
  export type vehicle_featuresDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_features to delete
     */
    where?: vehicle_featuresWhereInput
    /**
     * Limit how many vehicle_features to delete.
     */
    limit?: number
  }

  /**
   * vehicle_features findRaw
   */
  export type vehicle_featuresFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_features aggregateRaw
   */
  export type vehicle_featuresAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_features without action
   */
  export type vehicle_featuresDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_features
     */
    select?: vehicle_featuresSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_features
     */
    omit?: vehicle_featuresOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_featuresInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_images
   */

  export type AggregateVehicle_images = {
    _count: Vehicle_imagesCountAggregateOutputType | null
    _min: Vehicle_imagesMinAggregateOutputType | null
    _max: Vehicle_imagesMaxAggregateOutputType | null
  }

  export type Vehicle_imagesMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    image_url: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_imagesMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    image_url: string | null
    description: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_imagesCountAggregateOutputType = {
    id: number
    vehicle_id: number
    image_url: number
    description: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_imagesMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    image_url?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_imagesMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    image_url?: true
    description?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_imagesCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    image_url?: true
    description?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_imagesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_images to aggregate.
     */
    where?: vehicle_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_images to fetch.
     */
    orderBy?: vehicle_imagesOrderByWithRelationInput | vehicle_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_images
    **/
    _count?: true | Vehicle_imagesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_imagesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_imagesMaxAggregateInputType
  }

  export type GetVehicle_imagesAggregateType<T extends Vehicle_imagesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_images]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_images[P]>
      : GetScalarType<T[P], AggregateVehicle_images[P]>
  }




  export type vehicle_imagesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_imagesWhereInput
    orderBy?: vehicle_imagesOrderByWithAggregationInput | vehicle_imagesOrderByWithAggregationInput[]
    by: Vehicle_imagesScalarFieldEnum[] | Vehicle_imagesScalarFieldEnum
    having?: vehicle_imagesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_imagesCountAggregateInputType | true
    _min?: Vehicle_imagesMinAggregateInputType
    _max?: Vehicle_imagesMaxAggregateInputType
  }

  export type Vehicle_imagesGroupByOutputType = {
    id: string
    vehicle_id: string
    image_url: string
    description: string
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_imagesCountAggregateOutputType | null
    _min: Vehicle_imagesMinAggregateOutputType | null
    _max: Vehicle_imagesMaxAggregateOutputType | null
  }

  type GetVehicle_imagesGroupByPayload<T extends vehicle_imagesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_imagesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_imagesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_imagesGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_imagesGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_imagesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    image_url?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_images"]>



  export type vehicle_imagesSelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    image_url?: boolean
    description?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_imagesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "image_url" | "description" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_images"]>
  export type vehicle_imagesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }

  export type $vehicle_imagesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_images"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string
      image_url: string
      description: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_images"]>
    composites: {}
  }

  type vehicle_imagesGetPayload<S extends boolean | null | undefined | vehicle_imagesDefaultArgs> = $Result.GetResult<Prisma.$vehicle_imagesPayload, S>

  type vehicle_imagesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_imagesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_imagesCountAggregateInputType | true
    }

  export interface vehicle_imagesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_images'], meta: { name: 'vehicle_images' } }
    /**
     * Find zero or one Vehicle_images that matches the filter.
     * @param {vehicle_imagesFindUniqueArgs} args - Arguments to find a Vehicle_images
     * @example
     * // Get one Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_imagesFindUniqueArgs>(args: SelectSubset<T, vehicle_imagesFindUniqueArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_images that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_imagesFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_images
     * @example
     * // Get one Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_imagesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_imagesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_imagesFindFirstArgs} args - Arguments to find a Vehicle_images
     * @example
     * // Get one Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_imagesFindFirstArgs>(args?: SelectSubset<T, vehicle_imagesFindFirstArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_images that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_imagesFindFirstOrThrowArgs} args - Arguments to find a Vehicle_images
     * @example
     * // Get one Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_imagesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_imagesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_images that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_imagesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.findMany()
     * 
     * // Get first 10 Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_imagesWithIdOnly = await prisma.vehicle_images.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_imagesFindManyArgs>(args?: SelectSubset<T, vehicle_imagesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_images.
     * @param {vehicle_imagesCreateArgs} args - Arguments to create a Vehicle_images.
     * @example
     * // Create one Vehicle_images
     * const Vehicle_images = await prisma.vehicle_images.create({
     *   data: {
     *     // ... data to create a Vehicle_images
     *   }
     * })
     * 
     */
    create<T extends vehicle_imagesCreateArgs>(args: SelectSubset<T, vehicle_imagesCreateArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_images.
     * @param {vehicle_imagesCreateManyArgs} args - Arguments to create many Vehicle_images.
     * @example
     * // Create many Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_imagesCreateManyArgs>(args?: SelectSubset<T, vehicle_imagesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_images.
     * @param {vehicle_imagesDeleteArgs} args - Arguments to delete one Vehicle_images.
     * @example
     * // Delete one Vehicle_images
     * const Vehicle_images = await prisma.vehicle_images.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_images
     *   }
     * })
     * 
     */
    delete<T extends vehicle_imagesDeleteArgs>(args: SelectSubset<T, vehicle_imagesDeleteArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_images.
     * @param {vehicle_imagesUpdateArgs} args - Arguments to update one Vehicle_images.
     * @example
     * // Update one Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_imagesUpdateArgs>(args: SelectSubset<T, vehicle_imagesUpdateArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_images.
     * @param {vehicle_imagesDeleteManyArgs} args - Arguments to filter Vehicle_images to delete.
     * @example
     * // Delete a few Vehicle_images
     * const { count } = await prisma.vehicle_images.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_imagesDeleteManyArgs>(args?: SelectSubset<T, vehicle_imagesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_imagesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_imagesUpdateManyArgs>(args: SelectSubset<T, vehicle_imagesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_images.
     * @param {vehicle_imagesUpsertArgs} args - Arguments to update or create a Vehicle_images.
     * @example
     * // Update or create a Vehicle_images
     * const vehicle_images = await prisma.vehicle_images.upsert({
     *   create: {
     *     // ... data to create a Vehicle_images
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_images we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_imagesUpsertArgs>(args: SelectSubset<T, vehicle_imagesUpsertArgs<ExtArgs>>): Prisma__vehicle_imagesClient<$Result.GetResult<Prisma.$vehicle_imagesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_images that matches the filter.
     * @param {vehicle_imagesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_images = await prisma.vehicle_images.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_imagesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_images.
     * @param {vehicle_imagesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_images = await prisma.vehicle_images.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_imagesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_imagesCountArgs} args - Arguments to filter Vehicle_images to count.
     * @example
     * // Count the number of Vehicle_images
     * const count = await prisma.vehicle_images.count({
     *   where: {
     *     // ... the filter for the Vehicle_images we want to count
     *   }
     * })
    **/
    count<T extends vehicle_imagesCountArgs>(
      args?: Subset<T, vehicle_imagesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_imagesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_imagesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_imagesAggregateArgs>(args: Subset<T, Vehicle_imagesAggregateArgs>): Prisma.PrismaPromise<GetVehicle_imagesAggregateType<T>>

    /**
     * Group by Vehicle_images.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_imagesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_imagesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_imagesGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_imagesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_imagesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_imagesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_images model
   */
  readonly fields: vehicle_imagesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_images.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_imagesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_images model
   */
  interface vehicle_imagesFieldRefs {
    readonly id: FieldRef<"vehicle_images", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_images", 'String'>
    readonly image_url: FieldRef<"vehicle_images", 'String'>
    readonly description: FieldRef<"vehicle_images", 'String'>
    readonly createdAt: FieldRef<"vehicle_images", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_images", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_images findUnique
   */
  export type vehicle_imagesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_images to fetch.
     */
    where: vehicle_imagesWhereUniqueInput
  }

  /**
   * vehicle_images findUniqueOrThrow
   */
  export type vehicle_imagesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_images to fetch.
     */
    where: vehicle_imagesWhereUniqueInput
  }

  /**
   * vehicle_images findFirst
   */
  export type vehicle_imagesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_images to fetch.
     */
    where?: vehicle_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_images to fetch.
     */
    orderBy?: vehicle_imagesOrderByWithRelationInput | vehicle_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_images.
     */
    cursor?: vehicle_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_images.
     */
    distinct?: Vehicle_imagesScalarFieldEnum | Vehicle_imagesScalarFieldEnum[]
  }

  /**
   * vehicle_images findFirstOrThrow
   */
  export type vehicle_imagesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_images to fetch.
     */
    where?: vehicle_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_images to fetch.
     */
    orderBy?: vehicle_imagesOrderByWithRelationInput | vehicle_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_images.
     */
    cursor?: vehicle_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_images.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_images.
     */
    distinct?: Vehicle_imagesScalarFieldEnum | Vehicle_imagesScalarFieldEnum[]
  }

  /**
   * vehicle_images findMany
   */
  export type vehicle_imagesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_images to fetch.
     */
    where?: vehicle_imagesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_images to fetch.
     */
    orderBy?: vehicle_imagesOrderByWithRelationInput | vehicle_imagesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_images.
     */
    cursor?: vehicle_imagesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_images from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_images.
     */
    skip?: number
    distinct?: Vehicle_imagesScalarFieldEnum | Vehicle_imagesScalarFieldEnum[]
  }

  /**
   * vehicle_images create
   */
  export type vehicle_imagesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_images.
     */
    data: XOR<vehicle_imagesCreateInput, vehicle_imagesUncheckedCreateInput>
  }

  /**
   * vehicle_images createMany
   */
  export type vehicle_imagesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_images.
     */
    data: vehicle_imagesCreateManyInput | vehicle_imagesCreateManyInput[]
  }

  /**
   * vehicle_images update
   */
  export type vehicle_imagesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_images.
     */
    data: XOR<vehicle_imagesUpdateInput, vehicle_imagesUncheckedUpdateInput>
    /**
     * Choose, which vehicle_images to update.
     */
    where: vehicle_imagesWhereUniqueInput
  }

  /**
   * vehicle_images updateMany
   */
  export type vehicle_imagesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_images.
     */
    data: XOR<vehicle_imagesUpdateManyMutationInput, vehicle_imagesUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_images to update
     */
    where?: vehicle_imagesWhereInput
    /**
     * Limit how many vehicle_images to update.
     */
    limit?: number
  }

  /**
   * vehicle_images upsert
   */
  export type vehicle_imagesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_images to update in case it exists.
     */
    where: vehicle_imagesWhereUniqueInput
    /**
     * In case the vehicle_images found by the `where` argument doesn't exist, create a new vehicle_images with this data.
     */
    create: XOR<vehicle_imagesCreateInput, vehicle_imagesUncheckedCreateInput>
    /**
     * In case the vehicle_images was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_imagesUpdateInput, vehicle_imagesUncheckedUpdateInput>
  }

  /**
   * vehicle_images delete
   */
  export type vehicle_imagesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
    /**
     * Filter which vehicle_images to delete.
     */
    where: vehicle_imagesWhereUniqueInput
  }

  /**
   * vehicle_images deleteMany
   */
  export type vehicle_imagesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_images to delete
     */
    where?: vehicle_imagesWhereInput
    /**
     * Limit how many vehicle_images to delete.
     */
    limit?: number
  }

  /**
   * vehicle_images findRaw
   */
  export type vehicle_imagesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_images aggregateRaw
   */
  export type vehicle_imagesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_images without action
   */
  export type vehicle_imagesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_images
     */
    select?: vehicle_imagesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_images
     */
    omit?: vehicle_imagesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_imagesInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_availability
   */

  export type AggregateVehicle_availability = {
    _count: Vehicle_availabilityCountAggregateOutputType | null
    _min: Vehicle_availabilityMinAggregateOutputType | null
    _max: Vehicle_availabilityMaxAggregateOutputType | null
  }

  export type Vehicle_availabilityMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    start_time: Date | null
    end_time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_availabilityMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    start_time: Date | null
    end_time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_availabilityCountAggregateOutputType = {
    id: number
    vehicle_id: number
    start_time: number
    end_time: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_availabilityMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    start_time?: true
    end_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_availabilityMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    start_time?: true
    end_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_availabilityCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    start_time?: true
    end_time?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_availabilityAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_availability to aggregate.
     */
    where?: vehicle_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availabilities to fetch.
     */
    orderBy?: vehicle_availabilityOrderByWithRelationInput | vehicle_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_availabilities
    **/
    _count?: true | Vehicle_availabilityCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_availabilityMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_availabilityMaxAggregateInputType
  }

  export type GetVehicle_availabilityAggregateType<T extends Vehicle_availabilityAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_availability]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_availability[P]>
      : GetScalarType<T[P], AggregateVehicle_availability[P]>
  }




  export type vehicle_availabilityGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_availabilityWhereInput
    orderBy?: vehicle_availabilityOrderByWithAggregationInput | vehicle_availabilityOrderByWithAggregationInput[]
    by: Vehicle_availabilityScalarFieldEnum[] | Vehicle_availabilityScalarFieldEnum
    having?: vehicle_availabilityScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_availabilityCountAggregateInputType | true
    _min?: Vehicle_availabilityMinAggregateInputType
    _max?: Vehicle_availabilityMaxAggregateInputType
  }

  export type Vehicle_availabilityGroupByOutputType = {
    id: string
    vehicle_id: string
    start_time: Date
    end_time: Date
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_availabilityCountAggregateOutputType | null
    _min: Vehicle_availabilityMinAggregateOutputType | null
    _max: Vehicle_availabilityMaxAggregateOutputType | null
  }

  type GetVehicle_availabilityGroupByPayload<T extends vehicle_availabilityGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_availabilityGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_availabilityGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_availabilityGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_availabilityGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_availabilitySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    start_time?: boolean
    end_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_availability"]>



  export type vehicle_availabilitySelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    start_time?: boolean
    end_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_availabilityOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "start_time" | "end_time" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_availability"]>
  export type vehicle_availabilityInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }

  export type $vehicle_availabilityPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_availability"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string
      start_time: Date
      end_time: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_availability"]>
    composites: {}
  }

  type vehicle_availabilityGetPayload<S extends boolean | null | undefined | vehicle_availabilityDefaultArgs> = $Result.GetResult<Prisma.$vehicle_availabilityPayload, S>

  type vehicle_availabilityCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_availabilityFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_availabilityCountAggregateInputType | true
    }

  export interface vehicle_availabilityDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_availability'], meta: { name: 'vehicle_availability' } }
    /**
     * Find zero or one Vehicle_availability that matches the filter.
     * @param {vehicle_availabilityFindUniqueArgs} args - Arguments to find a Vehicle_availability
     * @example
     * // Get one Vehicle_availability
     * const vehicle_availability = await prisma.vehicle_availability.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_availabilityFindUniqueArgs>(args: SelectSubset<T, vehicle_availabilityFindUniqueArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_availability that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_availabilityFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_availability
     * @example
     * // Get one Vehicle_availability
     * const vehicle_availability = await prisma.vehicle_availability.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_availabilityFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_availabilityFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_availability that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availabilityFindFirstArgs} args - Arguments to find a Vehicle_availability
     * @example
     * // Get one Vehicle_availability
     * const vehicle_availability = await prisma.vehicle_availability.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_availabilityFindFirstArgs>(args?: SelectSubset<T, vehicle_availabilityFindFirstArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_availability that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availabilityFindFirstOrThrowArgs} args - Arguments to find a Vehicle_availability
     * @example
     * // Get one Vehicle_availability
     * const vehicle_availability = await prisma.vehicle_availability.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_availabilityFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_availabilityFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_availabilities that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availabilityFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_availabilities
     * const vehicle_availabilities = await prisma.vehicle_availability.findMany()
     * 
     * // Get first 10 Vehicle_availabilities
     * const vehicle_availabilities = await prisma.vehicle_availability.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_availabilityWithIdOnly = await prisma.vehicle_availability.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_availabilityFindManyArgs>(args?: SelectSubset<T, vehicle_availabilityFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_availability.
     * @param {vehicle_availabilityCreateArgs} args - Arguments to create a Vehicle_availability.
     * @example
     * // Create one Vehicle_availability
     * const Vehicle_availability = await prisma.vehicle_availability.create({
     *   data: {
     *     // ... data to create a Vehicle_availability
     *   }
     * })
     * 
     */
    create<T extends vehicle_availabilityCreateArgs>(args: SelectSubset<T, vehicle_availabilityCreateArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_availabilities.
     * @param {vehicle_availabilityCreateManyArgs} args - Arguments to create many Vehicle_availabilities.
     * @example
     * // Create many Vehicle_availabilities
     * const vehicle_availability = await prisma.vehicle_availability.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_availabilityCreateManyArgs>(args?: SelectSubset<T, vehicle_availabilityCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_availability.
     * @param {vehicle_availabilityDeleteArgs} args - Arguments to delete one Vehicle_availability.
     * @example
     * // Delete one Vehicle_availability
     * const Vehicle_availability = await prisma.vehicle_availability.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_availability
     *   }
     * })
     * 
     */
    delete<T extends vehicle_availabilityDeleteArgs>(args: SelectSubset<T, vehicle_availabilityDeleteArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_availability.
     * @param {vehicle_availabilityUpdateArgs} args - Arguments to update one Vehicle_availability.
     * @example
     * // Update one Vehicle_availability
     * const vehicle_availability = await prisma.vehicle_availability.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_availabilityUpdateArgs>(args: SelectSubset<T, vehicle_availabilityUpdateArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_availabilities.
     * @param {vehicle_availabilityDeleteManyArgs} args - Arguments to filter Vehicle_availabilities to delete.
     * @example
     * // Delete a few Vehicle_availabilities
     * const { count } = await prisma.vehicle_availability.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_availabilityDeleteManyArgs>(args?: SelectSubset<T, vehicle_availabilityDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availabilityUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_availabilities
     * const vehicle_availability = await prisma.vehicle_availability.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_availabilityUpdateManyArgs>(args: SelectSubset<T, vehicle_availabilityUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_availability.
     * @param {vehicle_availabilityUpsertArgs} args - Arguments to update or create a Vehicle_availability.
     * @example
     * // Update or create a Vehicle_availability
     * const vehicle_availability = await prisma.vehicle_availability.upsert({
     *   create: {
     *     // ... data to create a Vehicle_availability
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_availability we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_availabilityUpsertArgs>(args: SelectSubset<T, vehicle_availabilityUpsertArgs<ExtArgs>>): Prisma__vehicle_availabilityClient<$Result.GetResult<Prisma.$vehicle_availabilityPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_availabilities that matches the filter.
     * @param {vehicle_availabilityFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_availability = await prisma.vehicle_availability.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_availabilityFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_availability.
     * @param {vehicle_availabilityAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_availability = await prisma.vehicle_availability.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_availabilityAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_availabilities.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availabilityCountArgs} args - Arguments to filter Vehicle_availabilities to count.
     * @example
     * // Count the number of Vehicle_availabilities
     * const count = await prisma.vehicle_availability.count({
     *   where: {
     *     // ... the filter for the Vehicle_availabilities we want to count
     *   }
     * })
    **/
    count<T extends vehicle_availabilityCountArgs>(
      args?: Subset<T, vehicle_availabilityCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_availabilityCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_availabilityAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_availabilityAggregateArgs>(args: Subset<T, Vehicle_availabilityAggregateArgs>): Prisma.PrismaPromise<GetVehicle_availabilityAggregateType<T>>

    /**
     * Group by Vehicle_availability.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availabilityGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_availabilityGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_availabilityGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_availabilityGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_availabilityGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_availabilityGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_availability model
   */
  readonly fields: vehicle_availabilityFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_availability.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_availabilityClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_availability model
   */
  interface vehicle_availabilityFieldRefs {
    readonly id: FieldRef<"vehicle_availability", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_availability", 'String'>
    readonly start_time: FieldRef<"vehicle_availability", 'DateTime'>
    readonly end_time: FieldRef<"vehicle_availability", 'DateTime'>
    readonly createdAt: FieldRef<"vehicle_availability", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_availability", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_availability findUnique
   */
  export type vehicle_availabilityFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability to fetch.
     */
    where: vehicle_availabilityWhereUniqueInput
  }

  /**
   * vehicle_availability findUniqueOrThrow
   */
  export type vehicle_availabilityFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability to fetch.
     */
    where: vehicle_availabilityWhereUniqueInput
  }

  /**
   * vehicle_availability findFirst
   */
  export type vehicle_availabilityFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability to fetch.
     */
    where?: vehicle_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availabilities to fetch.
     */
    orderBy?: vehicle_availabilityOrderByWithRelationInput | vehicle_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_availabilities.
     */
    cursor?: vehicle_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_availabilities.
     */
    distinct?: Vehicle_availabilityScalarFieldEnum | Vehicle_availabilityScalarFieldEnum[]
  }

  /**
   * vehicle_availability findFirstOrThrow
   */
  export type vehicle_availabilityFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability to fetch.
     */
    where?: vehicle_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availabilities to fetch.
     */
    orderBy?: vehicle_availabilityOrderByWithRelationInput | vehicle_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_availabilities.
     */
    cursor?: vehicle_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availabilities.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_availabilities.
     */
    distinct?: Vehicle_availabilityScalarFieldEnum | Vehicle_availabilityScalarFieldEnum[]
  }

  /**
   * vehicle_availability findMany
   */
  export type vehicle_availabilityFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availabilities to fetch.
     */
    where?: vehicle_availabilityWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availabilities to fetch.
     */
    orderBy?: vehicle_availabilityOrderByWithRelationInput | vehicle_availabilityOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_availabilities.
     */
    cursor?: vehicle_availabilityWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availabilities from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availabilities.
     */
    skip?: number
    distinct?: Vehicle_availabilityScalarFieldEnum | Vehicle_availabilityScalarFieldEnum[]
  }

  /**
   * vehicle_availability create
   */
  export type vehicle_availabilityCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_availability.
     */
    data: XOR<vehicle_availabilityCreateInput, vehicle_availabilityUncheckedCreateInput>
  }

  /**
   * vehicle_availability createMany
   */
  export type vehicle_availabilityCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_availabilities.
     */
    data: vehicle_availabilityCreateManyInput | vehicle_availabilityCreateManyInput[]
  }

  /**
   * vehicle_availability update
   */
  export type vehicle_availabilityUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_availability.
     */
    data: XOR<vehicle_availabilityUpdateInput, vehicle_availabilityUncheckedUpdateInput>
    /**
     * Choose, which vehicle_availability to update.
     */
    where: vehicle_availabilityWhereUniqueInput
  }

  /**
   * vehicle_availability updateMany
   */
  export type vehicle_availabilityUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_availabilities.
     */
    data: XOR<vehicle_availabilityUpdateManyMutationInput, vehicle_availabilityUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_availabilities to update
     */
    where?: vehicle_availabilityWhereInput
    /**
     * Limit how many vehicle_availabilities to update.
     */
    limit?: number
  }

  /**
   * vehicle_availability upsert
   */
  export type vehicle_availabilityUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_availability to update in case it exists.
     */
    where: vehicle_availabilityWhereUniqueInput
    /**
     * In case the vehicle_availability found by the `where` argument doesn't exist, create a new vehicle_availability with this data.
     */
    create: XOR<vehicle_availabilityCreateInput, vehicle_availabilityUncheckedCreateInput>
    /**
     * In case the vehicle_availability was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_availabilityUpdateInput, vehicle_availabilityUncheckedUpdateInput>
  }

  /**
   * vehicle_availability delete
   */
  export type vehicle_availabilityDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
    /**
     * Filter which vehicle_availability to delete.
     */
    where: vehicle_availabilityWhereUniqueInput
  }

  /**
   * vehicle_availability deleteMany
   */
  export type vehicle_availabilityDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_availabilities to delete
     */
    where?: vehicle_availabilityWhereInput
    /**
     * Limit how many vehicle_availabilities to delete.
     */
    limit?: number
  }

  /**
   * vehicle_availability findRaw
   */
  export type vehicle_availabilityFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_availability aggregateRaw
   */
  export type vehicle_availabilityAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_availability without action
   */
  export type vehicle_availabilityDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability
     */
    select?: vehicle_availabilitySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability
     */
    omit?: vehicle_availabilityOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availabilityInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_availability_history
   */

  export type AggregateVehicle_availability_history = {
    _count: Vehicle_availability_historyCountAggregateOutputType | null
    _min: Vehicle_availability_historyMinAggregateOutputType | null
    _max: Vehicle_availability_historyMaxAggregateOutputType | null
  }

  export type Vehicle_availability_historyMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    start_time: Date | null
    end_time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_availability_historyMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    start_time: Date | null
    end_time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_availability_historyCountAggregateOutputType = {
    id: number
    vehicle_id: number
    start_time: number
    end_time: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_availability_historyMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    start_time?: true
    end_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_availability_historyMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    start_time?: true
    end_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_availability_historyCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    start_time?: true
    end_time?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_availability_historyAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_availability_history to aggregate.
     */
    where?: vehicle_availability_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availability_histories to fetch.
     */
    orderBy?: vehicle_availability_historyOrderByWithRelationInput | vehicle_availability_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_availability_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availability_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availability_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_availability_histories
    **/
    _count?: true | Vehicle_availability_historyCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_availability_historyMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_availability_historyMaxAggregateInputType
  }

  export type GetVehicle_availability_historyAggregateType<T extends Vehicle_availability_historyAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_availability_history]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_availability_history[P]>
      : GetScalarType<T[P], AggregateVehicle_availability_history[P]>
  }




  export type vehicle_availability_historyGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_availability_historyWhereInput
    orderBy?: vehicle_availability_historyOrderByWithAggregationInput | vehicle_availability_historyOrderByWithAggregationInput[]
    by: Vehicle_availability_historyScalarFieldEnum[] | Vehicle_availability_historyScalarFieldEnum
    having?: vehicle_availability_historyScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_availability_historyCountAggregateInputType | true
    _min?: Vehicle_availability_historyMinAggregateInputType
    _max?: Vehicle_availability_historyMaxAggregateInputType
  }

  export type Vehicle_availability_historyGroupByOutputType = {
    id: string
    vehicle_id: string
    start_time: Date
    end_time: Date
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_availability_historyCountAggregateOutputType | null
    _min: Vehicle_availability_historyMinAggregateOutputType | null
    _max: Vehicle_availability_historyMaxAggregateOutputType | null
  }

  type GetVehicle_availability_historyGroupByPayload<T extends vehicle_availability_historyGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_availability_historyGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_availability_historyGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_availability_historyGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_availability_historyGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_availability_historySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    start_time?: boolean
    end_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_availability_history"]>



  export type vehicle_availability_historySelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    start_time?: boolean
    end_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_availability_historyOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "start_time" | "end_time" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_availability_history"]>
  export type vehicle_availability_historyInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
  }

  export type $vehicle_availability_historyPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_availability_history"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string
      start_time: Date
      end_time: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_availability_history"]>
    composites: {}
  }

  type vehicle_availability_historyGetPayload<S extends boolean | null | undefined | vehicle_availability_historyDefaultArgs> = $Result.GetResult<Prisma.$vehicle_availability_historyPayload, S>

  type vehicle_availability_historyCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_availability_historyFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_availability_historyCountAggregateInputType | true
    }

  export interface vehicle_availability_historyDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_availability_history'], meta: { name: 'vehicle_availability_history' } }
    /**
     * Find zero or one Vehicle_availability_history that matches the filter.
     * @param {vehicle_availability_historyFindUniqueArgs} args - Arguments to find a Vehicle_availability_history
     * @example
     * // Get one Vehicle_availability_history
     * const vehicle_availability_history = await prisma.vehicle_availability_history.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_availability_historyFindUniqueArgs>(args: SelectSubset<T, vehicle_availability_historyFindUniqueArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_availability_history that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_availability_historyFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_availability_history
     * @example
     * // Get one Vehicle_availability_history
     * const vehicle_availability_history = await prisma.vehicle_availability_history.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_availability_historyFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_availability_historyFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_availability_history that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availability_historyFindFirstArgs} args - Arguments to find a Vehicle_availability_history
     * @example
     * // Get one Vehicle_availability_history
     * const vehicle_availability_history = await prisma.vehicle_availability_history.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_availability_historyFindFirstArgs>(args?: SelectSubset<T, vehicle_availability_historyFindFirstArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_availability_history that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availability_historyFindFirstOrThrowArgs} args - Arguments to find a Vehicle_availability_history
     * @example
     * // Get one Vehicle_availability_history
     * const vehicle_availability_history = await prisma.vehicle_availability_history.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_availability_historyFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_availability_historyFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_availability_histories that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availability_historyFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_availability_histories
     * const vehicle_availability_histories = await prisma.vehicle_availability_history.findMany()
     * 
     * // Get first 10 Vehicle_availability_histories
     * const vehicle_availability_histories = await prisma.vehicle_availability_history.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_availability_historyWithIdOnly = await prisma.vehicle_availability_history.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_availability_historyFindManyArgs>(args?: SelectSubset<T, vehicle_availability_historyFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_availability_history.
     * @param {vehicle_availability_historyCreateArgs} args - Arguments to create a Vehicle_availability_history.
     * @example
     * // Create one Vehicle_availability_history
     * const Vehicle_availability_history = await prisma.vehicle_availability_history.create({
     *   data: {
     *     // ... data to create a Vehicle_availability_history
     *   }
     * })
     * 
     */
    create<T extends vehicle_availability_historyCreateArgs>(args: SelectSubset<T, vehicle_availability_historyCreateArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_availability_histories.
     * @param {vehicle_availability_historyCreateManyArgs} args - Arguments to create many Vehicle_availability_histories.
     * @example
     * // Create many Vehicle_availability_histories
     * const vehicle_availability_history = await prisma.vehicle_availability_history.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_availability_historyCreateManyArgs>(args?: SelectSubset<T, vehicle_availability_historyCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_availability_history.
     * @param {vehicle_availability_historyDeleteArgs} args - Arguments to delete one Vehicle_availability_history.
     * @example
     * // Delete one Vehicle_availability_history
     * const Vehicle_availability_history = await prisma.vehicle_availability_history.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_availability_history
     *   }
     * })
     * 
     */
    delete<T extends vehicle_availability_historyDeleteArgs>(args: SelectSubset<T, vehicle_availability_historyDeleteArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_availability_history.
     * @param {vehicle_availability_historyUpdateArgs} args - Arguments to update one Vehicle_availability_history.
     * @example
     * // Update one Vehicle_availability_history
     * const vehicle_availability_history = await prisma.vehicle_availability_history.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_availability_historyUpdateArgs>(args: SelectSubset<T, vehicle_availability_historyUpdateArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_availability_histories.
     * @param {vehicle_availability_historyDeleteManyArgs} args - Arguments to filter Vehicle_availability_histories to delete.
     * @example
     * // Delete a few Vehicle_availability_histories
     * const { count } = await prisma.vehicle_availability_history.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_availability_historyDeleteManyArgs>(args?: SelectSubset<T, vehicle_availability_historyDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_availability_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availability_historyUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_availability_histories
     * const vehicle_availability_history = await prisma.vehicle_availability_history.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_availability_historyUpdateManyArgs>(args: SelectSubset<T, vehicle_availability_historyUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_availability_history.
     * @param {vehicle_availability_historyUpsertArgs} args - Arguments to update or create a Vehicle_availability_history.
     * @example
     * // Update or create a Vehicle_availability_history
     * const vehicle_availability_history = await prisma.vehicle_availability_history.upsert({
     *   create: {
     *     // ... data to create a Vehicle_availability_history
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_availability_history we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_availability_historyUpsertArgs>(args: SelectSubset<T, vehicle_availability_historyUpsertArgs<ExtArgs>>): Prisma__vehicle_availability_historyClient<$Result.GetResult<Prisma.$vehicle_availability_historyPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_availability_histories that matches the filter.
     * @param {vehicle_availability_historyFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_availability_history = await prisma.vehicle_availability_history.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_availability_historyFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_availability_history.
     * @param {vehicle_availability_historyAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_availability_history = await prisma.vehicle_availability_history.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_availability_historyAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_availability_histories.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availability_historyCountArgs} args - Arguments to filter Vehicle_availability_histories to count.
     * @example
     * // Count the number of Vehicle_availability_histories
     * const count = await prisma.vehicle_availability_history.count({
     *   where: {
     *     // ... the filter for the Vehicle_availability_histories we want to count
     *   }
     * })
    **/
    count<T extends vehicle_availability_historyCountArgs>(
      args?: Subset<T, vehicle_availability_historyCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_availability_historyCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_availability_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_availability_historyAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_availability_historyAggregateArgs>(args: Subset<T, Vehicle_availability_historyAggregateArgs>): Prisma.PrismaPromise<GetVehicle_availability_historyAggregateType<T>>

    /**
     * Group by Vehicle_availability_history.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_availability_historyGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_availability_historyGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_availability_historyGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_availability_historyGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_availability_historyGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_availability_historyGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_availability_history model
   */
  readonly fields: vehicle_availability_historyFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_availability_history.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_availability_historyClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_availability_history model
   */
  interface vehicle_availability_historyFieldRefs {
    readonly id: FieldRef<"vehicle_availability_history", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_availability_history", 'String'>
    readonly start_time: FieldRef<"vehicle_availability_history", 'DateTime'>
    readonly end_time: FieldRef<"vehicle_availability_history", 'DateTime'>
    readonly createdAt: FieldRef<"vehicle_availability_history", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_availability_history", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_availability_history findUnique
   */
  export type vehicle_availability_historyFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability_history to fetch.
     */
    where: vehicle_availability_historyWhereUniqueInput
  }

  /**
   * vehicle_availability_history findUniqueOrThrow
   */
  export type vehicle_availability_historyFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability_history to fetch.
     */
    where: vehicle_availability_historyWhereUniqueInput
  }

  /**
   * vehicle_availability_history findFirst
   */
  export type vehicle_availability_historyFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability_history to fetch.
     */
    where?: vehicle_availability_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availability_histories to fetch.
     */
    orderBy?: vehicle_availability_historyOrderByWithRelationInput | vehicle_availability_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_availability_histories.
     */
    cursor?: vehicle_availability_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availability_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availability_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_availability_histories.
     */
    distinct?: Vehicle_availability_historyScalarFieldEnum | Vehicle_availability_historyScalarFieldEnum[]
  }

  /**
   * vehicle_availability_history findFirstOrThrow
   */
  export type vehicle_availability_historyFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability_history to fetch.
     */
    where?: vehicle_availability_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availability_histories to fetch.
     */
    orderBy?: vehicle_availability_historyOrderByWithRelationInput | vehicle_availability_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_availability_histories.
     */
    cursor?: vehicle_availability_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availability_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availability_histories.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_availability_histories.
     */
    distinct?: Vehicle_availability_historyScalarFieldEnum | Vehicle_availability_historyScalarFieldEnum[]
  }

  /**
   * vehicle_availability_history findMany
   */
  export type vehicle_availability_historyFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_availability_histories to fetch.
     */
    where?: vehicle_availability_historyWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_availability_histories to fetch.
     */
    orderBy?: vehicle_availability_historyOrderByWithRelationInput | vehicle_availability_historyOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_availability_histories.
     */
    cursor?: vehicle_availability_historyWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_availability_histories from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_availability_histories.
     */
    skip?: number
    distinct?: Vehicle_availability_historyScalarFieldEnum | Vehicle_availability_historyScalarFieldEnum[]
  }

  /**
   * vehicle_availability_history create
   */
  export type vehicle_availability_historyCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_availability_history.
     */
    data: XOR<vehicle_availability_historyCreateInput, vehicle_availability_historyUncheckedCreateInput>
  }

  /**
   * vehicle_availability_history createMany
   */
  export type vehicle_availability_historyCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_availability_histories.
     */
    data: vehicle_availability_historyCreateManyInput | vehicle_availability_historyCreateManyInput[]
  }

  /**
   * vehicle_availability_history update
   */
  export type vehicle_availability_historyUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_availability_history.
     */
    data: XOR<vehicle_availability_historyUpdateInput, vehicle_availability_historyUncheckedUpdateInput>
    /**
     * Choose, which vehicle_availability_history to update.
     */
    where: vehicle_availability_historyWhereUniqueInput
  }

  /**
   * vehicle_availability_history updateMany
   */
  export type vehicle_availability_historyUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_availability_histories.
     */
    data: XOR<vehicle_availability_historyUpdateManyMutationInput, vehicle_availability_historyUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_availability_histories to update
     */
    where?: vehicle_availability_historyWhereInput
    /**
     * Limit how many vehicle_availability_histories to update.
     */
    limit?: number
  }

  /**
   * vehicle_availability_history upsert
   */
  export type vehicle_availability_historyUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_availability_history to update in case it exists.
     */
    where: vehicle_availability_historyWhereUniqueInput
    /**
     * In case the vehicle_availability_history found by the `where` argument doesn't exist, create a new vehicle_availability_history with this data.
     */
    create: XOR<vehicle_availability_historyCreateInput, vehicle_availability_historyUncheckedCreateInput>
    /**
     * In case the vehicle_availability_history was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_availability_historyUpdateInput, vehicle_availability_historyUncheckedUpdateInput>
  }

  /**
   * vehicle_availability_history delete
   */
  export type vehicle_availability_historyDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
    /**
     * Filter which vehicle_availability_history to delete.
     */
    where: vehicle_availability_historyWhereUniqueInput
  }

  /**
   * vehicle_availability_history deleteMany
   */
  export type vehicle_availability_historyDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_availability_histories to delete
     */
    where?: vehicle_availability_historyWhereInput
    /**
     * Limit how many vehicle_availability_histories to delete.
     */
    limit?: number
  }

  /**
   * vehicle_availability_history findRaw
   */
  export type vehicle_availability_historyFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_availability_history aggregateRaw
   */
  export type vehicle_availability_historyAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_availability_history without action
   */
  export type vehicle_availability_historyDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_availability_history
     */
    select?: vehicle_availability_historySelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_availability_history
     */
    omit?: vehicle_availability_historyOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_availability_historyInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_inspection
   */

  export type AggregateVehicle_inspection = {
    _count: Vehicle_inspectionCountAggregateOutputType | null
    _min: Vehicle_inspectionMinAggregateOutputType | null
    _max: Vehicle_inspectionMaxAggregateOutputType | null
  }

  export type Vehicle_inspectionMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    inspection_date: Date | null
    inspector_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicle_bookingsId: string | null
  }

  export type Vehicle_inspectionMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    inspection_date: Date | null
    inspector_name: string | null
    createdAt: Date | null
    updatedAt: Date | null
    vehicle_bookingsId: string | null
  }

  export type Vehicle_inspectionCountAggregateOutputType = {
    id: number
    vehicle_id: number
    inspection_date: number
    inspector_name: number
    createdAt: number
    updatedAt: number
    vehicle_bookingsId: number
    _all: number
  }


  export type Vehicle_inspectionMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    inspection_date?: true
    inspector_name?: true
    createdAt?: true
    updatedAt?: true
    vehicle_bookingsId?: true
  }

  export type Vehicle_inspectionMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    inspection_date?: true
    inspector_name?: true
    createdAt?: true
    updatedAt?: true
    vehicle_bookingsId?: true
  }

  export type Vehicle_inspectionCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    inspection_date?: true
    inspector_name?: true
    createdAt?: true
    updatedAt?: true
    vehicle_bookingsId?: true
    _all?: true
  }

  export type Vehicle_inspectionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_inspection to aggregate.
     */
    where?: vehicle_inspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspections to fetch.
     */
    orderBy?: vehicle_inspectionOrderByWithRelationInput | vehicle_inspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_inspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_inspections
    **/
    _count?: true | Vehicle_inspectionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_inspectionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_inspectionMaxAggregateInputType
  }

  export type GetVehicle_inspectionAggregateType<T extends Vehicle_inspectionAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_inspection]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_inspection[P]>
      : GetScalarType<T[P], AggregateVehicle_inspection[P]>
  }




  export type vehicle_inspectionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_inspectionWhereInput
    orderBy?: vehicle_inspectionOrderByWithAggregationInput | vehicle_inspectionOrderByWithAggregationInput[]
    by: Vehicle_inspectionScalarFieldEnum[] | Vehicle_inspectionScalarFieldEnum
    having?: vehicle_inspectionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_inspectionCountAggregateInputType | true
    _min?: Vehicle_inspectionMinAggregateInputType
    _max?: Vehicle_inspectionMaxAggregateInputType
  }

  export type Vehicle_inspectionGroupByOutputType = {
    id: string
    vehicle_id: string
    inspection_date: Date
    inspector_name: string
    createdAt: Date
    updatedAt: Date
    vehicle_bookingsId: string | null
    _count: Vehicle_inspectionCountAggregateOutputType | null
    _min: Vehicle_inspectionMinAggregateOutputType | null
    _max: Vehicle_inspectionMaxAggregateOutputType | null
  }

  type GetVehicle_inspectionGroupByPayload<T extends vehicle_inspectionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_inspectionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_inspectionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_inspectionGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_inspectionGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_inspectionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    inspection_date?: boolean
    inspector_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_bookingsId?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
    details?: boolean | vehicle_inspection$detailsArgs<ExtArgs>
    vehicle_bookings?: boolean | vehicle_inspection$vehicle_bookingsArgs<ExtArgs>
    _count?: boolean | Vehicle_inspectionCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_inspection"]>



  export type vehicle_inspectionSelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    inspection_date?: boolean
    inspector_name?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_bookingsId?: boolean
  }

  export type vehicle_inspectionOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "inspection_date" | "inspector_name" | "createdAt" | "updatedAt" | "vehicle_bookingsId", ExtArgs["result"]["vehicle_inspection"]>
  export type vehicle_inspectionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
    details?: boolean | vehicle_inspection$detailsArgs<ExtArgs>
    vehicle_bookings?: boolean | vehicle_inspection$vehicle_bookingsArgs<ExtArgs>
    _count?: boolean | Vehicle_inspectionCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $vehicle_inspectionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_inspection"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
      details: Prisma.$vehicle_inspection_detailsPayload<ExtArgs>[]
      vehicle_bookings: Prisma.$vehicle_bookingsPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string
      inspection_date: Date
      inspector_name: string
      createdAt: Date
      updatedAt: Date
      vehicle_bookingsId: string | null
    }, ExtArgs["result"]["vehicle_inspection"]>
    composites: {}
  }

  type vehicle_inspectionGetPayload<S extends boolean | null | undefined | vehicle_inspectionDefaultArgs> = $Result.GetResult<Prisma.$vehicle_inspectionPayload, S>

  type vehicle_inspectionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_inspectionFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_inspectionCountAggregateInputType | true
    }

  export interface vehicle_inspectionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_inspection'], meta: { name: 'vehicle_inspection' } }
    /**
     * Find zero or one Vehicle_inspection that matches the filter.
     * @param {vehicle_inspectionFindUniqueArgs} args - Arguments to find a Vehicle_inspection
     * @example
     * // Get one Vehicle_inspection
     * const vehicle_inspection = await prisma.vehicle_inspection.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_inspectionFindUniqueArgs>(args: SelectSubset<T, vehicle_inspectionFindUniqueArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_inspection that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_inspectionFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_inspection
     * @example
     * // Get one Vehicle_inspection
     * const vehicle_inspection = await prisma.vehicle_inspection.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_inspectionFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_inspectionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_inspection that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspectionFindFirstArgs} args - Arguments to find a Vehicle_inspection
     * @example
     * // Get one Vehicle_inspection
     * const vehicle_inspection = await prisma.vehicle_inspection.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_inspectionFindFirstArgs>(args?: SelectSubset<T, vehicle_inspectionFindFirstArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_inspection that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspectionFindFirstOrThrowArgs} args - Arguments to find a Vehicle_inspection
     * @example
     * // Get one Vehicle_inspection
     * const vehicle_inspection = await prisma.vehicle_inspection.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_inspectionFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_inspectionFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_inspections that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspectionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_inspections
     * const vehicle_inspections = await prisma.vehicle_inspection.findMany()
     * 
     * // Get first 10 Vehicle_inspections
     * const vehicle_inspections = await prisma.vehicle_inspection.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_inspectionWithIdOnly = await prisma.vehicle_inspection.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_inspectionFindManyArgs>(args?: SelectSubset<T, vehicle_inspectionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_inspection.
     * @param {vehicle_inspectionCreateArgs} args - Arguments to create a Vehicle_inspection.
     * @example
     * // Create one Vehicle_inspection
     * const Vehicle_inspection = await prisma.vehicle_inspection.create({
     *   data: {
     *     // ... data to create a Vehicle_inspection
     *   }
     * })
     * 
     */
    create<T extends vehicle_inspectionCreateArgs>(args: SelectSubset<T, vehicle_inspectionCreateArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_inspections.
     * @param {vehicle_inspectionCreateManyArgs} args - Arguments to create many Vehicle_inspections.
     * @example
     * // Create many Vehicle_inspections
     * const vehicle_inspection = await prisma.vehicle_inspection.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_inspectionCreateManyArgs>(args?: SelectSubset<T, vehicle_inspectionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_inspection.
     * @param {vehicle_inspectionDeleteArgs} args - Arguments to delete one Vehicle_inspection.
     * @example
     * // Delete one Vehicle_inspection
     * const Vehicle_inspection = await prisma.vehicle_inspection.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_inspection
     *   }
     * })
     * 
     */
    delete<T extends vehicle_inspectionDeleteArgs>(args: SelectSubset<T, vehicle_inspectionDeleteArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_inspection.
     * @param {vehicle_inspectionUpdateArgs} args - Arguments to update one Vehicle_inspection.
     * @example
     * // Update one Vehicle_inspection
     * const vehicle_inspection = await prisma.vehicle_inspection.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_inspectionUpdateArgs>(args: SelectSubset<T, vehicle_inspectionUpdateArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_inspections.
     * @param {vehicle_inspectionDeleteManyArgs} args - Arguments to filter Vehicle_inspections to delete.
     * @example
     * // Delete a few Vehicle_inspections
     * const { count } = await prisma.vehicle_inspection.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_inspectionDeleteManyArgs>(args?: SelectSubset<T, vehicle_inspectionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_inspections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspectionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_inspections
     * const vehicle_inspection = await prisma.vehicle_inspection.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_inspectionUpdateManyArgs>(args: SelectSubset<T, vehicle_inspectionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_inspection.
     * @param {vehicle_inspectionUpsertArgs} args - Arguments to update or create a Vehicle_inspection.
     * @example
     * // Update or create a Vehicle_inspection
     * const vehicle_inspection = await prisma.vehicle_inspection.upsert({
     *   create: {
     *     // ... data to create a Vehicle_inspection
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_inspection we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_inspectionUpsertArgs>(args: SelectSubset<T, vehicle_inspectionUpsertArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_inspections that matches the filter.
     * @param {vehicle_inspectionFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_inspection = await prisma.vehicle_inspection.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_inspectionFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_inspection.
     * @param {vehicle_inspectionAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_inspection = await prisma.vehicle_inspection.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_inspectionAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_inspections.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspectionCountArgs} args - Arguments to filter Vehicle_inspections to count.
     * @example
     * // Count the number of Vehicle_inspections
     * const count = await prisma.vehicle_inspection.count({
     *   where: {
     *     // ... the filter for the Vehicle_inspections we want to count
     *   }
     * })
    **/
    count<T extends vehicle_inspectionCountArgs>(
      args?: Subset<T, vehicle_inspectionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_inspectionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_inspection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_inspectionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_inspectionAggregateArgs>(args: Subset<T, Vehicle_inspectionAggregateArgs>): Prisma.PrismaPromise<GetVehicle_inspectionAggregateType<T>>

    /**
     * Group by Vehicle_inspection.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspectionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_inspectionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_inspectionGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_inspectionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_inspectionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_inspectionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_inspection model
   */
  readonly fields: vehicle_inspectionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_inspection.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_inspectionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    details<T extends vehicle_inspection$detailsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_inspection$detailsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle_bookings<T extends vehicle_inspection$vehicle_bookingsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_inspection$vehicle_bookingsArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_inspection model
   */
  interface vehicle_inspectionFieldRefs {
    readonly id: FieldRef<"vehicle_inspection", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_inspection", 'String'>
    readonly inspection_date: FieldRef<"vehicle_inspection", 'DateTime'>
    readonly inspector_name: FieldRef<"vehicle_inspection", 'String'>
    readonly createdAt: FieldRef<"vehicle_inspection", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_inspection", 'DateTime'>
    readonly vehicle_bookingsId: FieldRef<"vehicle_inspection", 'String'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_inspection findUnique
   */
  export type vehicle_inspectionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection to fetch.
     */
    where: vehicle_inspectionWhereUniqueInput
  }

  /**
   * vehicle_inspection findUniqueOrThrow
   */
  export type vehicle_inspectionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection to fetch.
     */
    where: vehicle_inspectionWhereUniqueInput
  }

  /**
   * vehicle_inspection findFirst
   */
  export type vehicle_inspectionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection to fetch.
     */
    where?: vehicle_inspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspections to fetch.
     */
    orderBy?: vehicle_inspectionOrderByWithRelationInput | vehicle_inspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_inspections.
     */
    cursor?: vehicle_inspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_inspections.
     */
    distinct?: Vehicle_inspectionScalarFieldEnum | Vehicle_inspectionScalarFieldEnum[]
  }

  /**
   * vehicle_inspection findFirstOrThrow
   */
  export type vehicle_inspectionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection to fetch.
     */
    where?: vehicle_inspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspections to fetch.
     */
    orderBy?: vehicle_inspectionOrderByWithRelationInput | vehicle_inspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_inspections.
     */
    cursor?: vehicle_inspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspections.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_inspections.
     */
    distinct?: Vehicle_inspectionScalarFieldEnum | Vehicle_inspectionScalarFieldEnum[]
  }

  /**
   * vehicle_inspection findMany
   */
  export type vehicle_inspectionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspections to fetch.
     */
    where?: vehicle_inspectionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspections to fetch.
     */
    orderBy?: vehicle_inspectionOrderByWithRelationInput | vehicle_inspectionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_inspections.
     */
    cursor?: vehicle_inspectionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspections from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspections.
     */
    skip?: number
    distinct?: Vehicle_inspectionScalarFieldEnum | Vehicle_inspectionScalarFieldEnum[]
  }

  /**
   * vehicle_inspection create
   */
  export type vehicle_inspectionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_inspection.
     */
    data: XOR<vehicle_inspectionCreateInput, vehicle_inspectionUncheckedCreateInput>
  }

  /**
   * vehicle_inspection createMany
   */
  export type vehicle_inspectionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_inspections.
     */
    data: vehicle_inspectionCreateManyInput | vehicle_inspectionCreateManyInput[]
  }

  /**
   * vehicle_inspection update
   */
  export type vehicle_inspectionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_inspection.
     */
    data: XOR<vehicle_inspectionUpdateInput, vehicle_inspectionUncheckedUpdateInput>
    /**
     * Choose, which vehicle_inspection to update.
     */
    where: vehicle_inspectionWhereUniqueInput
  }

  /**
   * vehicle_inspection updateMany
   */
  export type vehicle_inspectionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_inspections.
     */
    data: XOR<vehicle_inspectionUpdateManyMutationInput, vehicle_inspectionUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_inspections to update
     */
    where?: vehicle_inspectionWhereInput
    /**
     * Limit how many vehicle_inspections to update.
     */
    limit?: number
  }

  /**
   * vehicle_inspection upsert
   */
  export type vehicle_inspectionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_inspection to update in case it exists.
     */
    where: vehicle_inspectionWhereUniqueInput
    /**
     * In case the vehicle_inspection found by the `where` argument doesn't exist, create a new vehicle_inspection with this data.
     */
    create: XOR<vehicle_inspectionCreateInput, vehicle_inspectionUncheckedCreateInput>
    /**
     * In case the vehicle_inspection was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_inspectionUpdateInput, vehicle_inspectionUncheckedUpdateInput>
  }

  /**
   * vehicle_inspection delete
   */
  export type vehicle_inspectionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    /**
     * Filter which vehicle_inspection to delete.
     */
    where: vehicle_inspectionWhereUniqueInput
  }

  /**
   * vehicle_inspection deleteMany
   */
  export type vehicle_inspectionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_inspections to delete
     */
    where?: vehicle_inspectionWhereInput
    /**
     * Limit how many vehicle_inspections to delete.
     */
    limit?: number
  }

  /**
   * vehicle_inspection findRaw
   */
  export type vehicle_inspectionFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_inspection aggregateRaw
   */
  export type vehicle_inspectionAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_inspection.details
   */
  export type vehicle_inspection$detailsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    where?: vehicle_inspection_detailsWhereInput
    orderBy?: vehicle_inspection_detailsOrderByWithRelationInput | vehicle_inspection_detailsOrderByWithRelationInput[]
    cursor?: vehicle_inspection_detailsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_inspection_detailsScalarFieldEnum | Vehicle_inspection_detailsScalarFieldEnum[]
  }

  /**
   * vehicle_inspection.vehicle_bookings
   */
  export type vehicle_inspection$vehicle_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    where?: vehicle_bookingsWhereInput
  }

  /**
   * vehicle_inspection without action
   */
  export type vehicle_inspectionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_inspection_details
   */

  export type AggregateVehicle_inspection_details = {
    _count: Vehicle_inspection_detailsCountAggregateOutputType | null
    _avg: Vehicle_inspection_detailsAvgAggregateOutputType | null
    _sum: Vehicle_inspection_detailsSumAggregateOutputType | null
    _min: Vehicle_inspection_detailsMinAggregateOutputType | null
    _max: Vehicle_inspection_detailsMaxAggregateOutputType | null
  }

  export type Vehicle_inspection_detailsAvgAggregateOutputType = {
    rating: number | null
  }

  export type Vehicle_inspection_detailsSumAggregateOutputType = {
    rating: number | null
  }

  export type Vehicle_inspection_detailsMinAggregateOutputType = {
    id: string | null
    checklist_option_id: string | null
    rating: number | null
    description: string | null
    vehicle_inspection_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_inspection_detailsMaxAggregateOutputType = {
    id: string | null
    checklist_option_id: string | null
    rating: number | null
    description: string | null
    vehicle_inspection_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_inspection_detailsCountAggregateOutputType = {
    id: number
    checklist_option_id: number
    rating: number
    description: number
    vehicle_inspection_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_inspection_detailsAvgAggregateInputType = {
    rating?: true
  }

  export type Vehicle_inspection_detailsSumAggregateInputType = {
    rating?: true
  }

  export type Vehicle_inspection_detailsMinAggregateInputType = {
    id?: true
    checklist_option_id?: true
    rating?: true
    description?: true
    vehicle_inspection_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_inspection_detailsMaxAggregateInputType = {
    id?: true
    checklist_option_id?: true
    rating?: true
    description?: true
    vehicle_inspection_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_inspection_detailsCountAggregateInputType = {
    id?: true
    checklist_option_id?: true
    rating?: true
    description?: true
    vehicle_inspection_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_inspection_detailsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_inspection_details to aggregate.
     */
    where?: vehicle_inspection_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspection_details to fetch.
     */
    orderBy?: vehicle_inspection_detailsOrderByWithRelationInput | vehicle_inspection_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_inspection_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspection_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspection_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_inspection_details
    **/
    _count?: true | Vehicle_inspection_detailsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vehicle_inspection_detailsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vehicle_inspection_detailsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_inspection_detailsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_inspection_detailsMaxAggregateInputType
  }

  export type GetVehicle_inspection_detailsAggregateType<T extends Vehicle_inspection_detailsAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_inspection_details]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_inspection_details[P]>
      : GetScalarType<T[P], AggregateVehicle_inspection_details[P]>
  }




  export type vehicle_inspection_detailsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_inspection_detailsWhereInput
    orderBy?: vehicle_inspection_detailsOrderByWithAggregationInput | vehicle_inspection_detailsOrderByWithAggregationInput[]
    by: Vehicle_inspection_detailsScalarFieldEnum[] | Vehicle_inspection_detailsScalarFieldEnum
    having?: vehicle_inspection_detailsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_inspection_detailsCountAggregateInputType | true
    _avg?: Vehicle_inspection_detailsAvgAggregateInputType
    _sum?: Vehicle_inspection_detailsSumAggregateInputType
    _min?: Vehicle_inspection_detailsMinAggregateInputType
    _max?: Vehicle_inspection_detailsMaxAggregateInputType
  }

  export type Vehicle_inspection_detailsGroupByOutputType = {
    id: string
    checklist_option_id: string
    rating: number
    description: string
    vehicle_inspection_id: string
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_inspection_detailsCountAggregateOutputType | null
    _avg: Vehicle_inspection_detailsAvgAggregateOutputType | null
    _sum: Vehicle_inspection_detailsSumAggregateOutputType | null
    _min: Vehicle_inspection_detailsMinAggregateOutputType | null
    _max: Vehicle_inspection_detailsMaxAggregateOutputType | null
  }

  type GetVehicle_inspection_detailsGroupByPayload<T extends vehicle_inspection_detailsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_inspection_detailsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_inspection_detailsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_inspection_detailsGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_inspection_detailsGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_inspection_detailsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    checklist_option_id?: boolean
    rating?: boolean
    description?: boolean
    vehicle_inspection_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    checklist_option?: boolean | checklist_optionsDefaultArgs<ExtArgs>
    vehicle_inspection?: boolean | vehicle_inspectionDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_inspection_details"]>



  export type vehicle_inspection_detailsSelectScalar = {
    id?: boolean
    checklist_option_id?: boolean
    rating?: boolean
    description?: boolean
    vehicle_inspection_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_inspection_detailsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "checklist_option_id" | "rating" | "description" | "vehicle_inspection_id" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_inspection_details"]>
  export type vehicle_inspection_detailsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    checklist_option?: boolean | checklist_optionsDefaultArgs<ExtArgs>
    vehicle_inspection?: boolean | vehicle_inspectionDefaultArgs<ExtArgs>
  }

  export type $vehicle_inspection_detailsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_inspection_details"
    objects: {
      checklist_option: Prisma.$checklist_optionsPayload<ExtArgs>
      vehicle_inspection: Prisma.$vehicle_inspectionPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      checklist_option_id: string
      rating: number
      description: string
      vehicle_inspection_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_inspection_details"]>
    composites: {}
  }

  type vehicle_inspection_detailsGetPayload<S extends boolean | null | undefined | vehicle_inspection_detailsDefaultArgs> = $Result.GetResult<Prisma.$vehicle_inspection_detailsPayload, S>

  type vehicle_inspection_detailsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_inspection_detailsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_inspection_detailsCountAggregateInputType | true
    }

  export interface vehicle_inspection_detailsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_inspection_details'], meta: { name: 'vehicle_inspection_details' } }
    /**
     * Find zero or one Vehicle_inspection_details that matches the filter.
     * @param {vehicle_inspection_detailsFindUniqueArgs} args - Arguments to find a Vehicle_inspection_details
     * @example
     * // Get one Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_inspection_detailsFindUniqueArgs>(args: SelectSubset<T, vehicle_inspection_detailsFindUniqueArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_inspection_details that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_inspection_detailsFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_inspection_details
     * @example
     * // Get one Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_inspection_detailsFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_inspection_detailsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_inspection_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspection_detailsFindFirstArgs} args - Arguments to find a Vehicle_inspection_details
     * @example
     * // Get one Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_inspection_detailsFindFirstArgs>(args?: SelectSubset<T, vehicle_inspection_detailsFindFirstArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_inspection_details that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspection_detailsFindFirstOrThrowArgs} args - Arguments to find a Vehicle_inspection_details
     * @example
     * // Get one Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_inspection_detailsFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_inspection_detailsFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_inspection_details that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspection_detailsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findMany()
     * 
     * // Get first 10 Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_inspection_detailsWithIdOnly = await prisma.vehicle_inspection_details.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_inspection_detailsFindManyArgs>(args?: SelectSubset<T, vehicle_inspection_detailsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsCreateArgs} args - Arguments to create a Vehicle_inspection_details.
     * @example
     * // Create one Vehicle_inspection_details
     * const Vehicle_inspection_details = await prisma.vehicle_inspection_details.create({
     *   data: {
     *     // ... data to create a Vehicle_inspection_details
     *   }
     * })
     * 
     */
    create<T extends vehicle_inspection_detailsCreateArgs>(args: SelectSubset<T, vehicle_inspection_detailsCreateArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsCreateManyArgs} args - Arguments to create many Vehicle_inspection_details.
     * @example
     * // Create many Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_inspection_detailsCreateManyArgs>(args?: SelectSubset<T, vehicle_inspection_detailsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsDeleteArgs} args - Arguments to delete one Vehicle_inspection_details.
     * @example
     * // Delete one Vehicle_inspection_details
     * const Vehicle_inspection_details = await prisma.vehicle_inspection_details.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_inspection_details
     *   }
     * })
     * 
     */
    delete<T extends vehicle_inspection_detailsDeleteArgs>(args: SelectSubset<T, vehicle_inspection_detailsDeleteArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsUpdateArgs} args - Arguments to update one Vehicle_inspection_details.
     * @example
     * // Update one Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_inspection_detailsUpdateArgs>(args: SelectSubset<T, vehicle_inspection_detailsUpdateArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsDeleteManyArgs} args - Arguments to filter Vehicle_inspection_details to delete.
     * @example
     * // Delete a few Vehicle_inspection_details
     * const { count } = await prisma.vehicle_inspection_details.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_inspection_detailsDeleteManyArgs>(args?: SelectSubset<T, vehicle_inspection_detailsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_inspection_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspection_detailsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_inspection_detailsUpdateManyArgs>(args: SelectSubset<T, vehicle_inspection_detailsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsUpsertArgs} args - Arguments to update or create a Vehicle_inspection_details.
     * @example
     * // Update or create a Vehicle_inspection_details
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.upsert({
     *   create: {
     *     // ... data to create a Vehicle_inspection_details
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_inspection_details we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_inspection_detailsUpsertArgs>(args: SelectSubset<T, vehicle_inspection_detailsUpsertArgs<ExtArgs>>): Prisma__vehicle_inspection_detailsClient<$Result.GetResult<Prisma.$vehicle_inspection_detailsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_inspection_details that matches the filter.
     * @param {vehicle_inspection_detailsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_inspection_detailsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_inspection_details.
     * @param {vehicle_inspection_detailsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_inspection_details = await prisma.vehicle_inspection_details.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_inspection_detailsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_inspection_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspection_detailsCountArgs} args - Arguments to filter Vehicle_inspection_details to count.
     * @example
     * // Count the number of Vehicle_inspection_details
     * const count = await prisma.vehicle_inspection_details.count({
     *   where: {
     *     // ... the filter for the Vehicle_inspection_details we want to count
     *   }
     * })
    **/
    count<T extends vehicle_inspection_detailsCountArgs>(
      args?: Subset<T, vehicle_inspection_detailsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_inspection_detailsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_inspection_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_inspection_detailsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_inspection_detailsAggregateArgs>(args: Subset<T, Vehicle_inspection_detailsAggregateArgs>): Prisma.PrismaPromise<GetVehicle_inspection_detailsAggregateType<T>>

    /**
     * Group by Vehicle_inspection_details.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_inspection_detailsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_inspection_detailsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_inspection_detailsGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_inspection_detailsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_inspection_detailsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_inspection_detailsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_inspection_details model
   */
  readonly fields: vehicle_inspection_detailsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_inspection_details.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_inspection_detailsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    checklist_option<T extends checklist_optionsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, checklist_optionsDefaultArgs<ExtArgs>>): Prisma__checklist_optionsClient<$Result.GetResult<Prisma.$checklist_optionsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_inspection<T extends vehicle_inspectionDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_inspectionDefaultArgs<ExtArgs>>): Prisma__vehicle_inspectionClient<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_inspection_details model
   */
  interface vehicle_inspection_detailsFieldRefs {
    readonly id: FieldRef<"vehicle_inspection_details", 'String'>
    readonly checklist_option_id: FieldRef<"vehicle_inspection_details", 'String'>
    readonly rating: FieldRef<"vehicle_inspection_details", 'Int'>
    readonly description: FieldRef<"vehicle_inspection_details", 'String'>
    readonly vehicle_inspection_id: FieldRef<"vehicle_inspection_details", 'String'>
    readonly createdAt: FieldRef<"vehicle_inspection_details", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_inspection_details", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_inspection_details findUnique
   */
  export type vehicle_inspection_detailsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection_details to fetch.
     */
    where: vehicle_inspection_detailsWhereUniqueInput
  }

  /**
   * vehicle_inspection_details findUniqueOrThrow
   */
  export type vehicle_inspection_detailsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection_details to fetch.
     */
    where: vehicle_inspection_detailsWhereUniqueInput
  }

  /**
   * vehicle_inspection_details findFirst
   */
  export type vehicle_inspection_detailsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection_details to fetch.
     */
    where?: vehicle_inspection_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspection_details to fetch.
     */
    orderBy?: vehicle_inspection_detailsOrderByWithRelationInput | vehicle_inspection_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_inspection_details.
     */
    cursor?: vehicle_inspection_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspection_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspection_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_inspection_details.
     */
    distinct?: Vehicle_inspection_detailsScalarFieldEnum | Vehicle_inspection_detailsScalarFieldEnum[]
  }

  /**
   * vehicle_inspection_details findFirstOrThrow
   */
  export type vehicle_inspection_detailsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection_details to fetch.
     */
    where?: vehicle_inspection_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspection_details to fetch.
     */
    orderBy?: vehicle_inspection_detailsOrderByWithRelationInput | vehicle_inspection_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_inspection_details.
     */
    cursor?: vehicle_inspection_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspection_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspection_details.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_inspection_details.
     */
    distinct?: Vehicle_inspection_detailsScalarFieldEnum | Vehicle_inspection_detailsScalarFieldEnum[]
  }

  /**
   * vehicle_inspection_details findMany
   */
  export type vehicle_inspection_detailsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_inspection_details to fetch.
     */
    where?: vehicle_inspection_detailsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_inspection_details to fetch.
     */
    orderBy?: vehicle_inspection_detailsOrderByWithRelationInput | vehicle_inspection_detailsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_inspection_details.
     */
    cursor?: vehicle_inspection_detailsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_inspection_details from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_inspection_details.
     */
    skip?: number
    distinct?: Vehicle_inspection_detailsScalarFieldEnum | Vehicle_inspection_detailsScalarFieldEnum[]
  }

  /**
   * vehicle_inspection_details create
   */
  export type vehicle_inspection_detailsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_inspection_details.
     */
    data: XOR<vehicle_inspection_detailsCreateInput, vehicle_inspection_detailsUncheckedCreateInput>
  }

  /**
   * vehicle_inspection_details createMany
   */
  export type vehicle_inspection_detailsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_inspection_details.
     */
    data: vehicle_inspection_detailsCreateManyInput | vehicle_inspection_detailsCreateManyInput[]
  }

  /**
   * vehicle_inspection_details update
   */
  export type vehicle_inspection_detailsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_inspection_details.
     */
    data: XOR<vehicle_inspection_detailsUpdateInput, vehicle_inspection_detailsUncheckedUpdateInput>
    /**
     * Choose, which vehicle_inspection_details to update.
     */
    where: vehicle_inspection_detailsWhereUniqueInput
  }

  /**
   * vehicle_inspection_details updateMany
   */
  export type vehicle_inspection_detailsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_inspection_details.
     */
    data: XOR<vehicle_inspection_detailsUpdateManyMutationInput, vehicle_inspection_detailsUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_inspection_details to update
     */
    where?: vehicle_inspection_detailsWhereInput
    /**
     * Limit how many vehicle_inspection_details to update.
     */
    limit?: number
  }

  /**
   * vehicle_inspection_details upsert
   */
  export type vehicle_inspection_detailsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_inspection_details to update in case it exists.
     */
    where: vehicle_inspection_detailsWhereUniqueInput
    /**
     * In case the vehicle_inspection_details found by the `where` argument doesn't exist, create a new vehicle_inspection_details with this data.
     */
    create: XOR<vehicle_inspection_detailsCreateInput, vehicle_inspection_detailsUncheckedCreateInput>
    /**
     * In case the vehicle_inspection_details was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_inspection_detailsUpdateInput, vehicle_inspection_detailsUncheckedUpdateInput>
  }

  /**
   * vehicle_inspection_details delete
   */
  export type vehicle_inspection_detailsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
    /**
     * Filter which vehicle_inspection_details to delete.
     */
    where: vehicle_inspection_detailsWhereUniqueInput
  }

  /**
   * vehicle_inspection_details deleteMany
   */
  export type vehicle_inspection_detailsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_inspection_details to delete
     */
    where?: vehicle_inspection_detailsWhereInput
    /**
     * Limit how many vehicle_inspection_details to delete.
     */
    limit?: number
  }

  /**
   * vehicle_inspection_details findRaw
   */
  export type vehicle_inspection_detailsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_inspection_details aggregateRaw
   */
  export type vehicle_inspection_detailsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_inspection_details without action
   */
  export type vehicle_inspection_detailsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection_details
     */
    select?: vehicle_inspection_detailsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection_details
     */
    omit?: vehicle_inspection_detailsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspection_detailsInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_prices
   */

  export type AggregateVehicle_prices = {
    _count: Vehicle_pricesCountAggregateOutputType | null
    _avg: Vehicle_pricesAvgAggregateOutputType | null
    _sum: Vehicle_pricesSumAggregateOutputType | null
    _min: Vehicle_pricesMinAggregateOutputType | null
    _max: Vehicle_pricesMaxAggregateOutputType | null
  }

  export type Vehicle_pricesAvgAggregateOutputType = {
    base_price_per_day: number | null
    hr_included: number | null
    km_included: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
  }

  export type Vehicle_pricesSumAggregateOutputType = {
    base_price_per_day: number | null
    hr_included: number | null
    km_included: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
  }

  export type Vehicle_pricesMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    base_price_per_day: number | null
    hr_included: number | null
    km_included: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
    is_unlimited_allowed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_pricesMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    base_price_per_day: number | null
    hr_included: number | null
    km_included: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
    is_unlimited_allowed: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_pricesCountAggregateOutputType = {
    id: number
    vehicle_id: number
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_pricesAvgAggregateInputType = {
    base_price_per_day?: true
    hr_included?: true
    km_included?: true
    extra_km_charge?: true
    extra_hr_charge?: true
  }

  export type Vehicle_pricesSumAggregateInputType = {
    base_price_per_day?: true
    hr_included?: true
    km_included?: true
    extra_km_charge?: true
    extra_hr_charge?: true
  }

  export type Vehicle_pricesMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    base_price_per_day?: true
    hr_included?: true
    km_included?: true
    extra_km_charge?: true
    extra_hr_charge?: true
    is_unlimited_allowed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_pricesMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    base_price_per_day?: true
    hr_included?: true
    km_included?: true
    extra_km_charge?: true
    extra_hr_charge?: true
    is_unlimited_allowed?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_pricesCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    base_price_per_day?: true
    hr_included?: true
    km_included?: true
    extra_km_charge?: true
    extra_hr_charge?: true
    is_unlimited_allowed?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_pricesAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_prices to aggregate.
     */
    where?: vehicle_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_prices to fetch.
     */
    orderBy?: vehicle_pricesOrderByWithRelationInput | vehicle_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_prices
    **/
    _count?: true | Vehicle_pricesCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vehicle_pricesAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vehicle_pricesSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_pricesMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_pricesMaxAggregateInputType
  }

  export type GetVehicle_pricesAggregateType<T extends Vehicle_pricesAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_prices]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_prices[P]>
      : GetScalarType<T[P], AggregateVehicle_prices[P]>
  }




  export type vehicle_pricesGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_pricesWhereInput
    orderBy?: vehicle_pricesOrderByWithAggregationInput | vehicle_pricesOrderByWithAggregationInput[]
    by: Vehicle_pricesScalarFieldEnum[] | Vehicle_pricesScalarFieldEnum
    having?: vehicle_pricesScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_pricesCountAggregateInputType | true
    _avg?: Vehicle_pricesAvgAggregateInputType
    _sum?: Vehicle_pricesSumAggregateInputType
    _min?: Vehicle_pricesMinAggregateInputType
    _max?: Vehicle_pricesMaxAggregateInputType
  }

  export type Vehicle_pricesGroupByOutputType = {
    id: string
    vehicle_id: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed: boolean
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_pricesCountAggregateOutputType | null
    _avg: Vehicle_pricesAvgAggregateOutputType | null
    _sum: Vehicle_pricesSumAggregateOutputType | null
    _min: Vehicle_pricesMinAggregateOutputType | null
    _max: Vehicle_pricesMaxAggregateOutputType | null
  }

  type GetVehicle_pricesGroupByPayload<T extends vehicle_pricesGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_pricesGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_pricesGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_pricesGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_pricesGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_pricesSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    base_price_per_day?: boolean
    hr_included?: boolean
    km_included?: boolean
    extra_km_charge?: boolean
    extra_hr_charge?: boolean
    is_unlimited_allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
    bills?: boolean | vehicle_prices$billsArgs<ExtArgs>
    _count?: boolean | Vehicle_pricesCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_prices"]>



  export type vehicle_pricesSelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    base_price_per_day?: boolean
    hr_included?: boolean
    km_included?: boolean
    extra_km_charge?: boolean
    extra_hr_charge?: boolean
    is_unlimited_allowed?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_pricesOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "base_price_per_day" | "hr_included" | "km_included" | "extra_km_charge" | "extra_hr_charge" | "is_unlimited_allowed" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_prices"]>
  export type vehicle_pricesInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
    bills?: boolean | vehicle_prices$billsArgs<ExtArgs>
    _count?: boolean | Vehicle_pricesCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $vehicle_pricesPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_prices"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
      bills: Prisma.$vehicle_bookings_billsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string
      base_price_per_day: number
      hr_included: number
      km_included: number
      extra_km_charge: number
      extra_hr_charge: number
      is_unlimited_allowed: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_prices"]>
    composites: {}
  }

  type vehicle_pricesGetPayload<S extends boolean | null | undefined | vehicle_pricesDefaultArgs> = $Result.GetResult<Prisma.$vehicle_pricesPayload, S>

  type vehicle_pricesCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_pricesFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_pricesCountAggregateInputType | true
    }

  export interface vehicle_pricesDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_prices'], meta: { name: 'vehicle_prices' } }
    /**
     * Find zero or one Vehicle_prices that matches the filter.
     * @param {vehicle_pricesFindUniqueArgs} args - Arguments to find a Vehicle_prices
     * @example
     * // Get one Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_pricesFindUniqueArgs>(args: SelectSubset<T, vehicle_pricesFindUniqueArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_prices that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_pricesFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_prices
     * @example
     * // Get one Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_pricesFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_pricesFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_pricesFindFirstArgs} args - Arguments to find a Vehicle_prices
     * @example
     * // Get one Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_pricesFindFirstArgs>(args?: SelectSubset<T, vehicle_pricesFindFirstArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_prices that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_pricesFindFirstOrThrowArgs} args - Arguments to find a Vehicle_prices
     * @example
     * // Get one Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_pricesFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_pricesFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_prices that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_pricesFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.findMany()
     * 
     * // Get first 10 Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_pricesWithIdOnly = await prisma.vehicle_prices.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_pricesFindManyArgs>(args?: SelectSubset<T, vehicle_pricesFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_prices.
     * @param {vehicle_pricesCreateArgs} args - Arguments to create a Vehicle_prices.
     * @example
     * // Create one Vehicle_prices
     * const Vehicle_prices = await prisma.vehicle_prices.create({
     *   data: {
     *     // ... data to create a Vehicle_prices
     *   }
     * })
     * 
     */
    create<T extends vehicle_pricesCreateArgs>(args: SelectSubset<T, vehicle_pricesCreateArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_prices.
     * @param {vehicle_pricesCreateManyArgs} args - Arguments to create many Vehicle_prices.
     * @example
     * // Create many Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_pricesCreateManyArgs>(args?: SelectSubset<T, vehicle_pricesCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_prices.
     * @param {vehicle_pricesDeleteArgs} args - Arguments to delete one Vehicle_prices.
     * @example
     * // Delete one Vehicle_prices
     * const Vehicle_prices = await prisma.vehicle_prices.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_prices
     *   }
     * })
     * 
     */
    delete<T extends vehicle_pricesDeleteArgs>(args: SelectSubset<T, vehicle_pricesDeleteArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_prices.
     * @param {vehicle_pricesUpdateArgs} args - Arguments to update one Vehicle_prices.
     * @example
     * // Update one Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_pricesUpdateArgs>(args: SelectSubset<T, vehicle_pricesUpdateArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_prices.
     * @param {vehicle_pricesDeleteManyArgs} args - Arguments to filter Vehicle_prices to delete.
     * @example
     * // Delete a few Vehicle_prices
     * const { count } = await prisma.vehicle_prices.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_pricesDeleteManyArgs>(args?: SelectSubset<T, vehicle_pricesDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_pricesUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_pricesUpdateManyArgs>(args: SelectSubset<T, vehicle_pricesUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_prices.
     * @param {vehicle_pricesUpsertArgs} args - Arguments to update or create a Vehicle_prices.
     * @example
     * // Update or create a Vehicle_prices
     * const vehicle_prices = await prisma.vehicle_prices.upsert({
     *   create: {
     *     // ... data to create a Vehicle_prices
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_prices we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_pricesUpsertArgs>(args: SelectSubset<T, vehicle_pricesUpsertArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_prices that matches the filter.
     * @param {vehicle_pricesFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_prices = await prisma.vehicle_prices.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_pricesFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_prices.
     * @param {vehicle_pricesAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_prices = await prisma.vehicle_prices.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_pricesAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_pricesCountArgs} args - Arguments to filter Vehicle_prices to count.
     * @example
     * // Count the number of Vehicle_prices
     * const count = await prisma.vehicle_prices.count({
     *   where: {
     *     // ... the filter for the Vehicle_prices we want to count
     *   }
     * })
    **/
    count<T extends vehicle_pricesCountArgs>(
      args?: Subset<T, vehicle_pricesCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_pricesCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_pricesAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_pricesAggregateArgs>(args: Subset<T, Vehicle_pricesAggregateArgs>): Prisma.PrismaPromise<GetVehicle_pricesAggregateType<T>>

    /**
     * Group by Vehicle_prices.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_pricesGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_pricesGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_pricesGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_pricesGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_pricesGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_pricesGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_prices model
   */
  readonly fields: vehicle_pricesFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_prices.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_pricesClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bills<T extends vehicle_prices$billsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_prices$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_prices model
   */
  interface vehicle_pricesFieldRefs {
    readonly id: FieldRef<"vehicle_prices", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_prices", 'String'>
    readonly base_price_per_day: FieldRef<"vehicle_prices", 'Float'>
    readonly hr_included: FieldRef<"vehicle_prices", 'Int'>
    readonly km_included: FieldRef<"vehicle_prices", 'Int'>
    readonly extra_km_charge: FieldRef<"vehicle_prices", 'Float'>
    readonly extra_hr_charge: FieldRef<"vehicle_prices", 'Float'>
    readonly is_unlimited_allowed: FieldRef<"vehicle_prices", 'Boolean'>
    readonly createdAt: FieldRef<"vehicle_prices", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_prices", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_prices findUnique
   */
  export type vehicle_pricesFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_prices to fetch.
     */
    where: vehicle_pricesWhereUniqueInput
  }

  /**
   * vehicle_prices findUniqueOrThrow
   */
  export type vehicle_pricesFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_prices to fetch.
     */
    where: vehicle_pricesWhereUniqueInput
  }

  /**
   * vehicle_prices findFirst
   */
  export type vehicle_pricesFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_prices to fetch.
     */
    where?: vehicle_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_prices to fetch.
     */
    orderBy?: vehicle_pricesOrderByWithRelationInput | vehicle_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_prices.
     */
    cursor?: vehicle_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_prices.
     */
    distinct?: Vehicle_pricesScalarFieldEnum | Vehicle_pricesScalarFieldEnum[]
  }

  /**
   * vehicle_prices findFirstOrThrow
   */
  export type vehicle_pricesFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_prices to fetch.
     */
    where?: vehicle_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_prices to fetch.
     */
    orderBy?: vehicle_pricesOrderByWithRelationInput | vehicle_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_prices.
     */
    cursor?: vehicle_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_prices.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_prices.
     */
    distinct?: Vehicle_pricesScalarFieldEnum | Vehicle_pricesScalarFieldEnum[]
  }

  /**
   * vehicle_prices findMany
   */
  export type vehicle_pricesFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_prices to fetch.
     */
    where?: vehicle_pricesWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_prices to fetch.
     */
    orderBy?: vehicle_pricesOrderByWithRelationInput | vehicle_pricesOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_prices.
     */
    cursor?: vehicle_pricesWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_prices from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_prices.
     */
    skip?: number
    distinct?: Vehicle_pricesScalarFieldEnum | Vehicle_pricesScalarFieldEnum[]
  }

  /**
   * vehicle_prices create
   */
  export type vehicle_pricesCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_prices.
     */
    data: XOR<vehicle_pricesCreateInput, vehicle_pricesUncheckedCreateInput>
  }

  /**
   * vehicle_prices createMany
   */
  export type vehicle_pricesCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_prices.
     */
    data: vehicle_pricesCreateManyInput | vehicle_pricesCreateManyInput[]
  }

  /**
   * vehicle_prices update
   */
  export type vehicle_pricesUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_prices.
     */
    data: XOR<vehicle_pricesUpdateInput, vehicle_pricesUncheckedUpdateInput>
    /**
     * Choose, which vehicle_prices to update.
     */
    where: vehicle_pricesWhereUniqueInput
  }

  /**
   * vehicle_prices updateMany
   */
  export type vehicle_pricesUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_prices.
     */
    data: XOR<vehicle_pricesUpdateManyMutationInput, vehicle_pricesUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_prices to update
     */
    where?: vehicle_pricesWhereInput
    /**
     * Limit how many vehicle_prices to update.
     */
    limit?: number
  }

  /**
   * vehicle_prices upsert
   */
  export type vehicle_pricesUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_prices to update in case it exists.
     */
    where: vehicle_pricesWhereUniqueInput
    /**
     * In case the vehicle_prices found by the `where` argument doesn't exist, create a new vehicle_prices with this data.
     */
    create: XOR<vehicle_pricesCreateInput, vehicle_pricesUncheckedCreateInput>
    /**
     * In case the vehicle_prices was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_pricesUpdateInput, vehicle_pricesUncheckedUpdateInput>
  }

  /**
   * vehicle_prices delete
   */
  export type vehicle_pricesDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
    /**
     * Filter which vehicle_prices to delete.
     */
    where: vehicle_pricesWhereUniqueInput
  }

  /**
   * vehicle_prices deleteMany
   */
  export type vehicle_pricesDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_prices to delete
     */
    where?: vehicle_pricesWhereInput
    /**
     * Limit how many vehicle_prices to delete.
     */
    limit?: number
  }

  /**
   * vehicle_prices findRaw
   */
  export type vehicle_pricesFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_prices aggregateRaw
   */
  export type vehicle_pricesAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_prices.bills
   */
  export type vehicle_prices$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    where?: vehicle_bookings_billsWhereInput
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    cursor?: vehicle_bookings_billsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookings_billsScalarFieldEnum | Vehicle_bookings_billsScalarFieldEnum[]
  }

  /**
   * vehicle_prices without action
   */
  export type vehicle_pricesDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_prices
     */
    select?: vehicle_pricesSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_prices
     */
    omit?: vehicle_pricesOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_pricesInclude<ExtArgs> | null
  }


  /**
   * Model customer
   */

  export type AggregateCustomer = {
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  export type CustomerMinAggregateOutputType = {
    id: string | null
    name: string | null
    email_id: string | null
    mobile_number: string | null
    alternate_mobile_number: string | null
    address: string | null
    city_id: string | null
    state_id: string | null
    pin_code: string | null
    adhaar_number: string | null
    adhar_front_image: string | null
    adhar_back_image: string | null
    driving_license_number: string | null
    driving_license_front_image: string | null
    driving_license_back_image: string | null
    profile_image: string | null
    is_active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email_id: string | null
    mobile_number: string | null
    alternate_mobile_number: string | null
    address: string | null
    city_id: string | null
    state_id: string | null
    pin_code: string | null
    adhaar_number: string | null
    adhar_front_image: string | null
    adhar_back_image: string | null
    driving_license_number: string | null
    driving_license_front_image: string | null
    driving_license_back_image: string | null
    profile_image: string | null
    is_active: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type CustomerCountAggregateOutputType = {
    id: number
    name: number
    email_id: number
    mobile_number: number
    alternate_mobile_number: number
    address: number
    city_id: number
    state_id: number
    pin_code: number
    adhaar_number: number
    adhar_front_image: number
    adhar_back_image: number
    driving_license_number: number
    driving_license_front_image: number
    driving_license_back_image: number
    profile_image: number
    is_active: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type CustomerMinAggregateInputType = {
    id?: true
    name?: true
    email_id?: true
    mobile_number?: true
    alternate_mobile_number?: true
    address?: true
    city_id?: true
    state_id?: true
    pin_code?: true
    adhaar_number?: true
    adhar_front_image?: true
    adhar_back_image?: true
    driving_license_number?: true
    driving_license_front_image?: true
    driving_license_back_image?: true
    profile_image?: true
    is_active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerMaxAggregateInputType = {
    id?: true
    name?: true
    email_id?: true
    mobile_number?: true
    alternate_mobile_number?: true
    address?: true
    city_id?: true
    state_id?: true
    pin_code?: true
    adhaar_number?: true
    adhar_front_image?: true
    adhar_back_image?: true
    driving_license_number?: true
    driving_license_front_image?: true
    driving_license_back_image?: true
    profile_image?: true
    is_active?: true
    createdAt?: true
    updatedAt?: true
  }

  export type CustomerCountAggregateInputType = {
    id?: true
    name?: true
    email_id?: true
    mobile_number?: true
    alternate_mobile_number?: true
    address?: true
    city_id?: true
    state_id?: true
    pin_code?: true
    adhaar_number?: true
    adhar_front_image?: true
    adhar_back_image?: true
    driving_license_number?: true
    driving_license_front_image?: true
    driving_license_back_image?: true
    profile_image?: true
    is_active?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type CustomerAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customer to aggregate.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned customers
    **/
    _count?: true | CustomerCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: CustomerMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: CustomerMaxAggregateInputType
  }

  export type GetCustomerAggregateType<T extends CustomerAggregateArgs> = {
        [P in keyof T & keyof AggregateCustomer]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateCustomer[P]>
      : GetScalarType<T[P], AggregateCustomer[P]>
  }




  export type customerGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: customerWhereInput
    orderBy?: customerOrderByWithAggregationInput | customerOrderByWithAggregationInput[]
    by: CustomerScalarFieldEnum[] | CustomerScalarFieldEnum
    having?: customerScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: CustomerCountAggregateInputType | true
    _min?: CustomerMinAggregateInputType
    _max?: CustomerMaxAggregateInputType
  }

  export type CustomerGroupByOutputType = {
    id: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number: string | null
    address: string
    city_id: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image: string | null
    is_active: boolean
    createdAt: Date
    updatedAt: Date
    _count: CustomerCountAggregateOutputType | null
    _min: CustomerMinAggregateOutputType | null
    _max: CustomerMaxAggregateOutputType | null
  }

  type GetCustomerGroupByPayload<T extends customerGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<CustomerGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof CustomerGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], CustomerGroupByOutputType[P]>
            : GetScalarType<T[P], CustomerGroupByOutputType[P]>
        }
      >
    >


  export type customerSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email_id?: boolean
    mobile_number?: boolean
    alternate_mobile_number?: boolean
    address?: boolean
    city_id?: boolean
    state_id?: boolean
    pin_code?: boolean
    adhaar_number?: boolean
    adhar_front_image?: boolean
    adhar_back_image?: boolean
    driving_license_number?: boolean
    driving_license_front_image?: boolean
    driving_license_back_image?: boolean
    profile_image?: boolean
    is_active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | citiesDefaultArgs<ExtArgs>
    state?: boolean | statesDefaultArgs<ExtArgs>
    vehicle_bookings?: boolean | customer$vehicle_bookingsArgs<ExtArgs>
    vehicle_bookings_logs?: boolean | customer$vehicle_bookings_logsArgs<ExtArgs>
    vehicle_bookings_bills?: boolean | customer$vehicle_bookings_billsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["customer"]>



  export type customerSelectScalar = {
    id?: boolean
    name?: boolean
    email_id?: boolean
    mobile_number?: boolean
    alternate_mobile_number?: boolean
    address?: boolean
    city_id?: boolean
    state_id?: boolean
    pin_code?: boolean
    adhaar_number?: boolean
    adhar_front_image?: boolean
    adhar_back_image?: boolean
    driving_license_number?: boolean
    driving_license_front_image?: boolean
    driving_license_back_image?: boolean
    profile_image?: boolean
    is_active?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type customerOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email_id" | "mobile_number" | "alternate_mobile_number" | "address" | "city_id" | "state_id" | "pin_code" | "adhaar_number" | "adhar_front_image" | "adhar_back_image" | "driving_license_number" | "driving_license_front_image" | "driving_license_back_image" | "profile_image" | "is_active" | "createdAt" | "updatedAt", ExtArgs["result"]["customer"]>
  export type customerInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | citiesDefaultArgs<ExtArgs>
    state?: boolean | statesDefaultArgs<ExtArgs>
    vehicle_bookings?: boolean | customer$vehicle_bookingsArgs<ExtArgs>
    vehicle_bookings_logs?: boolean | customer$vehicle_bookings_logsArgs<ExtArgs>
    vehicle_bookings_bills?: boolean | customer$vehicle_bookings_billsArgs<ExtArgs>
    _count?: boolean | CustomerCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $customerPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "customer"
    objects: {
      city: Prisma.$citiesPayload<ExtArgs>
      state: Prisma.$statesPayload<ExtArgs>
      vehicle_bookings: Prisma.$vehicle_bookingsPayload<ExtArgs>[]
      vehicle_bookings_logs: Prisma.$vehicle_bookings_logsPayload<ExtArgs>[]
      vehicle_bookings_bills: Prisma.$vehicle_bookings_billsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email_id: string
      mobile_number: string
      alternate_mobile_number: string | null
      address: string
      city_id: string
      state_id: string
      pin_code: string
      adhaar_number: string
      adhar_front_image: string
      adhar_back_image: string
      driving_license_number: string
      driving_license_front_image: string
      driving_license_back_image: string
      profile_image: string | null
      is_active: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["customer"]>
    composites: {}
  }

  type customerGetPayload<S extends boolean | null | undefined | customerDefaultArgs> = $Result.GetResult<Prisma.$customerPayload, S>

  type customerCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<customerFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: CustomerCountAggregateInputType | true
    }

  export interface customerDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['customer'], meta: { name: 'customer' } }
    /**
     * Find zero or one Customer that matches the filter.
     * @param {customerFindUniqueArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends customerFindUniqueArgs>(args: SelectSubset<T, customerFindUniqueArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Customer that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {customerFindUniqueOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends customerFindUniqueOrThrowArgs>(args: SelectSubset<T, customerFindUniqueOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends customerFindFirstArgs>(args?: SelectSubset<T, customerFindFirstArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Customer that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindFirstOrThrowArgs} args - Arguments to find a Customer
     * @example
     * // Get one Customer
     * const customer = await prisma.customer.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends customerFindFirstOrThrowArgs>(args?: SelectSubset<T, customerFindFirstOrThrowArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Customers
     * const customers = await prisma.customer.findMany()
     * 
     * // Get first 10 Customers
     * const customers = await prisma.customer.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const customerWithIdOnly = await prisma.customer.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends customerFindManyArgs>(args?: SelectSubset<T, customerFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Customer.
     * @param {customerCreateArgs} args - Arguments to create a Customer.
     * @example
     * // Create one Customer
     * const Customer = await prisma.customer.create({
     *   data: {
     *     // ... data to create a Customer
     *   }
     * })
     * 
     */
    create<T extends customerCreateArgs>(args: SelectSubset<T, customerCreateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Customers.
     * @param {customerCreateManyArgs} args - Arguments to create many Customers.
     * @example
     * // Create many Customers
     * const customer = await prisma.customer.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends customerCreateManyArgs>(args?: SelectSubset<T, customerCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Customer.
     * @param {customerDeleteArgs} args - Arguments to delete one Customer.
     * @example
     * // Delete one Customer
     * const Customer = await prisma.customer.delete({
     *   where: {
     *     // ... filter to delete one Customer
     *   }
     * })
     * 
     */
    delete<T extends customerDeleteArgs>(args: SelectSubset<T, customerDeleteArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Customer.
     * @param {customerUpdateArgs} args - Arguments to update one Customer.
     * @example
     * // Update one Customer
     * const customer = await prisma.customer.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends customerUpdateArgs>(args: SelectSubset<T, customerUpdateArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Customers.
     * @param {customerDeleteManyArgs} args - Arguments to filter Customers to delete.
     * @example
     * // Delete a few Customers
     * const { count } = await prisma.customer.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends customerDeleteManyArgs>(args?: SelectSubset<T, customerDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Customers
     * const customer = await prisma.customer.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends customerUpdateManyArgs>(args: SelectSubset<T, customerUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Customer.
     * @param {customerUpsertArgs} args - Arguments to update or create a Customer.
     * @example
     * // Update or create a Customer
     * const customer = await prisma.customer.upsert({
     *   create: {
     *     // ... data to create a Customer
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Customer we want to update
     *   }
     * })
     */
    upsert<T extends customerUpsertArgs>(args: SelectSubset<T, customerUpsertArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Customers that matches the filter.
     * @param {customerFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const customer = await prisma.customer.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: customerFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Customer.
     * @param {customerAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const customer = await prisma.customer.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: customerAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Customers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerCountArgs} args - Arguments to filter Customers to count.
     * @example
     * // Count the number of Customers
     * const count = await prisma.customer.count({
     *   where: {
     *     // ... the filter for the Customers we want to count
     *   }
     * })
    **/
    count<T extends customerCountArgs>(
      args?: Subset<T, customerCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], CustomerCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {CustomerAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends CustomerAggregateArgs>(args: Subset<T, CustomerAggregateArgs>): Prisma.PrismaPromise<GetCustomerAggregateType<T>>

    /**
     * Group by Customer.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {customerGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends customerGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: customerGroupByArgs['orderBy'] }
        : { orderBy?: customerGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, customerGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetCustomerGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the customer model
   */
  readonly fields: customerFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for customer.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__customerClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends citiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, citiesDefaultArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    state<T extends statesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statesDefaultArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_bookings<T extends customer$vehicle_bookingsArgs<ExtArgs> = {}>(args?: Subset<T, customer$vehicle_bookingsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle_bookings_logs<T extends customer$vehicle_bookings_logsArgs<ExtArgs> = {}>(args?: Subset<T, customer$vehicle_bookings_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    vehicle_bookings_bills<T extends customer$vehicle_bookings_billsArgs<ExtArgs> = {}>(args?: Subset<T, customer$vehicle_bookings_billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the customer model
   */
  interface customerFieldRefs {
    readonly id: FieldRef<"customer", 'String'>
    readonly name: FieldRef<"customer", 'String'>
    readonly email_id: FieldRef<"customer", 'String'>
    readonly mobile_number: FieldRef<"customer", 'String'>
    readonly alternate_mobile_number: FieldRef<"customer", 'String'>
    readonly address: FieldRef<"customer", 'String'>
    readonly city_id: FieldRef<"customer", 'String'>
    readonly state_id: FieldRef<"customer", 'String'>
    readonly pin_code: FieldRef<"customer", 'String'>
    readonly adhaar_number: FieldRef<"customer", 'String'>
    readonly adhar_front_image: FieldRef<"customer", 'String'>
    readonly adhar_back_image: FieldRef<"customer", 'String'>
    readonly driving_license_number: FieldRef<"customer", 'String'>
    readonly driving_license_front_image: FieldRef<"customer", 'String'>
    readonly driving_license_back_image: FieldRef<"customer", 'String'>
    readonly profile_image: FieldRef<"customer", 'String'>
    readonly is_active: FieldRef<"customer", 'Boolean'>
    readonly createdAt: FieldRef<"customer", 'DateTime'>
    readonly updatedAt: FieldRef<"customer", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * customer findUnique
   */
  export type customerFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findUniqueOrThrow
   */
  export type customerFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer findFirst
   */
  export type customerFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findFirstOrThrow
   */
  export type customerFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customer to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of customers.
     */
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer findMany
   */
  export type customerFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter, which customers to fetch.
     */
    where?: customerWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of customers to fetch.
     */
    orderBy?: customerOrderByWithRelationInput | customerOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing customers.
     */
    cursor?: customerWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` customers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` customers.
     */
    skip?: number
    distinct?: CustomerScalarFieldEnum | CustomerScalarFieldEnum[]
  }

  /**
   * customer create
   */
  export type customerCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to create a customer.
     */
    data: XOR<customerCreateInput, customerUncheckedCreateInput>
  }

  /**
   * customer createMany
   */
  export type customerCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many customers.
     */
    data: customerCreateManyInput | customerCreateManyInput[]
  }

  /**
   * customer update
   */
  export type customerUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The data needed to update a customer.
     */
    data: XOR<customerUpdateInput, customerUncheckedUpdateInput>
    /**
     * Choose, which customer to update.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer updateMany
   */
  export type customerUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update customers.
     */
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyInput>
    /**
     * Filter which customers to update
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to update.
     */
    limit?: number
  }

  /**
   * customer upsert
   */
  export type customerUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * The filter to search for the customer to update in case it exists.
     */
    where: customerWhereUniqueInput
    /**
     * In case the customer found by the `where` argument doesn't exist, create a new customer with this data.
     */
    create: XOR<customerCreateInput, customerUncheckedCreateInput>
    /**
     * In case the customer was found with the provided `where` argument, update it with this data.
     */
    update: XOR<customerUpdateInput, customerUncheckedUpdateInput>
  }

  /**
   * customer delete
   */
  export type customerDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    /**
     * Filter which customer to delete.
     */
    where: customerWhereUniqueInput
  }

  /**
   * customer deleteMany
   */
  export type customerDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which customers to delete
     */
    where?: customerWhereInput
    /**
     * Limit how many customers to delete.
     */
    limit?: number
  }

  /**
   * customer findRaw
   */
  export type customerFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * customer aggregateRaw
   */
  export type customerAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * customer.vehicle_bookings
   */
  export type customer$vehicle_bookingsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    where?: vehicle_bookingsWhereInput
    orderBy?: vehicle_bookingsOrderByWithRelationInput | vehicle_bookingsOrderByWithRelationInput[]
    cursor?: vehicle_bookingsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookingsScalarFieldEnum | Vehicle_bookingsScalarFieldEnum[]
  }

  /**
   * customer.vehicle_bookings_logs
   */
  export type customer$vehicle_bookings_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    where?: vehicle_bookings_logsWhereInput
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    cursor?: vehicle_bookings_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookings_logsScalarFieldEnum | Vehicle_bookings_logsScalarFieldEnum[]
  }

  /**
   * customer.vehicle_bookings_bills
   */
  export type customer$vehicle_bookings_billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    where?: vehicle_bookings_billsWhereInput
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    cursor?: vehicle_bookings_billsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookings_billsScalarFieldEnum | Vehicle_bookings_billsScalarFieldEnum[]
  }

  /**
   * customer without action
   */
  export type customerDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
  }


  /**
   * Model providers
   */

  export type AggregateProviders = {
    _count: ProvidersCountAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  export type ProvidersMinAggregateOutputType = {
    id: string | null
    name: string | null
    email_id: string | null
    mobile_number: string | null
    alternate_mobile_number: string | null
    address: string | null
    cityId: string | null
    stateId: string | null
    pin_code: string | null
    adhaar_number: string | null
    adhar_front_image: string | null
    adhar_back_image: string | null
    pan_number: string | null
    pan_image: string | null
    profile_image: string | null
    is_approved: boolean | null
    is_active: boolean | null
    rejection_reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvidersMaxAggregateOutputType = {
    id: string | null
    name: string | null
    email_id: string | null
    mobile_number: string | null
    alternate_mobile_number: string | null
    address: string | null
    cityId: string | null
    stateId: string | null
    pin_code: string | null
    adhaar_number: string | null
    adhar_front_image: string | null
    adhar_back_image: string | null
    pan_number: string | null
    pan_image: string | null
    profile_image: string | null
    is_approved: boolean | null
    is_active: boolean | null
    rejection_reason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ProvidersCountAggregateOutputType = {
    id: number
    name: number
    email_id: number
    mobile_number: number
    alternate_mobile_number: number
    address: number
    cityId: number
    stateId: number
    pin_code: number
    adhaar_number: number
    adhar_front_image: number
    adhar_back_image: number
    pan_number: number
    pan_image: number
    profile_image: number
    is_approved: number
    is_active: number
    rejection_reason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ProvidersMinAggregateInputType = {
    id?: true
    name?: true
    email_id?: true
    mobile_number?: true
    alternate_mobile_number?: true
    address?: true
    cityId?: true
    stateId?: true
    pin_code?: true
    adhaar_number?: true
    adhar_front_image?: true
    adhar_back_image?: true
    pan_number?: true
    pan_image?: true
    profile_image?: true
    is_approved?: true
    is_active?: true
    rejection_reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvidersMaxAggregateInputType = {
    id?: true
    name?: true
    email_id?: true
    mobile_number?: true
    alternate_mobile_number?: true
    address?: true
    cityId?: true
    stateId?: true
    pin_code?: true
    adhaar_number?: true
    adhar_front_image?: true
    adhar_back_image?: true
    pan_number?: true
    pan_image?: true
    profile_image?: true
    is_approved?: true
    is_active?: true
    rejection_reason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ProvidersCountAggregateInputType = {
    id?: true
    name?: true
    email_id?: true
    mobile_number?: true
    alternate_mobile_number?: true
    address?: true
    cityId?: true
    stateId?: true
    pin_code?: true
    adhaar_number?: true
    adhar_front_image?: true
    adhar_back_image?: true
    pan_number?: true
    pan_image?: true
    profile_image?: true
    is_approved?: true
    is_active?: true
    rejection_reason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ProvidersAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to aggregate.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned providers
    **/
    _count?: true | ProvidersCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ProvidersMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ProvidersMaxAggregateInputType
  }

  export type GetProvidersAggregateType<T extends ProvidersAggregateArgs> = {
        [P in keyof T & keyof AggregateProviders]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateProviders[P]>
      : GetScalarType<T[P], AggregateProviders[P]>
  }




  export type providersGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: providersWhereInput
    orderBy?: providersOrderByWithAggregationInput | providersOrderByWithAggregationInput[]
    by: ProvidersScalarFieldEnum[] | ProvidersScalarFieldEnum
    having?: providersScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ProvidersCountAggregateInputType | true
    _min?: ProvidersMinAggregateInputType
    _max?: ProvidersMaxAggregateInputType
  }

  export type ProvidersGroupByOutputType = {
    id: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number: string | null
    address: string
    cityId: string
    stateId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image: string | null
    is_approved: boolean
    is_active: boolean
    rejection_reason: string | null
    createdAt: Date
    updatedAt: Date
    _count: ProvidersCountAggregateOutputType | null
    _min: ProvidersMinAggregateOutputType | null
    _max: ProvidersMaxAggregateOutputType | null
  }

  type GetProvidersGroupByPayload<T extends providersGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ProvidersGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ProvidersGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
            : GetScalarType<T[P], ProvidersGroupByOutputType[P]>
        }
      >
    >


  export type providersSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    email_id?: boolean
    mobile_number?: boolean
    alternate_mobile_number?: boolean
    address?: boolean
    cityId?: boolean
    stateId?: boolean
    pin_code?: boolean
    adhaar_number?: boolean
    adhar_front_image?: boolean
    adhar_back_image?: boolean
    pan_number?: boolean
    pan_image?: boolean
    profile_image?: boolean
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    city?: boolean | citiesDefaultArgs<ExtArgs>
    state?: boolean | statesDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["providers"]>



  export type providersSelectScalar = {
    id?: boolean
    name?: boolean
    email_id?: boolean
    mobile_number?: boolean
    alternate_mobile_number?: boolean
    address?: boolean
    cityId?: boolean
    stateId?: boolean
    pin_code?: boolean
    adhaar_number?: boolean
    adhar_front_image?: boolean
    adhar_back_image?: boolean
    pan_number?: boolean
    pan_image?: boolean
    profile_image?: boolean
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type providersOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "name" | "email_id" | "mobile_number" | "alternate_mobile_number" | "address" | "cityId" | "stateId" | "pin_code" | "adhaar_number" | "adhar_front_image" | "adhar_back_image" | "pan_number" | "pan_image" | "profile_image" | "is_approved" | "is_active" | "rejection_reason" | "createdAt" | "updatedAt", ExtArgs["result"]["providers"]>
  export type providersInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    city?: boolean | citiesDefaultArgs<ExtArgs>
    state?: boolean | statesDefaultArgs<ExtArgs>
  }

  export type $providersPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "providers"
    objects: {
      city: Prisma.$citiesPayload<ExtArgs>
      state: Prisma.$statesPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      email_id: string
      mobile_number: string
      alternate_mobile_number: string | null
      address: string
      cityId: string
      stateId: string
      pin_code: string
      adhaar_number: string
      adhar_front_image: string
      adhar_back_image: string
      pan_number: string
      pan_image: string
      profile_image: string | null
      is_approved: boolean
      is_active: boolean
      rejection_reason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["providers"]>
    composites: {}
  }

  type providersGetPayload<S extends boolean | null | undefined | providersDefaultArgs> = $Result.GetResult<Prisma.$providersPayload, S>

  type providersCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<providersFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: ProvidersCountAggregateInputType | true
    }

  export interface providersDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['providers'], meta: { name: 'providers' } }
    /**
     * Find zero or one Providers that matches the filter.
     * @param {providersFindUniqueArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends providersFindUniqueArgs>(args: SelectSubset<T, providersFindUniqueArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Providers that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {providersFindUniqueOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends providersFindUniqueOrThrowArgs>(args: SelectSubset<T, providersFindUniqueOrThrowArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends providersFindFirstArgs>(args?: SelectSubset<T, providersFindFirstArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Providers that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindFirstOrThrowArgs} args - Arguments to find a Providers
     * @example
     * // Get one Providers
     * const providers = await prisma.providers.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends providersFindFirstOrThrowArgs>(args?: SelectSubset<T, providersFindFirstOrThrowArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Providers
     * const providers = await prisma.providers.findMany()
     * 
     * // Get first 10 Providers
     * const providers = await prisma.providers.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const providersWithIdOnly = await prisma.providers.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends providersFindManyArgs>(args?: SelectSubset<T, providersFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Providers.
     * @param {providersCreateArgs} args - Arguments to create a Providers.
     * @example
     * // Create one Providers
     * const Providers = await prisma.providers.create({
     *   data: {
     *     // ... data to create a Providers
     *   }
     * })
     * 
     */
    create<T extends providersCreateArgs>(args: SelectSubset<T, providersCreateArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Providers.
     * @param {providersCreateManyArgs} args - Arguments to create many Providers.
     * @example
     * // Create many Providers
     * const providers = await prisma.providers.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends providersCreateManyArgs>(args?: SelectSubset<T, providersCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Providers.
     * @param {providersDeleteArgs} args - Arguments to delete one Providers.
     * @example
     * // Delete one Providers
     * const Providers = await prisma.providers.delete({
     *   where: {
     *     // ... filter to delete one Providers
     *   }
     * })
     * 
     */
    delete<T extends providersDeleteArgs>(args: SelectSubset<T, providersDeleteArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Providers.
     * @param {providersUpdateArgs} args - Arguments to update one Providers.
     * @example
     * // Update one Providers
     * const providers = await prisma.providers.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends providersUpdateArgs>(args: SelectSubset<T, providersUpdateArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Providers.
     * @param {providersDeleteManyArgs} args - Arguments to filter Providers to delete.
     * @example
     * // Delete a few Providers
     * const { count } = await prisma.providers.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends providersDeleteManyArgs>(args?: SelectSubset<T, providersDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Providers
     * const providers = await prisma.providers.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends providersUpdateManyArgs>(args: SelectSubset<T, providersUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Providers.
     * @param {providersUpsertArgs} args - Arguments to update or create a Providers.
     * @example
     * // Update or create a Providers
     * const providers = await prisma.providers.upsert({
     *   create: {
     *     // ... data to create a Providers
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Providers we want to update
     *   }
     * })
     */
    upsert<T extends providersUpsertArgs>(args: SelectSubset<T, providersUpsertArgs<ExtArgs>>): Prisma__providersClient<$Result.GetResult<Prisma.$providersPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Providers that matches the filter.
     * @param {providersFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const providers = await prisma.providers.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: providersFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Providers.
     * @param {providersAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const providers = await prisma.providers.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: providersAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersCountArgs} args - Arguments to filter Providers to count.
     * @example
     * // Count the number of Providers
     * const count = await prisma.providers.count({
     *   where: {
     *     // ... the filter for the Providers we want to count
     *   }
     * })
    **/
    count<T extends providersCountArgs>(
      args?: Subset<T, providersCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ProvidersCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ProvidersAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ProvidersAggregateArgs>(args: Subset<T, ProvidersAggregateArgs>): Prisma.PrismaPromise<GetProvidersAggregateType<T>>

    /**
     * Group by Providers.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {providersGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends providersGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: providersGroupByArgs['orderBy'] }
        : { orderBy?: providersGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, providersGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetProvidersGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the providers model
   */
  readonly fields: providersFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for providers.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__providersClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    city<T extends citiesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, citiesDefaultArgs<ExtArgs>>): Prisma__citiesClient<$Result.GetResult<Prisma.$citiesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    state<T extends statesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, statesDefaultArgs<ExtArgs>>): Prisma__statesClient<$Result.GetResult<Prisma.$statesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the providers model
   */
  interface providersFieldRefs {
    readonly id: FieldRef<"providers", 'String'>
    readonly name: FieldRef<"providers", 'String'>
    readonly email_id: FieldRef<"providers", 'String'>
    readonly mobile_number: FieldRef<"providers", 'String'>
    readonly alternate_mobile_number: FieldRef<"providers", 'String'>
    readonly address: FieldRef<"providers", 'String'>
    readonly cityId: FieldRef<"providers", 'String'>
    readonly stateId: FieldRef<"providers", 'String'>
    readonly pin_code: FieldRef<"providers", 'String'>
    readonly adhaar_number: FieldRef<"providers", 'String'>
    readonly adhar_front_image: FieldRef<"providers", 'String'>
    readonly adhar_back_image: FieldRef<"providers", 'String'>
    readonly pan_number: FieldRef<"providers", 'String'>
    readonly pan_image: FieldRef<"providers", 'String'>
    readonly profile_image: FieldRef<"providers", 'String'>
    readonly is_approved: FieldRef<"providers", 'Boolean'>
    readonly is_active: FieldRef<"providers", 'Boolean'>
    readonly rejection_reason: FieldRef<"providers", 'String'>
    readonly createdAt: FieldRef<"providers", 'DateTime'>
    readonly updatedAt: FieldRef<"providers", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * providers findUnique
   */
  export type providersFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findUniqueOrThrow
   */
  export type providersFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers findFirst
   */
  export type providersFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers findFirstOrThrow
   */
  export type providersFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of providers.
     */
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers findMany
   */
  export type providersFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter, which providers to fetch.
     */
    where?: providersWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of providers to fetch.
     */
    orderBy?: providersOrderByWithRelationInput | providersOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing providers.
     */
    cursor?: providersWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` providers from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` providers.
     */
    skip?: number
    distinct?: ProvidersScalarFieldEnum | ProvidersScalarFieldEnum[]
  }

  /**
   * providers create
   */
  export type providersCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The data needed to create a providers.
     */
    data: XOR<providersCreateInput, providersUncheckedCreateInput>
  }

  /**
   * providers createMany
   */
  export type providersCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many providers.
     */
    data: providersCreateManyInput | providersCreateManyInput[]
  }

  /**
   * providers update
   */
  export type providersUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The data needed to update a providers.
     */
    data: XOR<providersUpdateInput, providersUncheckedUpdateInput>
    /**
     * Choose, which providers to update.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers updateMany
   */
  export type providersUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update providers.
     */
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyInput>
    /**
     * Filter which providers to update
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to update.
     */
    limit?: number
  }

  /**
   * providers upsert
   */
  export type providersUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * The filter to search for the providers to update in case it exists.
     */
    where: providersWhereUniqueInput
    /**
     * In case the providers found by the `where` argument doesn't exist, create a new providers with this data.
     */
    create: XOR<providersCreateInput, providersUncheckedCreateInput>
    /**
     * In case the providers was found with the provided `where` argument, update it with this data.
     */
    update: XOR<providersUpdateInput, providersUncheckedUpdateInput>
  }

  /**
   * providers delete
   */
  export type providersDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
    /**
     * Filter which providers to delete.
     */
    where: providersWhereUniqueInput
  }

  /**
   * providers deleteMany
   */
  export type providersDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which providers to delete
     */
    where?: providersWhereInput
    /**
     * Limit how many providers to delete.
     */
    limit?: number
  }

  /**
   * providers findRaw
   */
  export type providersFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * providers aggregateRaw
   */
  export type providersAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * providers without action
   */
  export type providersDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the providers
     */
    select?: providersSelect<ExtArgs> | null
    /**
     * Omit specific fields from the providers
     */
    omit?: providersOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: providersInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_bookings
   */

  export type AggregateVehicle_bookings = {
    _count: Vehicle_bookingsCountAggregateOutputType | null
    _min: Vehicle_bookingsMinAggregateOutputType | null
    _max: Vehicle_bookingsMaxAggregateOutputType | null
  }

  export type Vehicle_bookingsMinAggregateOutputType = {
    id: string | null
    booking_number: string | null
    vehicle_id: string | null
    customer_id: string | null
    start_time: Date | null
    end_time: Date | null
    booking_status_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_bookingsMaxAggregateOutputType = {
    id: string | null
    booking_number: string | null
    vehicle_id: string | null
    customer_id: string | null
    start_time: Date | null
    end_time: Date | null
    booking_status_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_bookingsCountAggregateOutputType = {
    id: number
    booking_number: number
    vehicle_id: number
    customer_id: number
    start_time: number
    end_time: number
    booking_status_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_bookingsMinAggregateInputType = {
    id?: true
    booking_number?: true
    vehicle_id?: true
    customer_id?: true
    start_time?: true
    end_time?: true
    booking_status_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_bookingsMaxAggregateInputType = {
    id?: true
    booking_number?: true
    vehicle_id?: true
    customer_id?: true
    start_time?: true
    end_time?: true
    booking_status_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_bookingsCountAggregateInputType = {
    id?: true
    booking_number?: true
    vehicle_id?: true
    customer_id?: true
    start_time?: true
    end_time?: true
    booking_status_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_bookingsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_bookings to aggregate.
     */
    where?: vehicle_bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings to fetch.
     */
    orderBy?: vehicle_bookingsOrderByWithRelationInput | vehicle_bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_bookings
    **/
    _count?: true | Vehicle_bookingsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_bookingsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_bookingsMaxAggregateInputType
  }

  export type GetVehicle_bookingsAggregateType<T extends Vehicle_bookingsAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_bookings]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_bookings[P]>
      : GetScalarType<T[P], AggregateVehicle_bookings[P]>
  }




  export type vehicle_bookingsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookingsWhereInput
    orderBy?: vehicle_bookingsOrderByWithAggregationInput | vehicle_bookingsOrderByWithAggregationInput[]
    by: Vehicle_bookingsScalarFieldEnum[] | Vehicle_bookingsScalarFieldEnum
    having?: vehicle_bookingsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_bookingsCountAggregateInputType | true
    _min?: Vehicle_bookingsMinAggregateInputType
    _max?: Vehicle_bookingsMaxAggregateInputType
  }

  export type Vehicle_bookingsGroupByOutputType = {
    id: string
    booking_number: string
    vehicle_id: string
    customer_id: string
    start_time: Date
    end_time: Date
    booking_status_id: string | null
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_bookingsCountAggregateOutputType | null
    _min: Vehicle_bookingsMinAggregateOutputType | null
    _max: Vehicle_bookingsMaxAggregateOutputType | null
  }

  type GetVehicle_bookingsGroupByPayload<T extends vehicle_bookingsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_bookingsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_bookingsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_bookingsGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_bookingsGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_bookingsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    booking_number?: boolean
    vehicle_id?: boolean
    customer_id?: boolean
    start_time?: boolean
    end_time?: boolean
    booking_status_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
    vehicle_inspection?: boolean | vehicle_bookings$vehicle_inspectionArgs<ExtArgs>
    booking_logs?: boolean | vehicle_bookings$booking_logsArgs<ExtArgs>
    bills?: boolean | vehicle_bookings$billsArgs<ExtArgs>
    _count?: boolean | Vehicle_bookingsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_bookings"]>



  export type vehicle_bookingsSelectScalar = {
    id?: boolean
    booking_number?: boolean
    vehicle_id?: boolean
    customer_id?: boolean
    start_time?: boolean
    end_time?: boolean
    booking_status_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_bookingsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "booking_number" | "vehicle_id" | "customer_id" | "start_time" | "end_time" | "booking_status_id" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_bookings"]>
  export type vehicle_bookingsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicleDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
    vehicle_inspection?: boolean | vehicle_bookings$vehicle_inspectionArgs<ExtArgs>
    booking_logs?: boolean | vehicle_bookings$booking_logsArgs<ExtArgs>
    bills?: boolean | vehicle_bookings$billsArgs<ExtArgs>
    _count?: boolean | Vehicle_bookingsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $vehicle_bookingsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_bookings"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs>
      vehicle_inspection: Prisma.$vehicle_inspectionPayload<ExtArgs>[]
      booking_logs: Prisma.$vehicle_bookings_logsPayload<ExtArgs>[]
      bills: Prisma.$vehicle_bookings_billsPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      booking_number: string
      vehicle_id: string
      customer_id: string
      start_time: Date
      end_time: Date
      booking_status_id: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_bookings"]>
    composites: {}
  }

  type vehicle_bookingsGetPayload<S extends boolean | null | undefined | vehicle_bookingsDefaultArgs> = $Result.GetResult<Prisma.$vehicle_bookingsPayload, S>

  type vehicle_bookingsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_bookingsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_bookingsCountAggregateInputType | true
    }

  export interface vehicle_bookingsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_bookings'], meta: { name: 'vehicle_bookings' } }
    /**
     * Find zero or one Vehicle_bookings that matches the filter.
     * @param {vehicle_bookingsFindUniqueArgs} args - Arguments to find a Vehicle_bookings
     * @example
     * // Get one Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_bookingsFindUniqueArgs>(args: SelectSubset<T, vehicle_bookingsFindUniqueArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_bookings that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_bookingsFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_bookings
     * @example
     * // Get one Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_bookingsFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_bookingsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookingsFindFirstArgs} args - Arguments to find a Vehicle_bookings
     * @example
     * // Get one Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_bookingsFindFirstArgs>(args?: SelectSubset<T, vehicle_bookingsFindFirstArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_bookings that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookingsFindFirstOrThrowArgs} args - Arguments to find a Vehicle_bookings
     * @example
     * // Get one Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_bookingsFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_bookingsFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_bookings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookingsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.findMany()
     * 
     * // Get first 10 Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_bookingsWithIdOnly = await prisma.vehicle_bookings.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_bookingsFindManyArgs>(args?: SelectSubset<T, vehicle_bookingsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_bookings.
     * @param {vehicle_bookingsCreateArgs} args - Arguments to create a Vehicle_bookings.
     * @example
     * // Create one Vehicle_bookings
     * const Vehicle_bookings = await prisma.vehicle_bookings.create({
     *   data: {
     *     // ... data to create a Vehicle_bookings
     *   }
     * })
     * 
     */
    create<T extends vehicle_bookingsCreateArgs>(args: SelectSubset<T, vehicle_bookingsCreateArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_bookings.
     * @param {vehicle_bookingsCreateManyArgs} args - Arguments to create many Vehicle_bookings.
     * @example
     * // Create many Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_bookingsCreateManyArgs>(args?: SelectSubset<T, vehicle_bookingsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_bookings.
     * @param {vehicle_bookingsDeleteArgs} args - Arguments to delete one Vehicle_bookings.
     * @example
     * // Delete one Vehicle_bookings
     * const Vehicle_bookings = await prisma.vehicle_bookings.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_bookings
     *   }
     * })
     * 
     */
    delete<T extends vehicle_bookingsDeleteArgs>(args: SelectSubset<T, vehicle_bookingsDeleteArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_bookings.
     * @param {vehicle_bookingsUpdateArgs} args - Arguments to update one Vehicle_bookings.
     * @example
     * // Update one Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_bookingsUpdateArgs>(args: SelectSubset<T, vehicle_bookingsUpdateArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_bookings.
     * @param {vehicle_bookingsDeleteManyArgs} args - Arguments to filter Vehicle_bookings to delete.
     * @example
     * // Delete a few Vehicle_bookings
     * const { count } = await prisma.vehicle_bookings.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_bookingsDeleteManyArgs>(args?: SelectSubset<T, vehicle_bookingsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookingsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_bookingsUpdateManyArgs>(args: SelectSubset<T, vehicle_bookingsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_bookings.
     * @param {vehicle_bookingsUpsertArgs} args - Arguments to update or create a Vehicle_bookings.
     * @example
     * // Update or create a Vehicle_bookings
     * const vehicle_bookings = await prisma.vehicle_bookings.upsert({
     *   create: {
     *     // ... data to create a Vehicle_bookings
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_bookings we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_bookingsUpsertArgs>(args: SelectSubset<T, vehicle_bookingsUpsertArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_bookings that matches the filter.
     * @param {vehicle_bookingsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_bookings = await prisma.vehicle_bookings.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_bookingsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_bookings.
     * @param {vehicle_bookingsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_bookings = await prisma.vehicle_bookings.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_bookingsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookingsCountArgs} args - Arguments to filter Vehicle_bookings to count.
     * @example
     * // Count the number of Vehicle_bookings
     * const count = await prisma.vehicle_bookings.count({
     *   where: {
     *     // ... the filter for the Vehicle_bookings we want to count
     *   }
     * })
    **/
    count<T extends vehicle_bookingsCountArgs>(
      args?: Subset<T, vehicle_bookingsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_bookingsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_bookingsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_bookingsAggregateArgs>(args: Subset<T, Vehicle_bookingsAggregateArgs>): Prisma.PrismaPromise<GetVehicle_bookingsAggregateType<T>>

    /**
     * Group by Vehicle_bookings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookingsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_bookingsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_bookingsGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_bookingsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_bookingsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_bookingsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_bookings model
   */
  readonly fields: vehicle_bookingsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_bookings.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_bookingsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicleDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicleDefaultArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_inspection<T extends vehicle_bookings$vehicle_inspectionArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings$vehicle_inspectionArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_inspectionPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    booking_logs<T extends vehicle_bookings$booking_logsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings$booking_logsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    bills<T extends vehicle_bookings$billsArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings$billsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_bookings model
   */
  interface vehicle_bookingsFieldRefs {
    readonly id: FieldRef<"vehicle_bookings", 'String'>
    readonly booking_number: FieldRef<"vehicle_bookings", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_bookings", 'String'>
    readonly customer_id: FieldRef<"vehicle_bookings", 'String'>
    readonly start_time: FieldRef<"vehicle_bookings", 'DateTime'>
    readonly end_time: FieldRef<"vehicle_bookings", 'DateTime'>
    readonly booking_status_id: FieldRef<"vehicle_bookings", 'String'>
    readonly createdAt: FieldRef<"vehicle_bookings", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_bookings", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_bookings findUnique
   */
  export type vehicle_bookingsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings to fetch.
     */
    where: vehicle_bookingsWhereUniqueInput
  }

  /**
   * vehicle_bookings findUniqueOrThrow
   */
  export type vehicle_bookingsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings to fetch.
     */
    where: vehicle_bookingsWhereUniqueInput
  }

  /**
   * vehicle_bookings findFirst
   */
  export type vehicle_bookingsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings to fetch.
     */
    where?: vehicle_bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings to fetch.
     */
    orderBy?: vehicle_bookingsOrderByWithRelationInput | vehicle_bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_bookings.
     */
    cursor?: vehicle_bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_bookings.
     */
    distinct?: Vehicle_bookingsScalarFieldEnum | Vehicle_bookingsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings findFirstOrThrow
   */
  export type vehicle_bookingsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings to fetch.
     */
    where?: vehicle_bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings to fetch.
     */
    orderBy?: vehicle_bookingsOrderByWithRelationInput | vehicle_bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_bookings.
     */
    cursor?: vehicle_bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_bookings.
     */
    distinct?: Vehicle_bookingsScalarFieldEnum | Vehicle_bookingsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings findMany
   */
  export type vehicle_bookingsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings to fetch.
     */
    where?: vehicle_bookingsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings to fetch.
     */
    orderBy?: vehicle_bookingsOrderByWithRelationInput | vehicle_bookingsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_bookings.
     */
    cursor?: vehicle_bookingsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings.
     */
    skip?: number
    distinct?: Vehicle_bookingsScalarFieldEnum | Vehicle_bookingsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings create
   */
  export type vehicle_bookingsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_bookings.
     */
    data: XOR<vehicle_bookingsCreateInput, vehicle_bookingsUncheckedCreateInput>
  }

  /**
   * vehicle_bookings createMany
   */
  export type vehicle_bookingsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_bookings.
     */
    data: vehicle_bookingsCreateManyInput | vehicle_bookingsCreateManyInput[]
  }

  /**
   * vehicle_bookings update
   */
  export type vehicle_bookingsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_bookings.
     */
    data: XOR<vehicle_bookingsUpdateInput, vehicle_bookingsUncheckedUpdateInput>
    /**
     * Choose, which vehicle_bookings to update.
     */
    where: vehicle_bookingsWhereUniqueInput
  }

  /**
   * vehicle_bookings updateMany
   */
  export type vehicle_bookingsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_bookings.
     */
    data: XOR<vehicle_bookingsUpdateManyMutationInput, vehicle_bookingsUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_bookings to update
     */
    where?: vehicle_bookingsWhereInput
    /**
     * Limit how many vehicle_bookings to update.
     */
    limit?: number
  }

  /**
   * vehicle_bookings upsert
   */
  export type vehicle_bookingsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_bookings to update in case it exists.
     */
    where: vehicle_bookingsWhereUniqueInput
    /**
     * In case the vehicle_bookings found by the `where` argument doesn't exist, create a new vehicle_bookings with this data.
     */
    create: XOR<vehicle_bookingsCreateInput, vehicle_bookingsUncheckedCreateInput>
    /**
     * In case the vehicle_bookings was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_bookingsUpdateInput, vehicle_bookingsUncheckedUpdateInput>
  }

  /**
   * vehicle_bookings delete
   */
  export type vehicle_bookingsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    /**
     * Filter which vehicle_bookings to delete.
     */
    where: vehicle_bookingsWhereUniqueInput
  }

  /**
   * vehicle_bookings deleteMany
   */
  export type vehicle_bookingsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_bookings to delete
     */
    where?: vehicle_bookingsWhereInput
    /**
     * Limit how many vehicle_bookings to delete.
     */
    limit?: number
  }

  /**
   * vehicle_bookings findRaw
   */
  export type vehicle_bookingsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_bookings aggregateRaw
   */
  export type vehicle_bookingsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_bookings.vehicle_inspection
   */
  export type vehicle_bookings$vehicle_inspectionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_inspection
     */
    select?: vehicle_inspectionSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_inspection
     */
    omit?: vehicle_inspectionOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_inspectionInclude<ExtArgs> | null
    where?: vehicle_inspectionWhereInput
    orderBy?: vehicle_inspectionOrderByWithRelationInput | vehicle_inspectionOrderByWithRelationInput[]
    cursor?: vehicle_inspectionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_inspectionScalarFieldEnum | Vehicle_inspectionScalarFieldEnum[]
  }

  /**
   * vehicle_bookings.booking_logs
   */
  export type vehicle_bookings$booking_logsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    where?: vehicle_bookings_logsWhereInput
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    cursor?: vehicle_bookings_logsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookings_logsScalarFieldEnum | Vehicle_bookings_logsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings.bills
   */
  export type vehicle_bookings$billsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    where?: vehicle_bookings_billsWhereInput
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    cursor?: vehicle_bookings_billsWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Vehicle_bookings_billsScalarFieldEnum | Vehicle_bookings_billsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings without action
   */
  export type vehicle_bookingsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_bookings_logs
   */

  export type AggregateVehicle_bookings_logs = {
    _count: Vehicle_bookings_logsCountAggregateOutputType | null
    _min: Vehicle_bookings_logsMinAggregateOutputType | null
    _max: Vehicle_bookings_logsMaxAggregateOutputType | null
  }

  export type Vehicle_bookings_logsMinAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    vehicle_booking_id: string | null
    booking_number: string | null
    start_time: Date | null
    end_time: Date | null
    customer_id: string | null
    booking_status_id: string | null
    logged_time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_bookings_logsMaxAggregateOutputType = {
    id: string | null
    vehicle_id: string | null
    vehicle_booking_id: string | null
    booking_number: string | null
    start_time: Date | null
    end_time: Date | null
    customer_id: string | null
    booking_status_id: string | null
    logged_time: Date | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_bookings_logsCountAggregateOutputType = {
    id: number
    vehicle_id: number
    vehicle_booking_id: number
    booking_number: number
    start_time: number
    end_time: number
    customer_id: number
    booking_status_id: number
    logged_time: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_bookings_logsMinAggregateInputType = {
    id?: true
    vehicle_id?: true
    vehicle_booking_id?: true
    booking_number?: true
    start_time?: true
    end_time?: true
    customer_id?: true
    booking_status_id?: true
    logged_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_bookings_logsMaxAggregateInputType = {
    id?: true
    vehicle_id?: true
    vehicle_booking_id?: true
    booking_number?: true
    start_time?: true
    end_time?: true
    customer_id?: true
    booking_status_id?: true
    logged_time?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_bookings_logsCountAggregateInputType = {
    id?: true
    vehicle_id?: true
    vehicle_booking_id?: true
    booking_number?: true
    start_time?: true
    end_time?: true
    customer_id?: true
    booking_status_id?: true
    logged_time?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_bookings_logsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_bookings_logs to aggregate.
     */
    where?: vehicle_bookings_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_logs to fetch.
     */
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_bookings_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_bookings_logs
    **/
    _count?: true | Vehicle_bookings_logsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_bookings_logsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_bookings_logsMaxAggregateInputType
  }

  export type GetVehicle_bookings_logsAggregateType<T extends Vehicle_bookings_logsAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_bookings_logs]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_bookings_logs[P]>
      : GetScalarType<T[P], AggregateVehicle_bookings_logs[P]>
  }




  export type vehicle_bookings_logsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_logsWhereInput
    orderBy?: vehicle_bookings_logsOrderByWithAggregationInput | vehicle_bookings_logsOrderByWithAggregationInput[]
    by: Vehicle_bookings_logsScalarFieldEnum[] | Vehicle_bookings_logsScalarFieldEnum
    having?: vehicle_bookings_logsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_bookings_logsCountAggregateInputType | true
    _min?: Vehicle_bookings_logsMinAggregateInputType
    _max?: Vehicle_bookings_logsMaxAggregateInputType
  }

  export type Vehicle_bookings_logsGroupByOutputType = {
    id: string
    vehicle_id: string | null
    vehicle_booking_id: string | null
    booking_number: string | null
    start_time: Date
    end_time: Date
    customer_id: string | null
    booking_status_id: string | null
    logged_time: Date
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_bookings_logsCountAggregateOutputType | null
    _min: Vehicle_bookings_logsMinAggregateOutputType | null
    _max: Vehicle_bookings_logsMaxAggregateOutputType | null
  }

  type GetVehicle_bookings_logsGroupByPayload<T extends vehicle_bookings_logsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_bookings_logsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_bookings_logsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_bookings_logsGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_bookings_logsGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_bookings_logsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_id?: boolean
    vehicle_booking_id?: boolean
    booking_number?: boolean
    start_time?: boolean
    end_time?: boolean
    customer_id?: boolean
    booking_status_id?: boolean
    logged_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle?: boolean | vehicle_bookings_logs$vehicleArgs<ExtArgs>
    vehicle_booking?: boolean | vehicle_bookings_logs$vehicle_bookingArgs<ExtArgs>
    customer?: boolean | vehicle_bookings_logs$customerArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_bookings_logs"]>



  export type vehicle_bookings_logsSelectScalar = {
    id?: boolean
    vehicle_id?: boolean
    vehicle_booking_id?: boolean
    booking_number?: boolean
    start_time?: boolean
    end_time?: boolean
    customer_id?: boolean
    booking_status_id?: boolean
    logged_time?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_bookings_logsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_id" | "vehicle_booking_id" | "booking_number" | "start_time" | "end_time" | "customer_id" | "booking_status_id" | "logged_time" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_bookings_logs"]>
  export type vehicle_bookings_logsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle?: boolean | vehicle_bookings_logs$vehicleArgs<ExtArgs>
    vehicle_booking?: boolean | vehicle_bookings_logs$vehicle_bookingArgs<ExtArgs>
    customer?: boolean | vehicle_bookings_logs$customerArgs<ExtArgs>
  }

  export type $vehicle_bookings_logsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_bookings_logs"
    objects: {
      vehicle: Prisma.$vehiclePayload<ExtArgs> | null
      vehicle_booking: Prisma.$vehicle_bookingsPayload<ExtArgs> | null
      customer: Prisma.$customerPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_id: string | null
      vehicle_booking_id: string | null
      booking_number: string | null
      start_time: Date
      end_time: Date
      customer_id: string | null
      booking_status_id: string | null
      logged_time: Date
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_bookings_logs"]>
    composites: {}
  }

  type vehicle_bookings_logsGetPayload<S extends boolean | null | undefined | vehicle_bookings_logsDefaultArgs> = $Result.GetResult<Prisma.$vehicle_bookings_logsPayload, S>

  type vehicle_bookings_logsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_bookings_logsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_bookings_logsCountAggregateInputType | true
    }

  export interface vehicle_bookings_logsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_bookings_logs'], meta: { name: 'vehicle_bookings_logs' } }
    /**
     * Find zero or one Vehicle_bookings_logs that matches the filter.
     * @param {vehicle_bookings_logsFindUniqueArgs} args - Arguments to find a Vehicle_bookings_logs
     * @example
     * // Get one Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_bookings_logsFindUniqueArgs>(args: SelectSubset<T, vehicle_bookings_logsFindUniqueArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_bookings_logs that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_bookings_logsFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_bookings_logs
     * @example
     * // Get one Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_bookings_logsFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_bookings_logsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_bookings_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_logsFindFirstArgs} args - Arguments to find a Vehicle_bookings_logs
     * @example
     * // Get one Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_bookings_logsFindFirstArgs>(args?: SelectSubset<T, vehicle_bookings_logsFindFirstArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_bookings_logs that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_logsFindFirstOrThrowArgs} args - Arguments to find a Vehicle_bookings_logs
     * @example
     * // Get one Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_bookings_logsFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_bookings_logsFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_bookings_logs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_logsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findMany()
     * 
     * // Get first 10 Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_bookings_logsWithIdOnly = await prisma.vehicle_bookings_logs.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_bookings_logsFindManyArgs>(args?: SelectSubset<T, vehicle_bookings_logsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsCreateArgs} args - Arguments to create a Vehicle_bookings_logs.
     * @example
     * // Create one Vehicle_bookings_logs
     * const Vehicle_bookings_logs = await prisma.vehicle_bookings_logs.create({
     *   data: {
     *     // ... data to create a Vehicle_bookings_logs
     *   }
     * })
     * 
     */
    create<T extends vehicle_bookings_logsCreateArgs>(args: SelectSubset<T, vehicle_bookings_logsCreateArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsCreateManyArgs} args - Arguments to create many Vehicle_bookings_logs.
     * @example
     * // Create many Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_bookings_logsCreateManyArgs>(args?: SelectSubset<T, vehicle_bookings_logsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsDeleteArgs} args - Arguments to delete one Vehicle_bookings_logs.
     * @example
     * // Delete one Vehicle_bookings_logs
     * const Vehicle_bookings_logs = await prisma.vehicle_bookings_logs.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_bookings_logs
     *   }
     * })
     * 
     */
    delete<T extends vehicle_bookings_logsDeleteArgs>(args: SelectSubset<T, vehicle_bookings_logsDeleteArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsUpdateArgs} args - Arguments to update one Vehicle_bookings_logs.
     * @example
     * // Update one Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_bookings_logsUpdateArgs>(args: SelectSubset<T, vehicle_bookings_logsUpdateArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsDeleteManyArgs} args - Arguments to filter Vehicle_bookings_logs to delete.
     * @example
     * // Delete a few Vehicle_bookings_logs
     * const { count } = await prisma.vehicle_bookings_logs.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_bookings_logsDeleteManyArgs>(args?: SelectSubset<T, vehicle_bookings_logsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_bookings_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_logsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_bookings_logsUpdateManyArgs>(args: SelectSubset<T, vehicle_bookings_logsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsUpsertArgs} args - Arguments to update or create a Vehicle_bookings_logs.
     * @example
     * // Update or create a Vehicle_bookings_logs
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.upsert({
     *   create: {
     *     // ... data to create a Vehicle_bookings_logs
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_bookings_logs we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_bookings_logsUpsertArgs>(args: SelectSubset<T, vehicle_bookings_logsUpsertArgs<ExtArgs>>): Prisma__vehicle_bookings_logsClient<$Result.GetResult<Prisma.$vehicle_bookings_logsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_bookings_logs that matches the filter.
     * @param {vehicle_bookings_logsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_bookings_logsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_bookings_logs.
     * @param {vehicle_bookings_logsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_bookings_logs = await prisma.vehicle_bookings_logs.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_bookings_logsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_bookings_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_logsCountArgs} args - Arguments to filter Vehicle_bookings_logs to count.
     * @example
     * // Count the number of Vehicle_bookings_logs
     * const count = await prisma.vehicle_bookings_logs.count({
     *   where: {
     *     // ... the filter for the Vehicle_bookings_logs we want to count
     *   }
     * })
    **/
    count<T extends vehicle_bookings_logsCountArgs>(
      args?: Subset<T, vehicle_bookings_logsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_bookings_logsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_bookings_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_bookings_logsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_bookings_logsAggregateArgs>(args: Subset<T, Vehicle_bookings_logsAggregateArgs>): Prisma.PrismaPromise<GetVehicle_bookings_logsAggregateType<T>>

    /**
     * Group by Vehicle_bookings_logs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_logsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_bookings_logsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_bookings_logsGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_bookings_logsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_bookings_logsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_bookings_logsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_bookings_logs model
   */
  readonly fields: vehicle_bookings_logsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_bookings_logs.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_bookings_logsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle<T extends vehicle_bookings_logs$vehicleArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings_logs$vehicleArgs<ExtArgs>>): Prisma__vehicleClient<$Result.GetResult<Prisma.$vehiclePayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    vehicle_booking<T extends vehicle_bookings_logs$vehicle_bookingArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings_logs$vehicle_bookingArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    customer<T extends vehicle_bookings_logs$customerArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings_logs$customerArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_bookings_logs model
   */
  interface vehicle_bookings_logsFieldRefs {
    readonly id: FieldRef<"vehicle_bookings_logs", 'String'>
    readonly vehicle_id: FieldRef<"vehicle_bookings_logs", 'String'>
    readonly vehicle_booking_id: FieldRef<"vehicle_bookings_logs", 'String'>
    readonly booking_number: FieldRef<"vehicle_bookings_logs", 'String'>
    readonly start_time: FieldRef<"vehicle_bookings_logs", 'DateTime'>
    readonly end_time: FieldRef<"vehicle_bookings_logs", 'DateTime'>
    readonly customer_id: FieldRef<"vehicle_bookings_logs", 'String'>
    readonly booking_status_id: FieldRef<"vehicle_bookings_logs", 'String'>
    readonly logged_time: FieldRef<"vehicle_bookings_logs", 'DateTime'>
    readonly createdAt: FieldRef<"vehicle_bookings_logs", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_bookings_logs", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_bookings_logs findUnique
   */
  export type vehicle_bookings_logsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_logs to fetch.
     */
    where: vehicle_bookings_logsWhereUniqueInput
  }

  /**
   * vehicle_bookings_logs findUniqueOrThrow
   */
  export type vehicle_bookings_logsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_logs to fetch.
     */
    where: vehicle_bookings_logsWhereUniqueInput
  }

  /**
   * vehicle_bookings_logs findFirst
   */
  export type vehicle_bookings_logsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_logs to fetch.
     */
    where?: vehicle_bookings_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_logs to fetch.
     */
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_bookings_logs.
     */
    cursor?: vehicle_bookings_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_bookings_logs.
     */
    distinct?: Vehicle_bookings_logsScalarFieldEnum | Vehicle_bookings_logsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_logs findFirstOrThrow
   */
  export type vehicle_bookings_logsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_logs to fetch.
     */
    where?: vehicle_bookings_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_logs to fetch.
     */
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_bookings_logs.
     */
    cursor?: vehicle_bookings_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_logs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_bookings_logs.
     */
    distinct?: Vehicle_bookings_logsScalarFieldEnum | Vehicle_bookings_logsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_logs findMany
   */
  export type vehicle_bookings_logsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_logs to fetch.
     */
    where?: vehicle_bookings_logsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_logs to fetch.
     */
    orderBy?: vehicle_bookings_logsOrderByWithRelationInput | vehicle_bookings_logsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_bookings_logs.
     */
    cursor?: vehicle_bookings_logsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_logs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_logs.
     */
    skip?: number
    distinct?: Vehicle_bookings_logsScalarFieldEnum | Vehicle_bookings_logsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_logs create
   */
  export type vehicle_bookings_logsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_bookings_logs.
     */
    data: XOR<vehicle_bookings_logsCreateInput, vehicle_bookings_logsUncheckedCreateInput>
  }

  /**
   * vehicle_bookings_logs createMany
   */
  export type vehicle_bookings_logsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_bookings_logs.
     */
    data: vehicle_bookings_logsCreateManyInput | vehicle_bookings_logsCreateManyInput[]
  }

  /**
   * vehicle_bookings_logs update
   */
  export type vehicle_bookings_logsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_bookings_logs.
     */
    data: XOR<vehicle_bookings_logsUpdateInput, vehicle_bookings_logsUncheckedUpdateInput>
    /**
     * Choose, which vehicle_bookings_logs to update.
     */
    where: vehicle_bookings_logsWhereUniqueInput
  }

  /**
   * vehicle_bookings_logs updateMany
   */
  export type vehicle_bookings_logsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_bookings_logs.
     */
    data: XOR<vehicle_bookings_logsUpdateManyMutationInput, vehicle_bookings_logsUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_bookings_logs to update
     */
    where?: vehicle_bookings_logsWhereInput
    /**
     * Limit how many vehicle_bookings_logs to update.
     */
    limit?: number
  }

  /**
   * vehicle_bookings_logs upsert
   */
  export type vehicle_bookings_logsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_bookings_logs to update in case it exists.
     */
    where: vehicle_bookings_logsWhereUniqueInput
    /**
     * In case the vehicle_bookings_logs found by the `where` argument doesn't exist, create a new vehicle_bookings_logs with this data.
     */
    create: XOR<vehicle_bookings_logsCreateInput, vehicle_bookings_logsUncheckedCreateInput>
    /**
     * In case the vehicle_bookings_logs was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_bookings_logsUpdateInput, vehicle_bookings_logsUncheckedUpdateInput>
  }

  /**
   * vehicle_bookings_logs delete
   */
  export type vehicle_bookings_logsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
    /**
     * Filter which vehicle_bookings_logs to delete.
     */
    where: vehicle_bookings_logsWhereUniqueInput
  }

  /**
   * vehicle_bookings_logs deleteMany
   */
  export type vehicle_bookings_logsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_bookings_logs to delete
     */
    where?: vehicle_bookings_logsWhereInput
    /**
     * Limit how many vehicle_bookings_logs to delete.
     */
    limit?: number
  }

  /**
   * vehicle_bookings_logs findRaw
   */
  export type vehicle_bookings_logsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_bookings_logs aggregateRaw
   */
  export type vehicle_bookings_logsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_bookings_logs.vehicle
   */
  export type vehicle_bookings_logs$vehicleArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle
     */
    select?: vehicleSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle
     */
    omit?: vehicleOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicleInclude<ExtArgs> | null
    where?: vehicleWhereInput
  }

  /**
   * vehicle_bookings_logs.vehicle_booking
   */
  export type vehicle_bookings_logs$vehicle_bookingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings
     */
    select?: vehicle_bookingsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings
     */
    omit?: vehicle_bookingsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookingsInclude<ExtArgs> | null
    where?: vehicle_bookingsWhereInput
  }

  /**
   * vehicle_bookings_logs.customer
   */
  export type vehicle_bookings_logs$customerArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the customer
     */
    select?: customerSelect<ExtArgs> | null
    /**
     * Omit specific fields from the customer
     */
    omit?: customerOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: customerInclude<ExtArgs> | null
    where?: customerWhereInput
  }

  /**
   * vehicle_bookings_logs without action
   */
  export type vehicle_bookings_logsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_logs
     */
    select?: vehicle_bookings_logsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_logs
     */
    omit?: vehicle_bookings_logsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_logsInclude<ExtArgs> | null
  }


  /**
   * Model vehicle_bookings_bills
   */

  export type AggregateVehicle_bookings_bills = {
    _count: Vehicle_bookings_billsCountAggregateOutputType | null
    _avg: Vehicle_bookings_billsAvgAggregateOutputType | null
    _sum: Vehicle_bookings_billsSumAggregateOutputType | null
    _min: Vehicle_bookings_billsMinAggregateOutputType | null
    _max: Vehicle_bookings_billsMaxAggregateOutputType | null
  }

  export type Vehicle_bookings_billsAvgAggregateOutputType = {
    base_price: number | null
    total_price: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
  }

  export type Vehicle_bookings_billsSumAggregateOutputType = {
    base_price: number | null
    total_price: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
  }

  export type Vehicle_bookings_billsMinAggregateOutputType = {
    id: string | null
    vehicle_booking_id: string | null
    base_price: number | null
    vehicle_price_id: string | null
    total_price: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
    customer_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_bookings_billsMaxAggregateOutputType = {
    id: string | null
    vehicle_booking_id: string | null
    base_price: number | null
    vehicle_price_id: string | null
    total_price: number | null
    extra_km_charge: number | null
    extra_hr_charge: number | null
    customer_id: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Vehicle_bookings_billsCountAggregateOutputType = {
    id: number
    vehicle_booking_id: number
    base_price: number
    vehicle_price_id: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Vehicle_bookings_billsAvgAggregateInputType = {
    base_price?: true
    total_price?: true
    extra_km_charge?: true
    extra_hr_charge?: true
  }

  export type Vehicle_bookings_billsSumAggregateInputType = {
    base_price?: true
    total_price?: true
    extra_km_charge?: true
    extra_hr_charge?: true
  }

  export type Vehicle_bookings_billsMinAggregateInputType = {
    id?: true
    vehicle_booking_id?: true
    base_price?: true
    vehicle_price_id?: true
    total_price?: true
    extra_km_charge?: true
    extra_hr_charge?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_bookings_billsMaxAggregateInputType = {
    id?: true
    vehicle_booking_id?: true
    base_price?: true
    vehicle_price_id?: true
    total_price?: true
    extra_km_charge?: true
    extra_hr_charge?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Vehicle_bookings_billsCountAggregateInputType = {
    id?: true
    vehicle_booking_id?: true
    base_price?: true
    vehicle_price_id?: true
    total_price?: true
    extra_km_charge?: true
    extra_hr_charge?: true
    customer_id?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Vehicle_bookings_billsAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_bookings_bills to aggregate.
     */
    where?: vehicle_bookings_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_bills to fetch.
     */
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: vehicle_bookings_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned vehicle_bookings_bills
    **/
    _count?: true | Vehicle_bookings_billsCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Vehicle_bookings_billsAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Vehicle_bookings_billsSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Vehicle_bookings_billsMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Vehicle_bookings_billsMaxAggregateInputType
  }

  export type GetVehicle_bookings_billsAggregateType<T extends Vehicle_bookings_billsAggregateArgs> = {
        [P in keyof T & keyof AggregateVehicle_bookings_bills]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateVehicle_bookings_bills[P]>
      : GetScalarType<T[P], AggregateVehicle_bookings_bills[P]>
  }




  export type vehicle_bookings_billsGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: vehicle_bookings_billsWhereInput
    orderBy?: vehicle_bookings_billsOrderByWithAggregationInput | vehicle_bookings_billsOrderByWithAggregationInput[]
    by: Vehicle_bookings_billsScalarFieldEnum[] | Vehicle_bookings_billsScalarFieldEnum
    having?: vehicle_bookings_billsScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Vehicle_bookings_billsCountAggregateInputType | true
    _avg?: Vehicle_bookings_billsAvgAggregateInputType
    _sum?: Vehicle_bookings_billsSumAggregateInputType
    _min?: Vehicle_bookings_billsMinAggregateInputType
    _max?: Vehicle_bookings_billsMaxAggregateInputType
  }

  export type Vehicle_bookings_billsGroupByOutputType = {
    id: string
    vehicle_booking_id: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt: Date
    updatedAt: Date
    _count: Vehicle_bookings_billsCountAggregateOutputType | null
    _avg: Vehicle_bookings_billsAvgAggregateOutputType | null
    _sum: Vehicle_bookings_billsSumAggregateOutputType | null
    _min: Vehicle_bookings_billsMinAggregateOutputType | null
    _max: Vehicle_bookings_billsMaxAggregateOutputType | null
  }

  type GetVehicle_bookings_billsGroupByPayload<T extends vehicle_bookings_billsGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Vehicle_bookings_billsGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Vehicle_bookings_billsGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Vehicle_bookings_billsGroupByOutputType[P]>
            : GetScalarType<T[P], Vehicle_bookings_billsGroupByOutputType[P]>
        }
      >
    >


  export type vehicle_bookings_billsSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    vehicle_booking_id?: boolean
    base_price?: boolean
    vehicle_price_id?: boolean
    total_price?: boolean
    extra_km_charge?: boolean
    extra_hr_charge?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    vehicle_booking?: boolean | vehicle_bookingsDefaultArgs<ExtArgs>
    vehicle_price?: boolean | vehicle_pricesDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
    bills_payment?: boolean | vehicle_bookings_bills$bills_paymentArgs<ExtArgs>
    _count?: boolean | Vehicle_bookings_billsCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["vehicle_bookings_bills"]>



  export type vehicle_bookings_billsSelectScalar = {
    id?: boolean
    vehicle_booking_id?: boolean
    base_price?: boolean
    vehicle_price_id?: boolean
    total_price?: boolean
    extra_km_charge?: boolean
    extra_hr_charge?: boolean
    customer_id?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type vehicle_bookings_billsOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "vehicle_booking_id" | "base_price" | "vehicle_price_id" | "total_price" | "extra_km_charge" | "extra_hr_charge" | "customer_id" | "createdAt" | "updatedAt", ExtArgs["result"]["vehicle_bookings_bills"]>
  export type vehicle_bookings_billsInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    vehicle_booking?: boolean | vehicle_bookingsDefaultArgs<ExtArgs>
    vehicle_price?: boolean | vehicle_pricesDefaultArgs<ExtArgs>
    customer?: boolean | customerDefaultArgs<ExtArgs>
    bills_payment?: boolean | vehicle_bookings_bills$bills_paymentArgs<ExtArgs>
    _count?: boolean | Vehicle_bookings_billsCountOutputTypeDefaultArgs<ExtArgs>
  }

  export type $vehicle_bookings_billsPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "vehicle_bookings_bills"
    objects: {
      vehicle_booking: Prisma.$vehicle_bookingsPayload<ExtArgs>
      vehicle_price: Prisma.$vehicle_pricesPayload<ExtArgs>
      customer: Prisma.$customerPayload<ExtArgs>
      bills_payment: Prisma.$bills_paymentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      vehicle_booking_id: string
      base_price: number
      vehicle_price_id: string
      total_price: number
      extra_km_charge: number
      extra_hr_charge: number
      customer_id: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["vehicle_bookings_bills"]>
    composites: {}
  }

  type vehicle_bookings_billsGetPayload<S extends boolean | null | undefined | vehicle_bookings_billsDefaultArgs> = $Result.GetResult<Prisma.$vehicle_bookings_billsPayload, S>

  type vehicle_bookings_billsCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<vehicle_bookings_billsFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Vehicle_bookings_billsCountAggregateInputType | true
    }

  export interface vehicle_bookings_billsDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['vehicle_bookings_bills'], meta: { name: 'vehicle_bookings_bills' } }
    /**
     * Find zero or one Vehicle_bookings_bills that matches the filter.
     * @param {vehicle_bookings_billsFindUniqueArgs} args - Arguments to find a Vehicle_bookings_bills
     * @example
     * // Get one Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends vehicle_bookings_billsFindUniqueArgs>(args: SelectSubset<T, vehicle_bookings_billsFindUniqueArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Vehicle_bookings_bills that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {vehicle_bookings_billsFindUniqueOrThrowArgs} args - Arguments to find a Vehicle_bookings_bills
     * @example
     * // Get one Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends vehicle_bookings_billsFindUniqueOrThrowArgs>(args: SelectSubset<T, vehicle_bookings_billsFindUniqueOrThrowArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_bookings_bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_billsFindFirstArgs} args - Arguments to find a Vehicle_bookings_bills
     * @example
     * // Get one Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends vehicle_bookings_billsFindFirstArgs>(args?: SelectSubset<T, vehicle_bookings_billsFindFirstArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Vehicle_bookings_bills that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_billsFindFirstOrThrowArgs} args - Arguments to find a Vehicle_bookings_bills
     * @example
     * // Get one Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends vehicle_bookings_billsFindFirstOrThrowArgs>(args?: SelectSubset<T, vehicle_bookings_billsFindFirstOrThrowArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_bookings_bills that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_billsFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findMany()
     * 
     * // Get first 10 Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const vehicle_bookings_billsWithIdOnly = await prisma.vehicle_bookings_bills.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends vehicle_bookings_billsFindManyArgs>(args?: SelectSubset<T, vehicle_bookings_billsFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsCreateArgs} args - Arguments to create a Vehicle_bookings_bills.
     * @example
     * // Create one Vehicle_bookings_bills
     * const Vehicle_bookings_bills = await prisma.vehicle_bookings_bills.create({
     *   data: {
     *     // ... data to create a Vehicle_bookings_bills
     *   }
     * })
     * 
     */
    create<T extends vehicle_bookings_billsCreateArgs>(args: SelectSubset<T, vehicle_bookings_billsCreateArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsCreateManyArgs} args - Arguments to create many Vehicle_bookings_bills.
     * @example
     * // Create many Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends vehicle_bookings_billsCreateManyArgs>(args?: SelectSubset<T, vehicle_bookings_billsCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsDeleteArgs} args - Arguments to delete one Vehicle_bookings_bills.
     * @example
     * // Delete one Vehicle_bookings_bills
     * const Vehicle_bookings_bills = await prisma.vehicle_bookings_bills.delete({
     *   where: {
     *     // ... filter to delete one Vehicle_bookings_bills
     *   }
     * })
     * 
     */
    delete<T extends vehicle_bookings_billsDeleteArgs>(args: SelectSubset<T, vehicle_bookings_billsDeleteArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsUpdateArgs} args - Arguments to update one Vehicle_bookings_bills.
     * @example
     * // Update one Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends vehicle_bookings_billsUpdateArgs>(args: SelectSubset<T, vehicle_bookings_billsUpdateArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsDeleteManyArgs} args - Arguments to filter Vehicle_bookings_bills to delete.
     * @example
     * // Delete a few Vehicle_bookings_bills
     * const { count } = await prisma.vehicle_bookings_bills.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends vehicle_bookings_billsDeleteManyArgs>(args?: SelectSubset<T, vehicle_bookings_billsDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Vehicle_bookings_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_billsUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends vehicle_bookings_billsUpdateManyArgs>(args: SelectSubset<T, vehicle_bookings_billsUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsUpsertArgs} args - Arguments to update or create a Vehicle_bookings_bills.
     * @example
     * // Update or create a Vehicle_bookings_bills
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.upsert({
     *   create: {
     *     // ... data to create a Vehicle_bookings_bills
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Vehicle_bookings_bills we want to update
     *   }
     * })
     */
    upsert<T extends vehicle_bookings_billsUpsertArgs>(args: SelectSubset<T, vehicle_bookings_billsUpsertArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Vehicle_bookings_bills that matches the filter.
     * @param {vehicle_bookings_billsFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: vehicle_bookings_billsFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Vehicle_bookings_bills.
     * @param {vehicle_bookings_billsAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const vehicle_bookings_bills = await prisma.vehicle_bookings_bills.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: vehicle_bookings_billsAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Vehicle_bookings_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_billsCountArgs} args - Arguments to filter Vehicle_bookings_bills to count.
     * @example
     * // Count the number of Vehicle_bookings_bills
     * const count = await prisma.vehicle_bookings_bills.count({
     *   where: {
     *     // ... the filter for the Vehicle_bookings_bills we want to count
     *   }
     * })
    **/
    count<T extends vehicle_bookings_billsCountArgs>(
      args?: Subset<T, vehicle_bookings_billsCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Vehicle_bookings_billsCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Vehicle_bookings_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Vehicle_bookings_billsAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Vehicle_bookings_billsAggregateArgs>(args: Subset<T, Vehicle_bookings_billsAggregateArgs>): Prisma.PrismaPromise<GetVehicle_bookings_billsAggregateType<T>>

    /**
     * Group by Vehicle_bookings_bills.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {vehicle_bookings_billsGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends vehicle_bookings_billsGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: vehicle_bookings_billsGroupByArgs['orderBy'] }
        : { orderBy?: vehicle_bookings_billsGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, vehicle_bookings_billsGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetVehicle_bookings_billsGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the vehicle_bookings_bills model
   */
  readonly fields: vehicle_bookings_billsFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for vehicle_bookings_bills.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__vehicle_bookings_billsClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    vehicle_booking<T extends vehicle_bookingsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookingsDefaultArgs<ExtArgs>>): Prisma__vehicle_bookingsClient<$Result.GetResult<Prisma.$vehicle_bookingsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    vehicle_price<T extends vehicle_pricesDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_pricesDefaultArgs<ExtArgs>>): Prisma__vehicle_pricesClient<$Result.GetResult<Prisma.$vehicle_pricesPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    customer<T extends customerDefaultArgs<ExtArgs> = {}>(args?: Subset<T, customerDefaultArgs<ExtArgs>>): Prisma__customerClient<$Result.GetResult<Prisma.$customerPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    bills_payment<T extends vehicle_bookings_bills$bills_paymentArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings_bills$bills_paymentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the vehicle_bookings_bills model
   */
  interface vehicle_bookings_billsFieldRefs {
    readonly id: FieldRef<"vehicle_bookings_bills", 'String'>
    readonly vehicle_booking_id: FieldRef<"vehicle_bookings_bills", 'String'>
    readonly base_price: FieldRef<"vehicle_bookings_bills", 'Float'>
    readonly vehicle_price_id: FieldRef<"vehicle_bookings_bills", 'String'>
    readonly total_price: FieldRef<"vehicle_bookings_bills", 'Float'>
    readonly extra_km_charge: FieldRef<"vehicle_bookings_bills", 'Float'>
    readonly extra_hr_charge: FieldRef<"vehicle_bookings_bills", 'Float'>
    readonly customer_id: FieldRef<"vehicle_bookings_bills", 'String'>
    readonly createdAt: FieldRef<"vehicle_bookings_bills", 'DateTime'>
    readonly updatedAt: FieldRef<"vehicle_bookings_bills", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * vehicle_bookings_bills findUnique
   */
  export type vehicle_bookings_billsFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_bills to fetch.
     */
    where: vehicle_bookings_billsWhereUniqueInput
  }

  /**
   * vehicle_bookings_bills findUniqueOrThrow
   */
  export type vehicle_bookings_billsFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_bills to fetch.
     */
    where: vehicle_bookings_billsWhereUniqueInput
  }

  /**
   * vehicle_bookings_bills findFirst
   */
  export type vehicle_bookings_billsFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_bills to fetch.
     */
    where?: vehicle_bookings_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_bills to fetch.
     */
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_bookings_bills.
     */
    cursor?: vehicle_bookings_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_bookings_bills.
     */
    distinct?: Vehicle_bookings_billsScalarFieldEnum | Vehicle_bookings_billsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_bills findFirstOrThrow
   */
  export type vehicle_bookings_billsFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_bills to fetch.
     */
    where?: vehicle_bookings_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_bills to fetch.
     */
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for vehicle_bookings_bills.
     */
    cursor?: vehicle_bookings_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_bills.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of vehicle_bookings_bills.
     */
    distinct?: Vehicle_bookings_billsScalarFieldEnum | Vehicle_bookings_billsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_bills findMany
   */
  export type vehicle_bookings_billsFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * Filter, which vehicle_bookings_bills to fetch.
     */
    where?: vehicle_bookings_billsWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of vehicle_bookings_bills to fetch.
     */
    orderBy?: vehicle_bookings_billsOrderByWithRelationInput | vehicle_bookings_billsOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing vehicle_bookings_bills.
     */
    cursor?: vehicle_bookings_billsWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` vehicle_bookings_bills from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` vehicle_bookings_bills.
     */
    skip?: number
    distinct?: Vehicle_bookings_billsScalarFieldEnum | Vehicle_bookings_billsScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_bills create
   */
  export type vehicle_bookings_billsCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * The data needed to create a vehicle_bookings_bills.
     */
    data: XOR<vehicle_bookings_billsCreateInput, vehicle_bookings_billsUncheckedCreateInput>
  }

  /**
   * vehicle_bookings_bills createMany
   */
  export type vehicle_bookings_billsCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many vehicle_bookings_bills.
     */
    data: vehicle_bookings_billsCreateManyInput | vehicle_bookings_billsCreateManyInput[]
  }

  /**
   * vehicle_bookings_bills update
   */
  export type vehicle_bookings_billsUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * The data needed to update a vehicle_bookings_bills.
     */
    data: XOR<vehicle_bookings_billsUpdateInput, vehicle_bookings_billsUncheckedUpdateInput>
    /**
     * Choose, which vehicle_bookings_bills to update.
     */
    where: vehicle_bookings_billsWhereUniqueInput
  }

  /**
   * vehicle_bookings_bills updateMany
   */
  export type vehicle_bookings_billsUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update vehicle_bookings_bills.
     */
    data: XOR<vehicle_bookings_billsUpdateManyMutationInput, vehicle_bookings_billsUncheckedUpdateManyInput>
    /**
     * Filter which vehicle_bookings_bills to update
     */
    where?: vehicle_bookings_billsWhereInput
    /**
     * Limit how many vehicle_bookings_bills to update.
     */
    limit?: number
  }

  /**
   * vehicle_bookings_bills upsert
   */
  export type vehicle_bookings_billsUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * The filter to search for the vehicle_bookings_bills to update in case it exists.
     */
    where: vehicle_bookings_billsWhereUniqueInput
    /**
     * In case the vehicle_bookings_bills found by the `where` argument doesn't exist, create a new vehicle_bookings_bills with this data.
     */
    create: XOR<vehicle_bookings_billsCreateInput, vehicle_bookings_billsUncheckedCreateInput>
    /**
     * In case the vehicle_bookings_bills was found with the provided `where` argument, update it with this data.
     */
    update: XOR<vehicle_bookings_billsUpdateInput, vehicle_bookings_billsUncheckedUpdateInput>
  }

  /**
   * vehicle_bookings_bills delete
   */
  export type vehicle_bookings_billsDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
    /**
     * Filter which vehicle_bookings_bills to delete.
     */
    where: vehicle_bookings_billsWhereUniqueInput
  }

  /**
   * vehicle_bookings_bills deleteMany
   */
  export type vehicle_bookings_billsDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which vehicle_bookings_bills to delete
     */
    where?: vehicle_bookings_billsWhereInput
    /**
     * Limit how many vehicle_bookings_bills to delete.
     */
    limit?: number
  }

  /**
   * vehicle_bookings_bills findRaw
   */
  export type vehicle_bookings_billsFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_bookings_bills aggregateRaw
   */
  export type vehicle_bookings_billsAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * vehicle_bookings_bills.bills_payment
   */
  export type vehicle_bookings_bills$bills_paymentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    where?: bills_paymentWhereInput
    orderBy?: bills_paymentOrderByWithRelationInput | bills_paymentOrderByWithRelationInput[]
    cursor?: bills_paymentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: Bills_paymentScalarFieldEnum | Bills_paymentScalarFieldEnum[]
  }

  /**
   * vehicle_bookings_bills without action
   */
  export type vehicle_bookings_billsDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the vehicle_bookings_bills
     */
    select?: vehicle_bookings_billsSelect<ExtArgs> | null
    /**
     * Omit specific fields from the vehicle_bookings_bills
     */
    omit?: vehicle_bookings_billsOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: vehicle_bookings_billsInclude<ExtArgs> | null
  }


  /**
   * Model bills_payment
   */

  export type AggregateBills_payment = {
    _count: Bills_paymentCountAggregateOutputType | null
    _avg: Bills_paymentAvgAggregateOutputType | null
    _sum: Bills_paymentSumAggregateOutputType | null
    _min: Bills_paymentMinAggregateOutputType | null
    _max: Bills_paymentMaxAggregateOutputType | null
  }

  export type Bills_paymentAvgAggregateOutputType = {
    amount: number | null
  }

  export type Bills_paymentSumAggregateOutputType = {
    amount: number | null
  }

  export type Bills_paymentMinAggregateOutputType = {
    id: string | null
    bill_id: string | null
    amount: number | null
    payment_method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Bills_paymentMaxAggregateOutputType = {
    id: string | null
    bill_id: string | null
    amount: number | null
    payment_method: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type Bills_paymentCountAggregateOutputType = {
    id: number
    bill_id: number
    amount: number
    payment_method: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type Bills_paymentAvgAggregateInputType = {
    amount?: true
  }

  export type Bills_paymentSumAggregateInputType = {
    amount?: true
  }

  export type Bills_paymentMinAggregateInputType = {
    id?: true
    bill_id?: true
    amount?: true
    payment_method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Bills_paymentMaxAggregateInputType = {
    id?: true
    bill_id?: true
    amount?: true
    payment_method?: true
    createdAt?: true
    updatedAt?: true
  }

  export type Bills_paymentCountAggregateInputType = {
    id?: true
    bill_id?: true
    amount?: true
    payment_method?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type Bills_paymentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bills_payment to aggregate.
     */
    where?: bills_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills_payments to fetch.
     */
    orderBy?: bills_paymentOrderByWithRelationInput | bills_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: bills_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned bills_payments
    **/
    _count?: true | Bills_paymentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: Bills_paymentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: Bills_paymentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: Bills_paymentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: Bills_paymentMaxAggregateInputType
  }

  export type GetBills_paymentAggregateType<T extends Bills_paymentAggregateArgs> = {
        [P in keyof T & keyof AggregateBills_payment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBills_payment[P]>
      : GetScalarType<T[P], AggregateBills_payment[P]>
  }




  export type bills_paymentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: bills_paymentWhereInput
    orderBy?: bills_paymentOrderByWithAggregationInput | bills_paymentOrderByWithAggregationInput[]
    by: Bills_paymentScalarFieldEnum[] | Bills_paymentScalarFieldEnum
    having?: bills_paymentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: Bills_paymentCountAggregateInputType | true
    _avg?: Bills_paymentAvgAggregateInputType
    _sum?: Bills_paymentSumAggregateInputType
    _min?: Bills_paymentMinAggregateInputType
    _max?: Bills_paymentMaxAggregateInputType
  }

  export type Bills_paymentGroupByOutputType = {
    id: string
    bill_id: string
    amount: number
    payment_method: string
    createdAt: Date
    updatedAt: Date
    _count: Bills_paymentCountAggregateOutputType | null
    _avg: Bills_paymentAvgAggregateOutputType | null
    _sum: Bills_paymentSumAggregateOutputType | null
    _min: Bills_paymentMinAggregateOutputType | null
    _max: Bills_paymentMaxAggregateOutputType | null
  }

  type GetBills_paymentGroupByPayload<T extends bills_paymentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<Bills_paymentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof Bills_paymentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], Bills_paymentGroupByOutputType[P]>
            : GetScalarType<T[P], Bills_paymentGroupByOutputType[P]>
        }
      >
    >


  export type bills_paymentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    bill_id?: boolean
    amount?: boolean
    payment_method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    bill?: boolean | vehicle_bookings_billsDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["bills_payment"]>



  export type bills_paymentSelectScalar = {
    id?: boolean
    bill_id?: boolean
    amount?: boolean
    payment_method?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type bills_paymentOmit<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetOmit<"id" | "bill_id" | "amount" | "payment_method" | "createdAt" | "updatedAt", ExtArgs["result"]["bills_payment"]>
  export type bills_paymentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    bill?: boolean | vehicle_bookings_billsDefaultArgs<ExtArgs>
  }

  export type $bills_paymentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "bills_payment"
    objects: {
      bill: Prisma.$vehicle_bookings_billsPayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      bill_id: string
      amount: number
      payment_method: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["bills_payment"]>
    composites: {}
  }

  type bills_paymentGetPayload<S extends boolean | null | undefined | bills_paymentDefaultArgs> = $Result.GetResult<Prisma.$bills_paymentPayload, S>

  type bills_paymentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> =
    Omit<bills_paymentFindManyArgs, 'select' | 'include' | 'distinct' | 'omit'> & {
      select?: Bills_paymentCountAggregateInputType | true
    }

  export interface bills_paymentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['bills_payment'], meta: { name: 'bills_payment' } }
    /**
     * Find zero or one Bills_payment that matches the filter.
     * @param {bills_paymentFindUniqueArgs} args - Arguments to find a Bills_payment
     * @example
     * // Get one Bills_payment
     * const bills_payment = await prisma.bills_payment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends bills_paymentFindUniqueArgs>(args: SelectSubset<T, bills_paymentFindUniqueArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "findUnique", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find one Bills_payment that matches the filter or throw an error with `error.code='P2025'`
     * if no matches were found.
     * @param {bills_paymentFindUniqueOrThrowArgs} args - Arguments to find a Bills_payment
     * @example
     * // Get one Bills_payment
     * const bills_payment = await prisma.bills_payment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends bills_paymentFindUniqueOrThrowArgs>(args: SelectSubset<T, bills_paymentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bills_payment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bills_paymentFindFirstArgs} args - Arguments to find a Bills_payment
     * @example
     * // Get one Bills_payment
     * const bills_payment = await prisma.bills_payment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends bills_paymentFindFirstArgs>(args?: SelectSubset<T, bills_paymentFindFirstArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "findFirst", GlobalOmitOptions> | null, null, ExtArgs, GlobalOmitOptions>

    /**
     * Find the first Bills_payment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bills_paymentFindFirstOrThrowArgs} args - Arguments to find a Bills_payment
     * @example
     * // Get one Bills_payment
     * const bills_payment = await prisma.bills_payment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends bills_paymentFindFirstOrThrowArgs>(args?: SelectSubset<T, bills_paymentFindFirstOrThrowArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "findFirstOrThrow", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills_payments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bills_paymentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Bills_payments
     * const bills_payments = await prisma.bills_payment.findMany()
     * 
     * // Get first 10 Bills_payments
     * const bills_payments = await prisma.bills_payment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const bills_paymentWithIdOnly = await prisma.bills_payment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends bills_paymentFindManyArgs>(args?: SelectSubset<T, bills_paymentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "findMany", GlobalOmitOptions>>

    /**
     * Create a Bills_payment.
     * @param {bills_paymentCreateArgs} args - Arguments to create a Bills_payment.
     * @example
     * // Create one Bills_payment
     * const Bills_payment = await prisma.bills_payment.create({
     *   data: {
     *     // ... data to create a Bills_payment
     *   }
     * })
     * 
     */
    create<T extends bills_paymentCreateArgs>(args: SelectSubset<T, bills_paymentCreateArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "create", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Create many Bills_payments.
     * @param {bills_paymentCreateManyArgs} args - Arguments to create many Bills_payments.
     * @example
     * // Create many Bills_payments
     * const bills_payment = await prisma.bills_payment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends bills_paymentCreateManyArgs>(args?: SelectSubset<T, bills_paymentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Delete a Bills_payment.
     * @param {bills_paymentDeleteArgs} args - Arguments to delete one Bills_payment.
     * @example
     * // Delete one Bills_payment
     * const Bills_payment = await prisma.bills_payment.delete({
     *   where: {
     *     // ... filter to delete one Bills_payment
     *   }
     * })
     * 
     */
    delete<T extends bills_paymentDeleteArgs>(args: SelectSubset<T, bills_paymentDeleteArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "delete", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Update one Bills_payment.
     * @param {bills_paymentUpdateArgs} args - Arguments to update one Bills_payment.
     * @example
     * // Update one Bills_payment
     * const bills_payment = await prisma.bills_payment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends bills_paymentUpdateArgs>(args: SelectSubset<T, bills_paymentUpdateArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "update", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Delete zero or more Bills_payments.
     * @param {bills_paymentDeleteManyArgs} args - Arguments to filter Bills_payments to delete.
     * @example
     * // Delete a few Bills_payments
     * const { count } = await prisma.bills_payment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends bills_paymentDeleteManyArgs>(args?: SelectSubset<T, bills_paymentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Bills_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bills_paymentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Bills_payments
     * const bills_payment = await prisma.bills_payment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends bills_paymentUpdateManyArgs>(args: SelectSubset<T, bills_paymentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Bills_payment.
     * @param {bills_paymentUpsertArgs} args - Arguments to update or create a Bills_payment.
     * @example
     * // Update or create a Bills_payment
     * const bills_payment = await prisma.bills_payment.upsert({
     *   create: {
     *     // ... data to create a Bills_payment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Bills_payment we want to update
     *   }
     * })
     */
    upsert<T extends bills_paymentUpsertArgs>(args: SelectSubset<T, bills_paymentUpsertArgs<ExtArgs>>): Prisma__bills_paymentClient<$Result.GetResult<Prisma.$bills_paymentPayload<ExtArgs>, T, "upsert", GlobalOmitOptions>, never, ExtArgs, GlobalOmitOptions>

    /**
     * Find zero or more Bills_payments that matches the filter.
     * @param {bills_paymentFindRawArgs} args - Select which filters you would like to apply.
     * @example
     * const bills_payment = await prisma.bills_payment.findRaw({
     *   filter: { age: { $gt: 25 } }
     * })
     */
    findRaw(args?: bills_paymentFindRawArgs): Prisma.PrismaPromise<JsonObject>

    /**
     * Perform aggregation operations on a Bills_payment.
     * @param {bills_paymentAggregateRawArgs} args - Select which aggregations you would like to apply.
     * @example
     * const bills_payment = await prisma.bills_payment.aggregateRaw({
     *   pipeline: [
     *     { $match: { status: "registered" } },
     *     { $group: { _id: "$country", total: { $sum: 1 } } }
     *   ]
     * })
     */
    aggregateRaw(args?: bills_paymentAggregateRawArgs): Prisma.PrismaPromise<JsonObject>


    /**
     * Count the number of Bills_payments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bills_paymentCountArgs} args - Arguments to filter Bills_payments to count.
     * @example
     * // Count the number of Bills_payments
     * const count = await prisma.bills_payment.count({
     *   where: {
     *     // ... the filter for the Bills_payments we want to count
     *   }
     * })
    **/
    count<T extends bills_paymentCountArgs>(
      args?: Subset<T, bills_paymentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], Bills_paymentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Bills_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {Bills_paymentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends Bills_paymentAggregateArgs>(args: Subset<T, Bills_paymentAggregateArgs>): Prisma.PrismaPromise<GetBills_paymentAggregateType<T>>

    /**
     * Group by Bills_payment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {bills_paymentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends bills_paymentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: bills_paymentGroupByArgs['orderBy'] }
        : { orderBy?: bills_paymentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, bills_paymentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBills_paymentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the bills_payment model
   */
  readonly fields: bills_paymentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for bills_payment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__bills_paymentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, GlobalOmitOptions = {}> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    bill<T extends vehicle_bookings_billsDefaultArgs<ExtArgs> = {}>(args?: Subset<T, vehicle_bookings_billsDefaultArgs<ExtArgs>>): Prisma__vehicle_bookings_billsClient<$Result.GetResult<Prisma.$vehicle_bookings_billsPayload<ExtArgs>, T, "findUniqueOrThrow", GlobalOmitOptions> | Null, Null, ExtArgs, GlobalOmitOptions>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the bills_payment model
   */
  interface bills_paymentFieldRefs {
    readonly id: FieldRef<"bills_payment", 'String'>
    readonly bill_id: FieldRef<"bills_payment", 'String'>
    readonly amount: FieldRef<"bills_payment", 'Float'>
    readonly payment_method: FieldRef<"bills_payment", 'String'>
    readonly createdAt: FieldRef<"bills_payment", 'DateTime'>
    readonly updatedAt: FieldRef<"bills_payment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * bills_payment findUnique
   */
  export type bills_paymentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * Filter, which bills_payment to fetch.
     */
    where: bills_paymentWhereUniqueInput
  }

  /**
   * bills_payment findUniqueOrThrow
   */
  export type bills_paymentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * Filter, which bills_payment to fetch.
     */
    where: bills_paymentWhereUniqueInput
  }

  /**
   * bills_payment findFirst
   */
  export type bills_paymentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * Filter, which bills_payment to fetch.
     */
    where?: bills_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills_payments to fetch.
     */
    orderBy?: bills_paymentOrderByWithRelationInput | bills_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bills_payments.
     */
    cursor?: bills_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bills_payments.
     */
    distinct?: Bills_paymentScalarFieldEnum | Bills_paymentScalarFieldEnum[]
  }

  /**
   * bills_payment findFirstOrThrow
   */
  export type bills_paymentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * Filter, which bills_payment to fetch.
     */
    where?: bills_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills_payments to fetch.
     */
    orderBy?: bills_paymentOrderByWithRelationInput | bills_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for bills_payments.
     */
    cursor?: bills_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills_payments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of bills_payments.
     */
    distinct?: Bills_paymentScalarFieldEnum | Bills_paymentScalarFieldEnum[]
  }

  /**
   * bills_payment findMany
   */
  export type bills_paymentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * Filter, which bills_payments to fetch.
     */
    where?: bills_paymentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of bills_payments to fetch.
     */
    orderBy?: bills_paymentOrderByWithRelationInput | bills_paymentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing bills_payments.
     */
    cursor?: bills_paymentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` bills_payments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` bills_payments.
     */
    skip?: number
    distinct?: Bills_paymentScalarFieldEnum | Bills_paymentScalarFieldEnum[]
  }

  /**
   * bills_payment create
   */
  export type bills_paymentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * The data needed to create a bills_payment.
     */
    data: XOR<bills_paymentCreateInput, bills_paymentUncheckedCreateInput>
  }

  /**
   * bills_payment createMany
   */
  export type bills_paymentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many bills_payments.
     */
    data: bills_paymentCreateManyInput | bills_paymentCreateManyInput[]
  }

  /**
   * bills_payment update
   */
  export type bills_paymentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * The data needed to update a bills_payment.
     */
    data: XOR<bills_paymentUpdateInput, bills_paymentUncheckedUpdateInput>
    /**
     * Choose, which bills_payment to update.
     */
    where: bills_paymentWhereUniqueInput
  }

  /**
   * bills_payment updateMany
   */
  export type bills_paymentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update bills_payments.
     */
    data: XOR<bills_paymentUpdateManyMutationInput, bills_paymentUncheckedUpdateManyInput>
    /**
     * Filter which bills_payments to update
     */
    where?: bills_paymentWhereInput
    /**
     * Limit how many bills_payments to update.
     */
    limit?: number
  }

  /**
   * bills_payment upsert
   */
  export type bills_paymentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * The filter to search for the bills_payment to update in case it exists.
     */
    where: bills_paymentWhereUniqueInput
    /**
     * In case the bills_payment found by the `where` argument doesn't exist, create a new bills_payment with this data.
     */
    create: XOR<bills_paymentCreateInput, bills_paymentUncheckedCreateInput>
    /**
     * In case the bills_payment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<bills_paymentUpdateInput, bills_paymentUncheckedUpdateInput>
  }

  /**
   * bills_payment delete
   */
  export type bills_paymentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
    /**
     * Filter which bills_payment to delete.
     */
    where: bills_paymentWhereUniqueInput
  }

  /**
   * bills_payment deleteMany
   */
  export type bills_paymentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which bills_payments to delete
     */
    where?: bills_paymentWhereInput
    /**
     * Limit how many bills_payments to delete.
     */
    limit?: number
  }

  /**
   * bills_payment findRaw
   */
  export type bills_paymentFindRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The query predicate filter. If unspecified, then all documents in the collection will match the predicate. ${@link https://docs.mongodb.com/manual/reference/operator/query MongoDB Docs}.
     */
    filter?: InputJsonValue
    /**
     * Additional options to pass to the `find` command ${@link https://docs.mongodb.com/manual/reference/command/find/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * bills_payment aggregateRaw
   */
  export type bills_paymentAggregateRawArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * An array of aggregation stages to process and transform the document stream via the aggregation pipeline. ${@link https://docs.mongodb.com/manual/reference/operator/aggregation-pipeline MongoDB Docs}.
     */
    pipeline?: InputJsonValue[]
    /**
     * Additional options to pass to the `aggregate` command ${@link https://docs.mongodb.com/manual/reference/command/aggregate/#command-fields MongoDB Docs}.
     */
    options?: InputJsonValue
  }

  /**
   * bills_payment without action
   */
  export type bills_paymentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the bills_payment
     */
    select?: bills_paymentSelect<ExtArgs> | null
    /**
     * Omit specific fields from the bills_payment
     */
    omit?: bills_paymentOmit<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: bills_paymentInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const UsersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    username: 'username',
    role_id: 'role_id',
    is_active: 'is_active',
    password: 'password',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UsersScalarFieldEnum = (typeof UsersScalarFieldEnum)[keyof typeof UsersScalarFieldEnum]


  export const BrandsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type BrandsScalarFieldEnum = (typeof BrandsScalarFieldEnum)[keyof typeof BrandsScalarFieldEnum]


  export const ModelsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    brand_id: 'brand_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ModelsScalarFieldEnum = (typeof ModelsScalarFieldEnum)[keyof typeof ModelsScalarFieldEnum]


  export const VariantsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    model_id: 'model_id',
    brand_id: 'brand_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VariantsScalarFieldEnum = (typeof VariantsScalarFieldEnum)[keyof typeof VariantsScalarFieldEnum]


  export const StatesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type StatesScalarFieldEnum = (typeof StatesScalarFieldEnum)[keyof typeof StatesScalarFieldEnum]


  export const CitiesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    stateId: 'stateId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CitiesScalarFieldEnum = (typeof CitiesScalarFieldEnum)[keyof typeof CitiesScalarFieldEnum]


  export const Checklist_categoriesScalarFieldEnum: {
    id: 'id',
    name: 'name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Checklist_categoriesScalarFieldEnum = (typeof Checklist_categoriesScalarFieldEnum)[keyof typeof Checklist_categoriesScalarFieldEnum]


  export const Checklist_optionsScalarFieldEnum: {
    id: 'id',
    name: 'name',
    category_id: 'category_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Checklist_optionsScalarFieldEnum = (typeof Checklist_optionsScalarFieldEnum)[keyof typeof Checklist_optionsScalarFieldEnum]


  export const VehicleScalarFieldEnum: {
    id: 'id',
    registration_number: 'registration_number',
    owner_name: 'owner_name',
    insurance_company: 'insurance_company',
    insurance_number: 'insurance_number',
    chassis_number: 'chassis_number',
    rc_image: 'rc_image',
    insurance_image: 'insurance_image',
    brand_id: 'brand_id',
    model_id: 'model_id',
    variant_id: 'variant_id',
    kms_driven: 'kms_driven',
    color: 'color',
    mileage: 'mileage',
    engine_capacity: 'engine_capacity',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type VehicleScalarFieldEnum = (typeof VehicleScalarFieldEnum)[keyof typeof VehicleScalarFieldEnum]


  export const Vehicle_featuresScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    feature_name: 'feature_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_featuresScalarFieldEnum = (typeof Vehicle_featuresScalarFieldEnum)[keyof typeof Vehicle_featuresScalarFieldEnum]


  export const Vehicle_imagesScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    image_url: 'image_url',
    description: 'description',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_imagesScalarFieldEnum = (typeof Vehicle_imagesScalarFieldEnum)[keyof typeof Vehicle_imagesScalarFieldEnum]


  export const Vehicle_availabilityScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    start_time: 'start_time',
    end_time: 'end_time',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_availabilityScalarFieldEnum = (typeof Vehicle_availabilityScalarFieldEnum)[keyof typeof Vehicle_availabilityScalarFieldEnum]


  export const Vehicle_availability_historyScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    start_time: 'start_time',
    end_time: 'end_time',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_availability_historyScalarFieldEnum = (typeof Vehicle_availability_historyScalarFieldEnum)[keyof typeof Vehicle_availability_historyScalarFieldEnum]


  export const Vehicle_inspectionScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    inspection_date: 'inspection_date',
    inspector_name: 'inspector_name',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt',
    vehicle_bookingsId: 'vehicle_bookingsId'
  };

  export type Vehicle_inspectionScalarFieldEnum = (typeof Vehicle_inspectionScalarFieldEnum)[keyof typeof Vehicle_inspectionScalarFieldEnum]


  export const Vehicle_inspection_detailsScalarFieldEnum: {
    id: 'id',
    checklist_option_id: 'checklist_option_id',
    rating: 'rating',
    description: 'description',
    vehicle_inspection_id: 'vehicle_inspection_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_inspection_detailsScalarFieldEnum = (typeof Vehicle_inspection_detailsScalarFieldEnum)[keyof typeof Vehicle_inspection_detailsScalarFieldEnum]


  export const Vehicle_pricesScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    base_price_per_day: 'base_price_per_day',
    hr_included: 'hr_included',
    km_included: 'km_included',
    extra_km_charge: 'extra_km_charge',
    extra_hr_charge: 'extra_hr_charge',
    is_unlimited_allowed: 'is_unlimited_allowed',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_pricesScalarFieldEnum = (typeof Vehicle_pricesScalarFieldEnum)[keyof typeof Vehicle_pricesScalarFieldEnum]


  export const CustomerScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email_id: 'email_id',
    mobile_number: 'mobile_number',
    alternate_mobile_number: 'alternate_mobile_number',
    address: 'address',
    city_id: 'city_id',
    state_id: 'state_id',
    pin_code: 'pin_code',
    adhaar_number: 'adhaar_number',
    adhar_front_image: 'adhar_front_image',
    adhar_back_image: 'adhar_back_image',
    driving_license_number: 'driving_license_number',
    driving_license_front_image: 'driving_license_front_image',
    driving_license_back_image: 'driving_license_back_image',
    profile_image: 'profile_image',
    is_active: 'is_active',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type CustomerScalarFieldEnum = (typeof CustomerScalarFieldEnum)[keyof typeof CustomerScalarFieldEnum]


  export const ProvidersScalarFieldEnum: {
    id: 'id',
    name: 'name',
    email_id: 'email_id',
    mobile_number: 'mobile_number',
    alternate_mobile_number: 'alternate_mobile_number',
    address: 'address',
    cityId: 'cityId',
    stateId: 'stateId',
    pin_code: 'pin_code',
    adhaar_number: 'adhaar_number',
    adhar_front_image: 'adhar_front_image',
    adhar_back_image: 'adhar_back_image',
    pan_number: 'pan_number',
    pan_image: 'pan_image',
    profile_image: 'profile_image',
    is_approved: 'is_approved',
    is_active: 'is_active',
    rejection_reason: 'rejection_reason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ProvidersScalarFieldEnum = (typeof ProvidersScalarFieldEnum)[keyof typeof ProvidersScalarFieldEnum]


  export const Vehicle_bookingsScalarFieldEnum: {
    id: 'id',
    booking_number: 'booking_number',
    vehicle_id: 'vehicle_id',
    customer_id: 'customer_id',
    start_time: 'start_time',
    end_time: 'end_time',
    booking_status_id: 'booking_status_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_bookingsScalarFieldEnum = (typeof Vehicle_bookingsScalarFieldEnum)[keyof typeof Vehicle_bookingsScalarFieldEnum]


  export const Vehicle_bookings_logsScalarFieldEnum: {
    id: 'id',
    vehicle_id: 'vehicle_id',
    vehicle_booking_id: 'vehicle_booking_id',
    booking_number: 'booking_number',
    start_time: 'start_time',
    end_time: 'end_time',
    customer_id: 'customer_id',
    booking_status_id: 'booking_status_id',
    logged_time: 'logged_time',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_bookings_logsScalarFieldEnum = (typeof Vehicle_bookings_logsScalarFieldEnum)[keyof typeof Vehicle_bookings_logsScalarFieldEnum]


  export const Vehicle_bookings_billsScalarFieldEnum: {
    id: 'id',
    vehicle_booking_id: 'vehicle_booking_id',
    base_price: 'base_price',
    vehicle_price_id: 'vehicle_price_id',
    total_price: 'total_price',
    extra_km_charge: 'extra_km_charge',
    extra_hr_charge: 'extra_hr_charge',
    customer_id: 'customer_id',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Vehicle_bookings_billsScalarFieldEnum = (typeof Vehicle_bookings_billsScalarFieldEnum)[keyof typeof Vehicle_bookings_billsScalarFieldEnum]


  export const Bills_paymentScalarFieldEnum: {
    id: 'id',
    bill_id: 'bill_id',
    amount: 'amount',
    payment_method: 'payment_method',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type Bills_paymentScalarFieldEnum = (typeof Bills_paymentScalarFieldEnum)[keyof typeof Bills_paymentScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  /**
   * Field references
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'role'
   */
  export type EnumroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role'>
    


  /**
   * Reference to a field of type 'role[]'
   */
  export type ListEnumroleFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'role[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    
  /**
   * Deep Input Types
   */


  export type usersWhereInput = {
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    id?: StringFilter<"users"> | string
    name?: StringFilter<"users"> | string
    username?: StringFilter<"users"> | string
    role_id?: EnumroleFilter<"users"> | $Enums.role
    is_active?: BoolFilter<"users"> | boolean
    password?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }

  export type usersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    username?: string
    AND?: usersWhereInput | usersWhereInput[]
    OR?: usersWhereInput[]
    NOT?: usersWhereInput | usersWhereInput[]
    name?: StringFilter<"users"> | string
    role_id?: EnumroleFilter<"users"> | $Enums.role
    is_active?: BoolFilter<"users"> | boolean
    password?: StringFilter<"users"> | string
    createdAt?: DateTimeFilter<"users"> | Date | string
    updatedAt?: DateTimeFilter<"users"> | Date | string
  }, "id" | "username">

  export type usersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: usersCountOrderByAggregateInput
    _max?: usersMaxOrderByAggregateInput
    _min?: usersMinOrderByAggregateInput
  }

  export type usersScalarWhereWithAggregatesInput = {
    AND?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    OR?: usersScalarWhereWithAggregatesInput[]
    NOT?: usersScalarWhereWithAggregatesInput | usersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"users"> | string
    name?: StringWithAggregatesFilter<"users"> | string
    username?: StringWithAggregatesFilter<"users"> | string
    role_id?: EnumroleWithAggregatesFilter<"users"> | $Enums.role
    is_active?: BoolWithAggregatesFilter<"users"> | boolean
    password?: StringWithAggregatesFilter<"users"> | string
    createdAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"users"> | Date | string
  }

  export type brandsWhereInput = {
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    id?: StringFilter<"brands"> | string
    name?: StringFilter<"brands"> | string
    createdAt?: DateTimeFilter<"brands"> | Date | string
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    models?: ModelsListRelationFilter
    variants?: VariantsListRelationFilter
    vehicle?: VehicleListRelationFilter
  }

  export type brandsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    models?: modelsOrderByRelationAggregateInput
    variants?: variantsOrderByRelationAggregateInput
    vehicle?: vehicleOrderByRelationAggregateInput
  }

  export type brandsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: brandsWhereInput | brandsWhereInput[]
    OR?: brandsWhereInput[]
    NOT?: brandsWhereInput | brandsWhereInput[]
    name?: StringFilter<"brands"> | string
    createdAt?: DateTimeFilter<"brands"> | Date | string
    updatedAt?: DateTimeFilter<"brands"> | Date | string
    models?: ModelsListRelationFilter
    variants?: VariantsListRelationFilter
    vehicle?: VehicleListRelationFilter
  }, "id">

  export type brandsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: brandsCountOrderByAggregateInput
    _max?: brandsMaxOrderByAggregateInput
    _min?: brandsMinOrderByAggregateInput
  }

  export type brandsScalarWhereWithAggregatesInput = {
    AND?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    OR?: brandsScalarWhereWithAggregatesInput[]
    NOT?: brandsScalarWhereWithAggregatesInput | brandsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"brands"> | string
    name?: StringWithAggregatesFilter<"brands"> | string
    createdAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"brands"> | Date | string
  }

  export type modelsWhereInput = {
    AND?: modelsWhereInput | modelsWhereInput[]
    OR?: modelsWhereInput[]
    NOT?: modelsWhereInput | modelsWhereInput[]
    id?: StringFilter<"models"> | string
    name?: StringFilter<"models"> | string
    brand_id?: StringFilter<"models"> | string
    createdAt?: DateTimeFilter<"models"> | Date | string
    updatedAt?: DateTimeFilter<"models"> | Date | string
    brand?: XOR<BrandsScalarRelationFilter, brandsWhereInput>
    variants?: VariantsListRelationFilter
    vehicle?: VehicleListRelationFilter
  }

  export type modelsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: brandsOrderByWithRelationInput
    variants?: variantsOrderByRelationAggregateInput
    vehicle?: vehicleOrderByRelationAggregateInput
  }

  export type modelsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: modelsWhereInput | modelsWhereInput[]
    OR?: modelsWhereInput[]
    NOT?: modelsWhereInput | modelsWhereInput[]
    name?: StringFilter<"models"> | string
    brand_id?: StringFilter<"models"> | string
    createdAt?: DateTimeFilter<"models"> | Date | string
    updatedAt?: DateTimeFilter<"models"> | Date | string
    brand?: XOR<BrandsScalarRelationFilter, brandsWhereInput>
    variants?: VariantsListRelationFilter
    vehicle?: VehicleListRelationFilter
  }, "id">

  export type modelsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: modelsCountOrderByAggregateInput
    _max?: modelsMaxOrderByAggregateInput
    _min?: modelsMinOrderByAggregateInput
  }

  export type modelsScalarWhereWithAggregatesInput = {
    AND?: modelsScalarWhereWithAggregatesInput | modelsScalarWhereWithAggregatesInput[]
    OR?: modelsScalarWhereWithAggregatesInput[]
    NOT?: modelsScalarWhereWithAggregatesInput | modelsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"models"> | string
    name?: StringWithAggregatesFilter<"models"> | string
    brand_id?: StringWithAggregatesFilter<"models"> | string
    createdAt?: DateTimeWithAggregatesFilter<"models"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"models"> | Date | string
  }

  export type variantsWhereInput = {
    AND?: variantsWhereInput | variantsWhereInput[]
    OR?: variantsWhereInput[]
    NOT?: variantsWhereInput | variantsWhereInput[]
    id?: StringFilter<"variants"> | string
    name?: StringFilter<"variants"> | string
    model_id?: StringFilter<"variants"> | string
    brand_id?: StringNullableFilter<"variants"> | string | null
    createdAt?: DateTimeFilter<"variants"> | Date | string
    updatedAt?: DateTimeFilter<"variants"> | Date | string
    model?: XOR<ModelsScalarRelationFilter, modelsWhereInput>
    brand?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    vehicle?: VehicleListRelationFilter
  }

  export type variantsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    model?: modelsOrderByWithRelationInput
    brand?: brandsOrderByWithRelationInput
    vehicle?: vehicleOrderByRelationAggregateInput
  }

  export type variantsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: variantsWhereInput | variantsWhereInput[]
    OR?: variantsWhereInput[]
    NOT?: variantsWhereInput | variantsWhereInput[]
    name?: StringFilter<"variants"> | string
    model_id?: StringFilter<"variants"> | string
    brand_id?: StringNullableFilter<"variants"> | string | null
    createdAt?: DateTimeFilter<"variants"> | Date | string
    updatedAt?: DateTimeFilter<"variants"> | Date | string
    model?: XOR<ModelsScalarRelationFilter, modelsWhereInput>
    brand?: XOR<BrandsNullableScalarRelationFilter, brandsWhereInput> | null
    vehicle?: VehicleListRelationFilter
  }, "id">

  export type variantsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: variantsCountOrderByAggregateInput
    _max?: variantsMaxOrderByAggregateInput
    _min?: variantsMinOrderByAggregateInput
  }

  export type variantsScalarWhereWithAggregatesInput = {
    AND?: variantsScalarWhereWithAggregatesInput | variantsScalarWhereWithAggregatesInput[]
    OR?: variantsScalarWhereWithAggregatesInput[]
    NOT?: variantsScalarWhereWithAggregatesInput | variantsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"variants"> | string
    name?: StringWithAggregatesFilter<"variants"> | string
    model_id?: StringWithAggregatesFilter<"variants"> | string
    brand_id?: StringNullableWithAggregatesFilter<"variants"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"variants"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"variants"> | Date | string
  }

  export type statesWhereInput = {
    AND?: statesWhereInput | statesWhereInput[]
    OR?: statesWhereInput[]
    NOT?: statesWhereInput | statesWhereInput[]
    id?: StringFilter<"states"> | string
    name?: StringFilter<"states"> | string
    createdAt?: DateTimeFilter<"states"> | Date | string
    updatedAt?: DateTimeFilter<"states"> | Date | string
    cities?: CitiesListRelationFilter
    customers?: CustomerListRelationFilter
    providers?: ProvidersListRelationFilter
  }

  export type statesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    cities?: citiesOrderByRelationAggregateInput
    customers?: customerOrderByRelationAggregateInput
    providers?: providersOrderByRelationAggregateInput
  }

  export type statesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: statesWhereInput | statesWhereInput[]
    OR?: statesWhereInput[]
    NOT?: statesWhereInput | statesWhereInput[]
    name?: StringFilter<"states"> | string
    createdAt?: DateTimeFilter<"states"> | Date | string
    updatedAt?: DateTimeFilter<"states"> | Date | string
    cities?: CitiesListRelationFilter
    customers?: CustomerListRelationFilter
    providers?: ProvidersListRelationFilter
  }, "id">

  export type statesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: statesCountOrderByAggregateInput
    _max?: statesMaxOrderByAggregateInput
    _min?: statesMinOrderByAggregateInput
  }

  export type statesScalarWhereWithAggregatesInput = {
    AND?: statesScalarWhereWithAggregatesInput | statesScalarWhereWithAggregatesInput[]
    OR?: statesScalarWhereWithAggregatesInput[]
    NOT?: statesScalarWhereWithAggregatesInput | statesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"states"> | string
    name?: StringWithAggregatesFilter<"states"> | string
    createdAt?: DateTimeWithAggregatesFilter<"states"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"states"> | Date | string
  }

  export type citiesWhereInput = {
    AND?: citiesWhereInput | citiesWhereInput[]
    OR?: citiesWhereInput[]
    NOT?: citiesWhereInput | citiesWhereInput[]
    id?: StringFilter<"cities"> | string
    name?: StringFilter<"cities"> | string
    stateId?: StringFilter<"cities"> | string
    createdAt?: DateTimeFilter<"cities"> | Date | string
    updatedAt?: DateTimeFilter<"cities"> | Date | string
    state?: XOR<StatesScalarRelationFilter, statesWhereInput>
    customers?: CustomerListRelationFilter
    providers?: ProvidersListRelationFilter
  }

  export type citiesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    state?: statesOrderByWithRelationInput
    customers?: customerOrderByRelationAggregateInput
    providers?: providersOrderByRelationAggregateInput
  }

  export type citiesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: citiesWhereInput | citiesWhereInput[]
    OR?: citiesWhereInput[]
    NOT?: citiesWhereInput | citiesWhereInput[]
    name?: StringFilter<"cities"> | string
    stateId?: StringFilter<"cities"> | string
    createdAt?: DateTimeFilter<"cities"> | Date | string
    updatedAt?: DateTimeFilter<"cities"> | Date | string
    state?: XOR<StatesScalarRelationFilter, statesWhereInput>
    customers?: CustomerListRelationFilter
    providers?: ProvidersListRelationFilter
  }, "id">

  export type citiesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: citiesCountOrderByAggregateInput
    _max?: citiesMaxOrderByAggregateInput
    _min?: citiesMinOrderByAggregateInput
  }

  export type citiesScalarWhereWithAggregatesInput = {
    AND?: citiesScalarWhereWithAggregatesInput | citiesScalarWhereWithAggregatesInput[]
    OR?: citiesScalarWhereWithAggregatesInput[]
    NOT?: citiesScalarWhereWithAggregatesInput | citiesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"cities"> | string
    name?: StringWithAggregatesFilter<"cities"> | string
    stateId?: StringWithAggregatesFilter<"cities"> | string
    createdAt?: DateTimeWithAggregatesFilter<"cities"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"cities"> | Date | string
  }

  export type checklist_categoriesWhereInput = {
    AND?: checklist_categoriesWhereInput | checklist_categoriesWhereInput[]
    OR?: checklist_categoriesWhereInput[]
    NOT?: checklist_categoriesWhereInput | checklist_categoriesWhereInput[]
    id?: StringFilter<"checklist_categories"> | string
    name?: StringFilter<"checklist_categories"> | string
    createdAt?: DateTimeFilter<"checklist_categories"> | Date | string
    updatedAt?: DateTimeFilter<"checklist_categories"> | Date | string
    options?: Checklist_optionsListRelationFilter
  }

  export type checklist_categoriesOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    options?: checklist_optionsOrderByRelationAggregateInput
  }

  export type checklist_categoriesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: checklist_categoriesWhereInput | checklist_categoriesWhereInput[]
    OR?: checklist_categoriesWhereInput[]
    NOT?: checklist_categoriesWhereInput | checklist_categoriesWhereInput[]
    name?: StringFilter<"checklist_categories"> | string
    createdAt?: DateTimeFilter<"checklist_categories"> | Date | string
    updatedAt?: DateTimeFilter<"checklist_categories"> | Date | string
    options?: Checklist_optionsListRelationFilter
  }, "id">

  export type checklist_categoriesOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: checklist_categoriesCountOrderByAggregateInput
    _max?: checklist_categoriesMaxOrderByAggregateInput
    _min?: checklist_categoriesMinOrderByAggregateInput
  }

  export type checklist_categoriesScalarWhereWithAggregatesInput = {
    AND?: checklist_categoriesScalarWhereWithAggregatesInput | checklist_categoriesScalarWhereWithAggregatesInput[]
    OR?: checklist_categoriesScalarWhereWithAggregatesInput[]
    NOT?: checklist_categoriesScalarWhereWithAggregatesInput | checklist_categoriesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"checklist_categories"> | string
    name?: StringWithAggregatesFilter<"checklist_categories"> | string
    createdAt?: DateTimeWithAggregatesFilter<"checklist_categories"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"checklist_categories"> | Date | string
  }

  export type checklist_optionsWhereInput = {
    AND?: checklist_optionsWhereInput | checklist_optionsWhereInput[]
    OR?: checklist_optionsWhereInput[]
    NOT?: checklist_optionsWhereInput | checklist_optionsWhereInput[]
    id?: StringFilter<"checklist_options"> | string
    name?: StringFilter<"checklist_options"> | string
    category_id?: StringFilter<"checklist_options"> | string
    createdAt?: DateTimeFilter<"checklist_options"> | Date | string
    updatedAt?: DateTimeFilter<"checklist_options"> | Date | string
    category?: XOR<Checklist_categoriesScalarRelationFilter, checklist_categoriesWhereInput>
    inspectionDetails?: Vehicle_inspection_detailsListRelationFilter
  }

  export type checklist_optionsOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    category?: checklist_categoriesOrderByWithRelationInput
    inspectionDetails?: vehicle_inspection_detailsOrderByRelationAggregateInput
  }

  export type checklist_optionsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: checklist_optionsWhereInput | checklist_optionsWhereInput[]
    OR?: checklist_optionsWhereInput[]
    NOT?: checklist_optionsWhereInput | checklist_optionsWhereInput[]
    name?: StringFilter<"checklist_options"> | string
    category_id?: StringFilter<"checklist_options"> | string
    createdAt?: DateTimeFilter<"checklist_options"> | Date | string
    updatedAt?: DateTimeFilter<"checklist_options"> | Date | string
    category?: XOR<Checklist_categoriesScalarRelationFilter, checklist_categoriesWhereInput>
    inspectionDetails?: Vehicle_inspection_detailsListRelationFilter
  }, "id">

  export type checklist_optionsOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: checklist_optionsCountOrderByAggregateInput
    _max?: checklist_optionsMaxOrderByAggregateInput
    _min?: checklist_optionsMinOrderByAggregateInput
  }

  export type checklist_optionsScalarWhereWithAggregatesInput = {
    AND?: checklist_optionsScalarWhereWithAggregatesInput | checklist_optionsScalarWhereWithAggregatesInput[]
    OR?: checklist_optionsScalarWhereWithAggregatesInput[]
    NOT?: checklist_optionsScalarWhereWithAggregatesInput | checklist_optionsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"checklist_options"> | string
    name?: StringWithAggregatesFilter<"checklist_options"> | string
    category_id?: StringWithAggregatesFilter<"checklist_options"> | string
    createdAt?: DateTimeWithAggregatesFilter<"checklist_options"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"checklist_options"> | Date | string
  }

  export type vehicleWhereInput = {
    AND?: vehicleWhereInput | vehicleWhereInput[]
    OR?: vehicleWhereInput[]
    NOT?: vehicleWhereInput | vehicleWhereInput[]
    id?: StringFilter<"vehicle"> | string
    registration_number?: StringFilter<"vehicle"> | string
    owner_name?: StringFilter<"vehicle"> | string
    insurance_company?: StringFilter<"vehicle"> | string
    insurance_number?: StringFilter<"vehicle"> | string
    chassis_number?: StringFilter<"vehicle"> | string
    rc_image?: StringFilter<"vehicle"> | string
    insurance_image?: StringFilter<"vehicle"> | string
    brand_id?: StringFilter<"vehicle"> | string
    model_id?: StringFilter<"vehicle"> | string
    variant_id?: StringFilter<"vehicle"> | string
    kms_driven?: IntFilter<"vehicle"> | number
    color?: StringFilter<"vehicle"> | string
    mileage?: FloatFilter<"vehicle"> | number
    engine_capacity?: IntFilter<"vehicle"> | number
    createdAt?: DateTimeFilter<"vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle"> | Date | string
    brand?: XOR<BrandsScalarRelationFilter, brandsWhereInput>
    model?: XOR<ModelsScalarRelationFilter, modelsWhereInput>
    variant?: XOR<VariantsScalarRelationFilter, variantsWhereInput>
    features?: Vehicle_featuresListRelationFilter
    images?: Vehicle_imagesListRelationFilter
    availability?: Vehicle_availabilityListRelationFilter
    availability_history?: Vehicle_availability_historyListRelationFilter
    inspections?: Vehicle_inspectionListRelationFilter
    prices?: Vehicle_pricesListRelationFilter
    bookings?: Vehicle_bookingsListRelationFilter
    booking_logs?: Vehicle_bookings_logsListRelationFilter
  }

  export type vehicleOrderByWithRelationInput = {
    id?: SortOrder
    registration_number?: SortOrder
    owner_name?: SortOrder
    insurance_company?: SortOrder
    insurance_number?: SortOrder
    chassis_number?: SortOrder
    rc_image?: SortOrder
    insurance_image?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    kms_driven?: SortOrder
    color?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    brand?: brandsOrderByWithRelationInput
    model?: modelsOrderByWithRelationInput
    variant?: variantsOrderByWithRelationInput
    features?: vehicle_featuresOrderByRelationAggregateInput
    images?: vehicle_imagesOrderByRelationAggregateInput
    availability?: vehicle_availabilityOrderByRelationAggregateInput
    availability_history?: vehicle_availability_historyOrderByRelationAggregateInput
    inspections?: vehicle_inspectionOrderByRelationAggregateInput
    prices?: vehicle_pricesOrderByRelationAggregateInput
    bookings?: vehicle_bookingsOrderByRelationAggregateInput
    booking_logs?: vehicle_bookings_logsOrderByRelationAggregateInput
  }

  export type vehicleWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    registration_number?: string
    chassis_number?: string
    AND?: vehicleWhereInput | vehicleWhereInput[]
    OR?: vehicleWhereInput[]
    NOT?: vehicleWhereInput | vehicleWhereInput[]
    owner_name?: StringFilter<"vehicle"> | string
    insurance_company?: StringFilter<"vehicle"> | string
    insurance_number?: StringFilter<"vehicle"> | string
    rc_image?: StringFilter<"vehicle"> | string
    insurance_image?: StringFilter<"vehicle"> | string
    brand_id?: StringFilter<"vehicle"> | string
    model_id?: StringFilter<"vehicle"> | string
    variant_id?: StringFilter<"vehicle"> | string
    kms_driven?: IntFilter<"vehicle"> | number
    color?: StringFilter<"vehicle"> | string
    mileage?: FloatFilter<"vehicle"> | number
    engine_capacity?: IntFilter<"vehicle"> | number
    createdAt?: DateTimeFilter<"vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle"> | Date | string
    brand?: XOR<BrandsScalarRelationFilter, brandsWhereInput>
    model?: XOR<ModelsScalarRelationFilter, modelsWhereInput>
    variant?: XOR<VariantsScalarRelationFilter, variantsWhereInput>
    features?: Vehicle_featuresListRelationFilter
    images?: Vehicle_imagesListRelationFilter
    availability?: Vehicle_availabilityListRelationFilter
    availability_history?: Vehicle_availability_historyListRelationFilter
    inspections?: Vehicle_inspectionListRelationFilter
    prices?: Vehicle_pricesListRelationFilter
    bookings?: Vehicle_bookingsListRelationFilter
    booking_logs?: Vehicle_bookings_logsListRelationFilter
  }, "id" | "registration_number" | "chassis_number">

  export type vehicleOrderByWithAggregationInput = {
    id?: SortOrder
    registration_number?: SortOrder
    owner_name?: SortOrder
    insurance_company?: SortOrder
    insurance_number?: SortOrder
    chassis_number?: SortOrder
    rc_image?: SortOrder
    insurance_image?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    kms_driven?: SortOrder
    color?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicleCountOrderByAggregateInput
    _avg?: vehicleAvgOrderByAggregateInput
    _max?: vehicleMaxOrderByAggregateInput
    _min?: vehicleMinOrderByAggregateInput
    _sum?: vehicleSumOrderByAggregateInput
  }

  export type vehicleScalarWhereWithAggregatesInput = {
    AND?: vehicleScalarWhereWithAggregatesInput | vehicleScalarWhereWithAggregatesInput[]
    OR?: vehicleScalarWhereWithAggregatesInput[]
    NOT?: vehicleScalarWhereWithAggregatesInput | vehicleScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle"> | string
    registration_number?: StringWithAggregatesFilter<"vehicle"> | string
    owner_name?: StringWithAggregatesFilter<"vehicle"> | string
    insurance_company?: StringWithAggregatesFilter<"vehicle"> | string
    insurance_number?: StringWithAggregatesFilter<"vehicle"> | string
    chassis_number?: StringWithAggregatesFilter<"vehicle"> | string
    rc_image?: StringWithAggregatesFilter<"vehicle"> | string
    insurance_image?: StringWithAggregatesFilter<"vehicle"> | string
    brand_id?: StringWithAggregatesFilter<"vehicle"> | string
    model_id?: StringWithAggregatesFilter<"vehicle"> | string
    variant_id?: StringWithAggregatesFilter<"vehicle"> | string
    kms_driven?: IntWithAggregatesFilter<"vehicle"> | number
    color?: StringWithAggregatesFilter<"vehicle"> | string
    mileage?: FloatWithAggregatesFilter<"vehicle"> | number
    engine_capacity?: IntWithAggregatesFilter<"vehicle"> | number
    createdAt?: DateTimeWithAggregatesFilter<"vehicle"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle"> | Date | string
  }

  export type vehicle_featuresWhereInput = {
    AND?: vehicle_featuresWhereInput | vehicle_featuresWhereInput[]
    OR?: vehicle_featuresWhereInput[]
    NOT?: vehicle_featuresWhereInput | vehicle_featuresWhereInput[]
    id?: StringFilter<"vehicle_features"> | string
    vehicle_id?: StringFilter<"vehicle_features"> | string
    feature_name?: StringFilter<"vehicle_features"> | string
    createdAt?: DateTimeFilter<"vehicle_features"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_features"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }

  export type vehicle_featuresOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    feature_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
  }

  export type vehicle_featuresWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_featuresWhereInput | vehicle_featuresWhereInput[]
    OR?: vehicle_featuresWhereInput[]
    NOT?: vehicle_featuresWhereInput | vehicle_featuresWhereInput[]
    vehicle_id?: StringFilter<"vehicle_features"> | string
    feature_name?: StringFilter<"vehicle_features"> | string
    createdAt?: DateTimeFilter<"vehicle_features"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_features"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }, "id">

  export type vehicle_featuresOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    feature_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_featuresCountOrderByAggregateInput
    _max?: vehicle_featuresMaxOrderByAggregateInput
    _min?: vehicle_featuresMinOrderByAggregateInput
  }

  export type vehicle_featuresScalarWhereWithAggregatesInput = {
    AND?: vehicle_featuresScalarWhereWithAggregatesInput | vehicle_featuresScalarWhereWithAggregatesInput[]
    OR?: vehicle_featuresScalarWhereWithAggregatesInput[]
    NOT?: vehicle_featuresScalarWhereWithAggregatesInput | vehicle_featuresScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_features"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_features"> | string
    feature_name?: StringWithAggregatesFilter<"vehicle_features"> | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_features"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_features"> | Date | string
  }

  export type vehicle_imagesWhereInput = {
    AND?: vehicle_imagesWhereInput | vehicle_imagesWhereInput[]
    OR?: vehicle_imagesWhereInput[]
    NOT?: vehicle_imagesWhereInput | vehicle_imagesWhereInput[]
    id?: StringFilter<"vehicle_images"> | string
    vehicle_id?: StringFilter<"vehicle_images"> | string
    image_url?: StringFilter<"vehicle_images"> | string
    description?: StringFilter<"vehicle_images"> | string
    createdAt?: DateTimeFilter<"vehicle_images"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_images"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }

  export type vehicle_imagesOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    image_url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
  }

  export type vehicle_imagesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_imagesWhereInput | vehicle_imagesWhereInput[]
    OR?: vehicle_imagesWhereInput[]
    NOT?: vehicle_imagesWhereInput | vehicle_imagesWhereInput[]
    vehicle_id?: StringFilter<"vehicle_images"> | string
    image_url?: StringFilter<"vehicle_images"> | string
    description?: StringFilter<"vehicle_images"> | string
    createdAt?: DateTimeFilter<"vehicle_images"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_images"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }, "id">

  export type vehicle_imagesOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    image_url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_imagesCountOrderByAggregateInput
    _max?: vehicle_imagesMaxOrderByAggregateInput
    _min?: vehicle_imagesMinOrderByAggregateInput
  }

  export type vehicle_imagesScalarWhereWithAggregatesInput = {
    AND?: vehicle_imagesScalarWhereWithAggregatesInput | vehicle_imagesScalarWhereWithAggregatesInput[]
    OR?: vehicle_imagesScalarWhereWithAggregatesInput[]
    NOT?: vehicle_imagesScalarWhereWithAggregatesInput | vehicle_imagesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_images"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_images"> | string
    image_url?: StringWithAggregatesFilter<"vehicle_images"> | string
    description?: StringWithAggregatesFilter<"vehicle_images"> | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_images"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_images"> | Date | string
  }

  export type vehicle_availabilityWhereInput = {
    AND?: vehicle_availabilityWhereInput | vehicle_availabilityWhereInput[]
    OR?: vehicle_availabilityWhereInput[]
    NOT?: vehicle_availabilityWhereInput | vehicle_availabilityWhereInput[]
    id?: StringFilter<"vehicle_availability"> | string
    vehicle_id?: StringFilter<"vehicle_availability"> | string
    start_time?: DateTimeFilter<"vehicle_availability"> | Date | string
    end_time?: DateTimeFilter<"vehicle_availability"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_availability"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_availability"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }

  export type vehicle_availabilityOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
  }

  export type vehicle_availabilityWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_availabilityWhereInput | vehicle_availabilityWhereInput[]
    OR?: vehicle_availabilityWhereInput[]
    NOT?: vehicle_availabilityWhereInput | vehicle_availabilityWhereInput[]
    vehicle_id?: StringFilter<"vehicle_availability"> | string
    start_time?: DateTimeFilter<"vehicle_availability"> | Date | string
    end_time?: DateTimeFilter<"vehicle_availability"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_availability"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_availability"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }, "id">

  export type vehicle_availabilityOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_availabilityCountOrderByAggregateInput
    _max?: vehicle_availabilityMaxOrderByAggregateInput
    _min?: vehicle_availabilityMinOrderByAggregateInput
  }

  export type vehicle_availabilityScalarWhereWithAggregatesInput = {
    AND?: vehicle_availabilityScalarWhereWithAggregatesInput | vehicle_availabilityScalarWhereWithAggregatesInput[]
    OR?: vehicle_availabilityScalarWhereWithAggregatesInput[]
    NOT?: vehicle_availabilityScalarWhereWithAggregatesInput | vehicle_availabilityScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_availability"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_availability"> | string
    start_time?: DateTimeWithAggregatesFilter<"vehicle_availability"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"vehicle_availability"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_availability"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_availability"> | Date | string
  }

  export type vehicle_availability_historyWhereInput = {
    AND?: vehicle_availability_historyWhereInput | vehicle_availability_historyWhereInput[]
    OR?: vehicle_availability_historyWhereInput[]
    NOT?: vehicle_availability_historyWhereInput | vehicle_availability_historyWhereInput[]
    id?: StringFilter<"vehicle_availability_history"> | string
    vehicle_id?: StringFilter<"vehicle_availability_history"> | string
    start_time?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    end_time?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }

  export type vehicle_availability_historyOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
  }

  export type vehicle_availability_historyWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_availability_historyWhereInput | vehicle_availability_historyWhereInput[]
    OR?: vehicle_availability_historyWhereInput[]
    NOT?: vehicle_availability_historyWhereInput | vehicle_availability_historyWhereInput[]
    vehicle_id?: StringFilter<"vehicle_availability_history"> | string
    start_time?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    end_time?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
  }, "id">

  export type vehicle_availability_historyOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_availability_historyCountOrderByAggregateInput
    _max?: vehicle_availability_historyMaxOrderByAggregateInput
    _min?: vehicle_availability_historyMinOrderByAggregateInput
  }

  export type vehicle_availability_historyScalarWhereWithAggregatesInput = {
    AND?: vehicle_availability_historyScalarWhereWithAggregatesInput | vehicle_availability_historyScalarWhereWithAggregatesInput[]
    OR?: vehicle_availability_historyScalarWhereWithAggregatesInput[]
    NOT?: vehicle_availability_historyScalarWhereWithAggregatesInput | vehicle_availability_historyScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_availability_history"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_availability_history"> | string
    start_time?: DateTimeWithAggregatesFilter<"vehicle_availability_history"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"vehicle_availability_history"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_availability_history"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_availability_history"> | Date | string
  }

  export type vehicle_inspectionWhereInput = {
    AND?: vehicle_inspectionWhereInput | vehicle_inspectionWhereInput[]
    OR?: vehicle_inspectionWhereInput[]
    NOT?: vehicle_inspectionWhereInput | vehicle_inspectionWhereInput[]
    id?: StringFilter<"vehicle_inspection"> | string
    vehicle_id?: StringFilter<"vehicle_inspection"> | string
    inspection_date?: DateTimeFilter<"vehicle_inspection"> | Date | string
    inspector_name?: StringFilter<"vehicle_inspection"> | string
    createdAt?: DateTimeFilter<"vehicle_inspection"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_inspection"> | Date | string
    vehicle_bookingsId?: StringNullableFilter<"vehicle_inspection"> | string | null
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
    details?: Vehicle_inspection_detailsListRelationFilter
    vehicle_bookings?: XOR<Vehicle_bookingsNullableScalarRelationFilter, vehicle_bookingsWhereInput> | null
  }

  export type vehicle_inspectionOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    inspection_date?: SortOrder
    inspector_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle_bookingsId?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
    details?: vehicle_inspection_detailsOrderByRelationAggregateInput
    vehicle_bookings?: vehicle_bookingsOrderByWithRelationInput
  }

  export type vehicle_inspectionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_inspectionWhereInput | vehicle_inspectionWhereInput[]
    OR?: vehicle_inspectionWhereInput[]
    NOT?: vehicle_inspectionWhereInput | vehicle_inspectionWhereInput[]
    vehicle_id?: StringFilter<"vehicle_inspection"> | string
    inspection_date?: DateTimeFilter<"vehicle_inspection"> | Date | string
    inspector_name?: StringFilter<"vehicle_inspection"> | string
    createdAt?: DateTimeFilter<"vehicle_inspection"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_inspection"> | Date | string
    vehicle_bookingsId?: StringNullableFilter<"vehicle_inspection"> | string | null
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
    details?: Vehicle_inspection_detailsListRelationFilter
    vehicle_bookings?: XOR<Vehicle_bookingsNullableScalarRelationFilter, vehicle_bookingsWhereInput> | null
  }, "id">

  export type vehicle_inspectionOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    inspection_date?: SortOrder
    inspector_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle_bookingsId?: SortOrder
    _count?: vehicle_inspectionCountOrderByAggregateInput
    _max?: vehicle_inspectionMaxOrderByAggregateInput
    _min?: vehicle_inspectionMinOrderByAggregateInput
  }

  export type vehicle_inspectionScalarWhereWithAggregatesInput = {
    AND?: vehicle_inspectionScalarWhereWithAggregatesInput | vehicle_inspectionScalarWhereWithAggregatesInput[]
    OR?: vehicle_inspectionScalarWhereWithAggregatesInput[]
    NOT?: vehicle_inspectionScalarWhereWithAggregatesInput | vehicle_inspectionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_inspection"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_inspection"> | string
    inspection_date?: DateTimeWithAggregatesFilter<"vehicle_inspection"> | Date | string
    inspector_name?: StringWithAggregatesFilter<"vehicle_inspection"> | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_inspection"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_inspection"> | Date | string
    vehicle_bookingsId?: StringNullableWithAggregatesFilter<"vehicle_inspection"> | string | null
  }

  export type vehicle_inspection_detailsWhereInput = {
    AND?: vehicle_inspection_detailsWhereInput | vehicle_inspection_detailsWhereInput[]
    OR?: vehicle_inspection_detailsWhereInput[]
    NOT?: vehicle_inspection_detailsWhereInput | vehicle_inspection_detailsWhereInput[]
    id?: StringFilter<"vehicle_inspection_details"> | string
    checklist_option_id?: StringFilter<"vehicle_inspection_details"> | string
    rating?: IntFilter<"vehicle_inspection_details"> | number
    description?: StringFilter<"vehicle_inspection_details"> | string
    vehicle_inspection_id?: StringFilter<"vehicle_inspection_details"> | string
    createdAt?: DateTimeFilter<"vehicle_inspection_details"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_inspection_details"> | Date | string
    checklist_option?: XOR<Checklist_optionsScalarRelationFilter, checklist_optionsWhereInput>
    vehicle_inspection?: XOR<Vehicle_inspectionScalarRelationFilter, vehicle_inspectionWhereInput>
  }

  export type vehicle_inspection_detailsOrderByWithRelationInput = {
    id?: SortOrder
    checklist_option_id?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    vehicle_inspection_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    checklist_option?: checklist_optionsOrderByWithRelationInput
    vehicle_inspection?: vehicle_inspectionOrderByWithRelationInput
  }

  export type vehicle_inspection_detailsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_inspection_detailsWhereInput | vehicle_inspection_detailsWhereInput[]
    OR?: vehicle_inspection_detailsWhereInput[]
    NOT?: vehicle_inspection_detailsWhereInput | vehicle_inspection_detailsWhereInput[]
    checklist_option_id?: StringFilter<"vehicle_inspection_details"> | string
    rating?: IntFilter<"vehicle_inspection_details"> | number
    description?: StringFilter<"vehicle_inspection_details"> | string
    vehicle_inspection_id?: StringFilter<"vehicle_inspection_details"> | string
    createdAt?: DateTimeFilter<"vehicle_inspection_details"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_inspection_details"> | Date | string
    checklist_option?: XOR<Checklist_optionsScalarRelationFilter, checklist_optionsWhereInput>
    vehicle_inspection?: XOR<Vehicle_inspectionScalarRelationFilter, vehicle_inspectionWhereInput>
  }, "id">

  export type vehicle_inspection_detailsOrderByWithAggregationInput = {
    id?: SortOrder
    checklist_option_id?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    vehicle_inspection_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_inspection_detailsCountOrderByAggregateInput
    _avg?: vehicle_inspection_detailsAvgOrderByAggregateInput
    _max?: vehicle_inspection_detailsMaxOrderByAggregateInput
    _min?: vehicle_inspection_detailsMinOrderByAggregateInput
    _sum?: vehicle_inspection_detailsSumOrderByAggregateInput
  }

  export type vehicle_inspection_detailsScalarWhereWithAggregatesInput = {
    AND?: vehicle_inspection_detailsScalarWhereWithAggregatesInput | vehicle_inspection_detailsScalarWhereWithAggregatesInput[]
    OR?: vehicle_inspection_detailsScalarWhereWithAggregatesInput[]
    NOT?: vehicle_inspection_detailsScalarWhereWithAggregatesInput | vehicle_inspection_detailsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_inspection_details"> | string
    checklist_option_id?: StringWithAggregatesFilter<"vehicle_inspection_details"> | string
    rating?: IntWithAggregatesFilter<"vehicle_inspection_details"> | number
    description?: StringWithAggregatesFilter<"vehicle_inspection_details"> | string
    vehicle_inspection_id?: StringWithAggregatesFilter<"vehicle_inspection_details"> | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_inspection_details"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_inspection_details"> | Date | string
  }

  export type vehicle_pricesWhereInput = {
    AND?: vehicle_pricesWhereInput | vehicle_pricesWhereInput[]
    OR?: vehicle_pricesWhereInput[]
    NOT?: vehicle_pricesWhereInput | vehicle_pricesWhereInput[]
    id?: StringFilter<"vehicle_prices"> | string
    vehicle_id?: StringFilter<"vehicle_prices"> | string
    base_price_per_day?: FloatFilter<"vehicle_prices"> | number
    hr_included?: IntFilter<"vehicle_prices"> | number
    km_included?: IntFilter<"vehicle_prices"> | number
    extra_km_charge?: FloatFilter<"vehicle_prices"> | number
    extra_hr_charge?: FloatFilter<"vehicle_prices"> | number
    is_unlimited_allowed?: BoolFilter<"vehicle_prices"> | boolean
    createdAt?: DateTimeFilter<"vehicle_prices"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_prices"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
    bills?: Vehicle_bookings_billsListRelationFilter
  }

  export type vehicle_pricesOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    is_unlimited_allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
    bills?: vehicle_bookings_billsOrderByRelationAggregateInput
  }

  export type vehicle_pricesWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_pricesWhereInput | vehicle_pricesWhereInput[]
    OR?: vehicle_pricesWhereInput[]
    NOT?: vehicle_pricesWhereInput | vehicle_pricesWhereInput[]
    vehicle_id?: StringFilter<"vehicle_prices"> | string
    base_price_per_day?: FloatFilter<"vehicle_prices"> | number
    hr_included?: IntFilter<"vehicle_prices"> | number
    km_included?: IntFilter<"vehicle_prices"> | number
    extra_km_charge?: FloatFilter<"vehicle_prices"> | number
    extra_hr_charge?: FloatFilter<"vehicle_prices"> | number
    is_unlimited_allowed?: BoolFilter<"vehicle_prices"> | boolean
    createdAt?: DateTimeFilter<"vehicle_prices"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_prices"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
    bills?: Vehicle_bookings_billsListRelationFilter
  }, "id">

  export type vehicle_pricesOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    is_unlimited_allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_pricesCountOrderByAggregateInput
    _avg?: vehicle_pricesAvgOrderByAggregateInput
    _max?: vehicle_pricesMaxOrderByAggregateInput
    _min?: vehicle_pricesMinOrderByAggregateInput
    _sum?: vehicle_pricesSumOrderByAggregateInput
  }

  export type vehicle_pricesScalarWhereWithAggregatesInput = {
    AND?: vehicle_pricesScalarWhereWithAggregatesInput | vehicle_pricesScalarWhereWithAggregatesInput[]
    OR?: vehicle_pricesScalarWhereWithAggregatesInput[]
    NOT?: vehicle_pricesScalarWhereWithAggregatesInput | vehicle_pricesScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_prices"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_prices"> | string
    base_price_per_day?: FloatWithAggregatesFilter<"vehicle_prices"> | number
    hr_included?: IntWithAggregatesFilter<"vehicle_prices"> | number
    km_included?: IntWithAggregatesFilter<"vehicle_prices"> | number
    extra_km_charge?: FloatWithAggregatesFilter<"vehicle_prices"> | number
    extra_hr_charge?: FloatWithAggregatesFilter<"vehicle_prices"> | number
    is_unlimited_allowed?: BoolWithAggregatesFilter<"vehicle_prices"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_prices"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_prices"> | Date | string
  }

  export type customerWhereInput = {
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    id?: StringFilter<"customer"> | string
    name?: StringFilter<"customer"> | string
    email_id?: StringFilter<"customer"> | string
    mobile_number?: StringFilter<"customer"> | string
    alternate_mobile_number?: StringNullableFilter<"customer"> | string | null
    address?: StringFilter<"customer"> | string
    city_id?: StringFilter<"customer"> | string
    state_id?: StringFilter<"customer"> | string
    pin_code?: StringFilter<"customer"> | string
    adhaar_number?: StringFilter<"customer"> | string
    adhar_front_image?: StringFilter<"customer"> | string
    adhar_back_image?: StringFilter<"customer"> | string
    driving_license_number?: StringFilter<"customer"> | string
    driving_license_front_image?: StringFilter<"customer"> | string
    driving_license_back_image?: StringFilter<"customer"> | string
    profile_image?: StringNullableFilter<"customer"> | string | null
    is_active?: BoolFilter<"customer"> | boolean
    createdAt?: DateTimeFilter<"customer"> | Date | string
    updatedAt?: DateTimeFilter<"customer"> | Date | string
    city?: XOR<CitiesScalarRelationFilter, citiesWhereInput>
    state?: XOR<StatesScalarRelationFilter, statesWhereInput>
    vehicle_bookings?: Vehicle_bookingsListRelationFilter
    vehicle_bookings_logs?: Vehicle_bookings_logsListRelationFilter
    vehicle_bookings_bills?: Vehicle_bookings_billsListRelationFilter
  }

  export type customerOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    city_id?: SortOrder
    state_id?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    driving_license_number?: SortOrder
    driving_license_front_image?: SortOrder
    driving_license_back_image?: SortOrder
    profile_image?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: citiesOrderByWithRelationInput
    state?: statesOrderByWithRelationInput
    vehicle_bookings?: vehicle_bookingsOrderByRelationAggregateInput
    vehicle_bookings_logs?: vehicle_bookings_logsOrderByRelationAggregateInput
    vehicle_bookings_bills?: vehicle_bookings_billsOrderByRelationAggregateInput
  }

  export type customerWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email_id?: string
    adhaar_number?: string
    driving_license_number?: string
    AND?: customerWhereInput | customerWhereInput[]
    OR?: customerWhereInput[]
    NOT?: customerWhereInput | customerWhereInput[]
    name?: StringFilter<"customer"> | string
    mobile_number?: StringFilter<"customer"> | string
    alternate_mobile_number?: StringNullableFilter<"customer"> | string | null
    address?: StringFilter<"customer"> | string
    city_id?: StringFilter<"customer"> | string
    state_id?: StringFilter<"customer"> | string
    pin_code?: StringFilter<"customer"> | string
    adhar_front_image?: StringFilter<"customer"> | string
    adhar_back_image?: StringFilter<"customer"> | string
    driving_license_front_image?: StringFilter<"customer"> | string
    driving_license_back_image?: StringFilter<"customer"> | string
    profile_image?: StringNullableFilter<"customer"> | string | null
    is_active?: BoolFilter<"customer"> | boolean
    createdAt?: DateTimeFilter<"customer"> | Date | string
    updatedAt?: DateTimeFilter<"customer"> | Date | string
    city?: XOR<CitiesScalarRelationFilter, citiesWhereInput>
    state?: XOR<StatesScalarRelationFilter, statesWhereInput>
    vehicle_bookings?: Vehicle_bookingsListRelationFilter
    vehicle_bookings_logs?: Vehicle_bookings_logsListRelationFilter
    vehicle_bookings_bills?: Vehicle_bookings_billsListRelationFilter
  }, "id" | "email_id" | "adhaar_number" | "driving_license_number">

  export type customerOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    city_id?: SortOrder
    state_id?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    driving_license_number?: SortOrder
    driving_license_front_image?: SortOrder
    driving_license_back_image?: SortOrder
    profile_image?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: customerCountOrderByAggregateInput
    _max?: customerMaxOrderByAggregateInput
    _min?: customerMinOrderByAggregateInput
  }

  export type customerScalarWhereWithAggregatesInput = {
    AND?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    OR?: customerScalarWhereWithAggregatesInput[]
    NOT?: customerScalarWhereWithAggregatesInput | customerScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"customer"> | string
    name?: StringWithAggregatesFilter<"customer"> | string
    email_id?: StringWithAggregatesFilter<"customer"> | string
    mobile_number?: StringWithAggregatesFilter<"customer"> | string
    alternate_mobile_number?: StringNullableWithAggregatesFilter<"customer"> | string | null
    address?: StringWithAggregatesFilter<"customer"> | string
    city_id?: StringWithAggregatesFilter<"customer"> | string
    state_id?: StringWithAggregatesFilter<"customer"> | string
    pin_code?: StringWithAggregatesFilter<"customer"> | string
    adhaar_number?: StringWithAggregatesFilter<"customer"> | string
    adhar_front_image?: StringWithAggregatesFilter<"customer"> | string
    adhar_back_image?: StringWithAggregatesFilter<"customer"> | string
    driving_license_number?: StringWithAggregatesFilter<"customer"> | string
    driving_license_front_image?: StringWithAggregatesFilter<"customer"> | string
    driving_license_back_image?: StringWithAggregatesFilter<"customer"> | string
    profile_image?: StringNullableWithAggregatesFilter<"customer"> | string | null
    is_active?: BoolWithAggregatesFilter<"customer"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"customer"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"customer"> | Date | string
  }

  export type providersWhereInput = {
    AND?: providersWhereInput | providersWhereInput[]
    OR?: providersWhereInput[]
    NOT?: providersWhereInput | providersWhereInput[]
    id?: StringFilter<"providers"> | string
    name?: StringFilter<"providers"> | string
    email_id?: StringFilter<"providers"> | string
    mobile_number?: StringFilter<"providers"> | string
    alternate_mobile_number?: StringNullableFilter<"providers"> | string | null
    address?: StringFilter<"providers"> | string
    cityId?: StringFilter<"providers"> | string
    stateId?: StringFilter<"providers"> | string
    pin_code?: StringFilter<"providers"> | string
    adhaar_number?: StringFilter<"providers"> | string
    adhar_front_image?: StringFilter<"providers"> | string
    adhar_back_image?: StringFilter<"providers"> | string
    pan_number?: StringFilter<"providers"> | string
    pan_image?: StringFilter<"providers"> | string
    profile_image?: StringNullableFilter<"providers"> | string | null
    is_approved?: BoolFilter<"providers"> | boolean
    is_active?: BoolFilter<"providers"> | boolean
    rejection_reason?: StringNullableFilter<"providers"> | string | null
    createdAt?: DateTimeFilter<"providers"> | Date | string
    updatedAt?: DateTimeFilter<"providers"> | Date | string
    city?: XOR<CitiesScalarRelationFilter, citiesWhereInput>
    state?: XOR<StatesScalarRelationFilter, statesWhereInput>
  }

  export type providersOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    pan_number?: SortOrder
    pan_image?: SortOrder
    profile_image?: SortOrder
    is_approved?: SortOrder
    is_active?: SortOrder
    rejection_reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    city?: citiesOrderByWithRelationInput
    state?: statesOrderByWithRelationInput
  }

  export type providersWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email_id?: string
    adhaar_number?: string
    pan_number?: string
    AND?: providersWhereInput | providersWhereInput[]
    OR?: providersWhereInput[]
    NOT?: providersWhereInput | providersWhereInput[]
    name?: StringFilter<"providers"> | string
    mobile_number?: StringFilter<"providers"> | string
    alternate_mobile_number?: StringNullableFilter<"providers"> | string | null
    address?: StringFilter<"providers"> | string
    cityId?: StringFilter<"providers"> | string
    stateId?: StringFilter<"providers"> | string
    pin_code?: StringFilter<"providers"> | string
    adhar_front_image?: StringFilter<"providers"> | string
    adhar_back_image?: StringFilter<"providers"> | string
    pan_image?: StringFilter<"providers"> | string
    profile_image?: StringNullableFilter<"providers"> | string | null
    is_approved?: BoolFilter<"providers"> | boolean
    is_active?: BoolFilter<"providers"> | boolean
    rejection_reason?: StringNullableFilter<"providers"> | string | null
    createdAt?: DateTimeFilter<"providers"> | Date | string
    updatedAt?: DateTimeFilter<"providers"> | Date | string
    city?: XOR<CitiesScalarRelationFilter, citiesWhereInput>
    state?: XOR<StatesScalarRelationFilter, statesWhereInput>
  }, "id" | "email_id" | "adhaar_number" | "pan_number">

  export type providersOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    pan_number?: SortOrder
    pan_image?: SortOrder
    profile_image?: SortOrder
    is_approved?: SortOrder
    is_active?: SortOrder
    rejection_reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: providersCountOrderByAggregateInput
    _max?: providersMaxOrderByAggregateInput
    _min?: providersMinOrderByAggregateInput
  }

  export type providersScalarWhereWithAggregatesInput = {
    AND?: providersScalarWhereWithAggregatesInput | providersScalarWhereWithAggregatesInput[]
    OR?: providersScalarWhereWithAggregatesInput[]
    NOT?: providersScalarWhereWithAggregatesInput | providersScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"providers"> | string
    name?: StringWithAggregatesFilter<"providers"> | string
    email_id?: StringWithAggregatesFilter<"providers"> | string
    mobile_number?: StringWithAggregatesFilter<"providers"> | string
    alternate_mobile_number?: StringNullableWithAggregatesFilter<"providers"> | string | null
    address?: StringWithAggregatesFilter<"providers"> | string
    cityId?: StringWithAggregatesFilter<"providers"> | string
    stateId?: StringWithAggregatesFilter<"providers"> | string
    pin_code?: StringWithAggregatesFilter<"providers"> | string
    adhaar_number?: StringWithAggregatesFilter<"providers"> | string
    adhar_front_image?: StringWithAggregatesFilter<"providers"> | string
    adhar_back_image?: StringWithAggregatesFilter<"providers"> | string
    pan_number?: StringWithAggregatesFilter<"providers"> | string
    pan_image?: StringWithAggregatesFilter<"providers"> | string
    profile_image?: StringNullableWithAggregatesFilter<"providers"> | string | null
    is_approved?: BoolWithAggregatesFilter<"providers"> | boolean
    is_active?: BoolWithAggregatesFilter<"providers"> | boolean
    rejection_reason?: StringNullableWithAggregatesFilter<"providers"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"providers"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"providers"> | Date | string
  }

  export type vehicle_bookingsWhereInput = {
    AND?: vehicle_bookingsWhereInput | vehicle_bookingsWhereInput[]
    OR?: vehicle_bookingsWhereInput[]
    NOT?: vehicle_bookingsWhereInput | vehicle_bookingsWhereInput[]
    id?: StringFilter<"vehicle_bookings"> | string
    booking_number?: StringFilter<"vehicle_bookings"> | string
    vehicle_id?: StringFilter<"vehicle_bookings"> | string
    customer_id?: StringFilter<"vehicle_bookings"> | string
    start_time?: DateTimeFilter<"vehicle_bookings"> | Date | string
    end_time?: DateTimeFilter<"vehicle_bookings"> | Date | string
    booking_status_id?: StringNullableFilter<"vehicle_bookings"> | string | null
    createdAt?: DateTimeFilter<"vehicle_bookings"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    vehicle_inspection?: Vehicle_inspectionListRelationFilter
    booking_logs?: Vehicle_bookings_logsListRelationFilter
    bills?: Vehicle_bookings_billsListRelationFilter
  }

  export type vehicle_bookingsOrderByWithRelationInput = {
    id?: SortOrder
    booking_number?: SortOrder
    vehicle_id?: SortOrder
    customer_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    booking_status_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    vehicle_inspection?: vehicle_inspectionOrderByRelationAggregateInput
    booking_logs?: vehicle_bookings_logsOrderByRelationAggregateInput
    bills?: vehicle_bookings_billsOrderByRelationAggregateInput
  }

  export type vehicle_bookingsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    booking_number?: string
    AND?: vehicle_bookingsWhereInput | vehicle_bookingsWhereInput[]
    OR?: vehicle_bookingsWhereInput[]
    NOT?: vehicle_bookingsWhereInput | vehicle_bookingsWhereInput[]
    vehicle_id?: StringFilter<"vehicle_bookings"> | string
    customer_id?: StringFilter<"vehicle_bookings"> | string
    start_time?: DateTimeFilter<"vehicle_bookings"> | Date | string
    end_time?: DateTimeFilter<"vehicle_bookings"> | Date | string
    booking_status_id?: StringNullableFilter<"vehicle_bookings"> | string | null
    createdAt?: DateTimeFilter<"vehicle_bookings"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings"> | Date | string
    vehicle?: XOR<VehicleScalarRelationFilter, vehicleWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    vehicle_inspection?: Vehicle_inspectionListRelationFilter
    booking_logs?: Vehicle_bookings_logsListRelationFilter
    bills?: Vehicle_bookings_billsListRelationFilter
  }, "id" | "booking_number">

  export type vehicle_bookingsOrderByWithAggregationInput = {
    id?: SortOrder
    booking_number?: SortOrder
    vehicle_id?: SortOrder
    customer_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    booking_status_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_bookingsCountOrderByAggregateInput
    _max?: vehicle_bookingsMaxOrderByAggregateInput
    _min?: vehicle_bookingsMinOrderByAggregateInput
  }

  export type vehicle_bookingsScalarWhereWithAggregatesInput = {
    AND?: vehicle_bookingsScalarWhereWithAggregatesInput | vehicle_bookingsScalarWhereWithAggregatesInput[]
    OR?: vehicle_bookingsScalarWhereWithAggregatesInput[]
    NOT?: vehicle_bookingsScalarWhereWithAggregatesInput | vehicle_bookingsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_bookings"> | string
    booking_number?: StringWithAggregatesFilter<"vehicle_bookings"> | string
    vehicle_id?: StringWithAggregatesFilter<"vehicle_bookings"> | string
    customer_id?: StringWithAggregatesFilter<"vehicle_bookings"> | string
    start_time?: DateTimeWithAggregatesFilter<"vehicle_bookings"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"vehicle_bookings"> | Date | string
    booking_status_id?: StringNullableWithAggregatesFilter<"vehicle_bookings"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_bookings"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_bookings"> | Date | string
  }

  export type vehicle_bookings_logsWhereInput = {
    AND?: vehicle_bookings_logsWhereInput | vehicle_bookings_logsWhereInput[]
    OR?: vehicle_bookings_logsWhereInput[]
    NOT?: vehicle_bookings_logsWhereInput | vehicle_bookings_logsWhereInput[]
    id?: StringFilter<"vehicle_bookings_logs"> | string
    vehicle_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    vehicle_booking_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    booking_number?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    start_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    end_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    customer_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    booking_status_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    logged_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    vehicle?: XOR<VehicleNullableScalarRelationFilter, vehicleWhereInput> | null
    vehicle_booking?: XOR<Vehicle_bookingsNullableScalarRelationFilter, vehicle_bookingsWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
  }

  export type vehicle_bookings_logsOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    vehicle_booking_id?: SortOrder
    booking_number?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    customer_id?: SortOrder
    booking_status_id?: SortOrder
    logged_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle?: vehicleOrderByWithRelationInput
    vehicle_booking?: vehicle_bookingsOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
  }

  export type vehicle_bookings_logsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_bookings_logsWhereInput | vehicle_bookings_logsWhereInput[]
    OR?: vehicle_bookings_logsWhereInput[]
    NOT?: vehicle_bookings_logsWhereInput | vehicle_bookings_logsWhereInput[]
    vehicle_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    vehicle_booking_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    booking_number?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    start_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    end_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    customer_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    booking_status_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    logged_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    vehicle?: XOR<VehicleNullableScalarRelationFilter, vehicleWhereInput> | null
    vehicle_booking?: XOR<Vehicle_bookingsNullableScalarRelationFilter, vehicle_bookingsWhereInput> | null
    customer?: XOR<CustomerNullableScalarRelationFilter, customerWhereInput> | null
  }, "id">

  export type vehicle_bookings_logsOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    vehicle_booking_id?: SortOrder
    booking_number?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    customer_id?: SortOrder
    booking_status_id?: SortOrder
    logged_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_bookings_logsCountOrderByAggregateInput
    _max?: vehicle_bookings_logsMaxOrderByAggregateInput
    _min?: vehicle_bookings_logsMinOrderByAggregateInput
  }

  export type vehicle_bookings_logsScalarWhereWithAggregatesInput = {
    AND?: vehicle_bookings_logsScalarWhereWithAggregatesInput | vehicle_bookings_logsScalarWhereWithAggregatesInput[]
    OR?: vehicle_bookings_logsScalarWhereWithAggregatesInput[]
    NOT?: vehicle_bookings_logsScalarWhereWithAggregatesInput | vehicle_bookings_logsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_bookings_logs"> | string
    vehicle_id?: StringNullableWithAggregatesFilter<"vehicle_bookings_logs"> | string | null
    vehicle_booking_id?: StringNullableWithAggregatesFilter<"vehicle_bookings_logs"> | string | null
    booking_number?: StringNullableWithAggregatesFilter<"vehicle_bookings_logs"> | string | null
    start_time?: DateTimeWithAggregatesFilter<"vehicle_bookings_logs"> | Date | string
    end_time?: DateTimeWithAggregatesFilter<"vehicle_bookings_logs"> | Date | string
    customer_id?: StringNullableWithAggregatesFilter<"vehicle_bookings_logs"> | string | null
    booking_status_id?: StringNullableWithAggregatesFilter<"vehicle_bookings_logs"> | string | null
    logged_time?: DateTimeWithAggregatesFilter<"vehicle_bookings_logs"> | Date | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_bookings_logs"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_bookings_logs"> | Date | string
  }

  export type vehicle_bookings_billsWhereInput = {
    AND?: vehicle_bookings_billsWhereInput | vehicle_bookings_billsWhereInput[]
    OR?: vehicle_bookings_billsWhereInput[]
    NOT?: vehicle_bookings_billsWhereInput | vehicle_bookings_billsWhereInput[]
    id?: StringFilter<"vehicle_bookings_bills"> | string
    vehicle_booking_id?: StringFilter<"vehicle_bookings_bills"> | string
    base_price?: FloatFilter<"vehicle_bookings_bills"> | number
    vehicle_price_id?: StringFilter<"vehicle_bookings_bills"> | string
    total_price?: FloatFilter<"vehicle_bookings_bills"> | number
    extra_km_charge?: FloatFilter<"vehicle_bookings_bills"> | number
    extra_hr_charge?: FloatFilter<"vehicle_bookings_bills"> | number
    customer_id?: StringFilter<"vehicle_bookings_bills"> | string
    createdAt?: DateTimeFilter<"vehicle_bookings_bills"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings_bills"> | Date | string
    vehicle_booking?: XOR<Vehicle_bookingsScalarRelationFilter, vehicle_bookingsWhereInput>
    vehicle_price?: XOR<Vehicle_pricesScalarRelationFilter, vehicle_pricesWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    bills_payment?: Bills_paymentListRelationFilter
  }

  export type vehicle_bookings_billsOrderByWithRelationInput = {
    id?: SortOrder
    vehicle_booking_id?: SortOrder
    base_price?: SortOrder
    vehicle_price_id?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle_booking?: vehicle_bookingsOrderByWithRelationInput
    vehicle_price?: vehicle_pricesOrderByWithRelationInput
    customer?: customerOrderByWithRelationInput
    bills_payment?: bills_paymentOrderByRelationAggregateInput
  }

  export type vehicle_bookings_billsWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: vehicle_bookings_billsWhereInput | vehicle_bookings_billsWhereInput[]
    OR?: vehicle_bookings_billsWhereInput[]
    NOT?: vehicle_bookings_billsWhereInput | vehicle_bookings_billsWhereInput[]
    vehicle_booking_id?: StringFilter<"vehicle_bookings_bills"> | string
    base_price?: FloatFilter<"vehicle_bookings_bills"> | number
    vehicle_price_id?: StringFilter<"vehicle_bookings_bills"> | string
    total_price?: FloatFilter<"vehicle_bookings_bills"> | number
    extra_km_charge?: FloatFilter<"vehicle_bookings_bills"> | number
    extra_hr_charge?: FloatFilter<"vehicle_bookings_bills"> | number
    customer_id?: StringFilter<"vehicle_bookings_bills"> | string
    createdAt?: DateTimeFilter<"vehicle_bookings_bills"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings_bills"> | Date | string
    vehicle_booking?: XOR<Vehicle_bookingsScalarRelationFilter, vehicle_bookingsWhereInput>
    vehicle_price?: XOR<Vehicle_pricesScalarRelationFilter, vehicle_pricesWhereInput>
    customer?: XOR<CustomerScalarRelationFilter, customerWhereInput>
    bills_payment?: Bills_paymentListRelationFilter
  }, "id">

  export type vehicle_bookings_billsOrderByWithAggregationInput = {
    id?: SortOrder
    vehicle_booking_id?: SortOrder
    base_price?: SortOrder
    vehicle_price_id?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: vehicle_bookings_billsCountOrderByAggregateInput
    _avg?: vehicle_bookings_billsAvgOrderByAggregateInput
    _max?: vehicle_bookings_billsMaxOrderByAggregateInput
    _min?: vehicle_bookings_billsMinOrderByAggregateInput
    _sum?: vehicle_bookings_billsSumOrderByAggregateInput
  }

  export type vehicle_bookings_billsScalarWhereWithAggregatesInput = {
    AND?: vehicle_bookings_billsScalarWhereWithAggregatesInput | vehicle_bookings_billsScalarWhereWithAggregatesInput[]
    OR?: vehicle_bookings_billsScalarWhereWithAggregatesInput[]
    NOT?: vehicle_bookings_billsScalarWhereWithAggregatesInput | vehicle_bookings_billsScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"vehicle_bookings_bills"> | string
    vehicle_booking_id?: StringWithAggregatesFilter<"vehicle_bookings_bills"> | string
    base_price?: FloatWithAggregatesFilter<"vehicle_bookings_bills"> | number
    vehicle_price_id?: StringWithAggregatesFilter<"vehicle_bookings_bills"> | string
    total_price?: FloatWithAggregatesFilter<"vehicle_bookings_bills"> | number
    extra_km_charge?: FloatWithAggregatesFilter<"vehicle_bookings_bills"> | number
    extra_hr_charge?: FloatWithAggregatesFilter<"vehicle_bookings_bills"> | number
    customer_id?: StringWithAggregatesFilter<"vehicle_bookings_bills"> | string
    createdAt?: DateTimeWithAggregatesFilter<"vehicle_bookings_bills"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"vehicle_bookings_bills"> | Date | string
  }

  export type bills_paymentWhereInput = {
    AND?: bills_paymentWhereInput | bills_paymentWhereInput[]
    OR?: bills_paymentWhereInput[]
    NOT?: bills_paymentWhereInput | bills_paymentWhereInput[]
    id?: StringFilter<"bills_payment"> | string
    bill_id?: StringFilter<"bills_payment"> | string
    amount?: FloatFilter<"bills_payment"> | number
    payment_method?: StringFilter<"bills_payment"> | string
    createdAt?: DateTimeFilter<"bills_payment"> | Date | string
    updatedAt?: DateTimeFilter<"bills_payment"> | Date | string
    bill?: XOR<Vehicle_bookings_billsScalarRelationFilter, vehicle_bookings_billsWhereInput>
  }

  export type bills_paymentOrderByWithRelationInput = {
    id?: SortOrder
    bill_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    bill?: vehicle_bookings_billsOrderByWithRelationInput
  }

  export type bills_paymentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: bills_paymentWhereInput | bills_paymentWhereInput[]
    OR?: bills_paymentWhereInput[]
    NOT?: bills_paymentWhereInput | bills_paymentWhereInput[]
    bill_id?: StringFilter<"bills_payment"> | string
    amount?: FloatFilter<"bills_payment"> | number
    payment_method?: StringFilter<"bills_payment"> | string
    createdAt?: DateTimeFilter<"bills_payment"> | Date | string
    updatedAt?: DateTimeFilter<"bills_payment"> | Date | string
    bill?: XOR<Vehicle_bookings_billsScalarRelationFilter, vehicle_bookings_billsWhereInput>
  }, "id">

  export type bills_paymentOrderByWithAggregationInput = {
    id?: SortOrder
    bill_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: bills_paymentCountOrderByAggregateInput
    _avg?: bills_paymentAvgOrderByAggregateInput
    _max?: bills_paymentMaxOrderByAggregateInput
    _min?: bills_paymentMinOrderByAggregateInput
    _sum?: bills_paymentSumOrderByAggregateInput
  }

  export type bills_paymentScalarWhereWithAggregatesInput = {
    AND?: bills_paymentScalarWhereWithAggregatesInput | bills_paymentScalarWhereWithAggregatesInput[]
    OR?: bills_paymentScalarWhereWithAggregatesInput[]
    NOT?: bills_paymentScalarWhereWithAggregatesInput | bills_paymentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"bills_payment"> | string
    bill_id?: StringWithAggregatesFilter<"bills_payment"> | string
    amount?: FloatWithAggregatesFilter<"bills_payment"> | number
    payment_method?: StringWithAggregatesFilter<"bills_payment"> | string
    createdAt?: DateTimeWithAggregatesFilter<"bills_payment"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"bills_payment"> | Date | string
  }

  export type usersCreateInput = {
    id?: string
    name: string
    username: string
    role_id: $Enums.role
    is_active?: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUncheckedCreateInput = {
    id?: string
    name: string
    username: string
    role_id: $Enums.role
    is_active?: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    role_id?: EnumroleFieldUpdateOperationsInput | $Enums.role
    is_active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    role_id?: EnumroleFieldUpdateOperationsInput | $Enums.role
    is_active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersCreateManyInput = {
    id?: string
    name: string
    username: string
    role_id: $Enums.role
    is_active?: boolean
    password: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type usersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    role_id?: EnumroleFieldUpdateOperationsInput | $Enums.role
    is_active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type usersUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    username?: StringFieldUpdateOperationsInput | string
    role_id?: EnumroleFieldUpdateOperationsInput | $Enums.role
    is_active?: BoolFieldUpdateOperationsInput | boolean
    password?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: modelsCreateNestedManyWithoutBrandInput
    variants?: variantsCreateNestedManyWithoutBrandInput
    vehicle?: vehicleCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: modelsUncheckedCreateNestedManyWithoutBrandInput
    variants?: variantsUncheckedCreateNestedManyWithoutBrandInput
    vehicle?: vehicleUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUpdateManyWithoutBrandNestedInput
    variants?: variantsUpdateManyWithoutBrandNestedInput
    vehicle?: vehicleUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUncheckedUpdateManyWithoutBrandNestedInput
    variants?: variantsUncheckedUpdateManyWithoutBrandNestedInput
    vehicle?: vehicleUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type brandsCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type brandsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type brandsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modelsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutModelsInput
    variants?: variantsCreateNestedManyWithoutModelInput
    vehicle?: vehicleCreateNestedManyWithoutModelInput
  }

  export type modelsUncheckedCreateInput = {
    id?: string
    name: string
    brand_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: variantsUncheckedCreateNestedManyWithoutModelInput
    vehicle?: vehicleUncheckedCreateNestedManyWithoutModelInput
  }

  export type modelsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutModelsNestedInput
    variants?: variantsUpdateManyWithoutModelNestedInput
    vehicle?: vehicleUpdateManyWithoutModelNestedInput
  }

  export type modelsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUncheckedUpdateManyWithoutModelNestedInput
    vehicle?: vehicleUncheckedUpdateManyWithoutModelNestedInput
  }

  export type modelsCreateManyInput = {
    id?: string
    name: string
    brand_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type modelsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modelsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type variantsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    model: modelsCreateNestedOneWithoutVariantsInput
    brand?: brandsCreateNestedOneWithoutVariantsInput
    vehicle?: vehicleCreateNestedManyWithoutVariantInput
  }

  export type variantsUncheckedCreateInput = {
    id?: string
    name: string
    model_id: string
    brand_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleUncheckedCreateNestedManyWithoutVariantInput
  }

  export type variantsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: modelsUpdateOneRequiredWithoutVariantsNestedInput
    brand?: brandsUpdateOneWithoutVariantsNestedInput
    vehicle?: vehicleUpdateManyWithoutVariantNestedInput
  }

  export type variantsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type variantsCreateManyInput = {
    id?: string
    name: string
    model_id: string
    brand_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type variantsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type variantsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type statesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: citiesCreateNestedManyWithoutStateInput
    customers?: customerCreateNestedManyWithoutStateInput
    providers?: providersCreateNestedManyWithoutStateInput
  }

  export type statesUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: citiesUncheckedCreateNestedManyWithoutStateInput
    customers?: customerUncheckedCreateNestedManyWithoutStateInput
    providers?: providersUncheckedCreateNestedManyWithoutStateInput
  }

  export type statesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUpdateManyWithoutStateNestedInput
    customers?: customerUpdateManyWithoutStateNestedInput
    providers?: providersUpdateManyWithoutStateNestedInput
  }

  export type statesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUncheckedUpdateManyWithoutStateNestedInput
    customers?: customerUncheckedUpdateManyWithoutStateNestedInput
    providers?: providersUncheckedUpdateManyWithoutStateNestedInput
  }

  export type statesCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type statesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type statesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type citiesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    state: statesCreateNestedOneWithoutCitiesInput
    customers?: customerCreateNestedManyWithoutCityInput
    providers?: providersCreateNestedManyWithoutCityInput
  }

  export type citiesUncheckedCreateInput = {
    id?: string
    name: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: customerUncheckedCreateNestedManyWithoutCityInput
    providers?: providersUncheckedCreateNestedManyWithoutCityInput
  }

  export type citiesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: statesUpdateOneRequiredWithoutCitiesNestedInput
    customers?: customerUpdateManyWithoutCityNestedInput
    providers?: providersUpdateManyWithoutCityNestedInput
  }

  export type citiesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customerUncheckedUpdateManyWithoutCityNestedInput
    providers?: providersUncheckedUpdateManyWithoutCityNestedInput
  }

  export type citiesCreateManyInput = {
    id?: string
    name: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type citiesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type citiesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checklist_categoriesCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: checklist_optionsCreateNestedManyWithoutCategoryInput
  }

  export type checklist_categoriesUncheckedCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    options?: checklist_optionsUncheckedCreateNestedManyWithoutCategoryInput
  }

  export type checklist_categoriesUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: checklist_optionsUpdateManyWithoutCategoryNestedInput
  }

  export type checklist_categoriesUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    options?: checklist_optionsUncheckedUpdateManyWithoutCategoryNestedInput
  }

  export type checklist_categoriesCreateManyInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type checklist_categoriesUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checklist_categoriesUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checklist_optionsCreateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: checklist_categoriesCreateNestedOneWithoutOptionsInput
    inspectionDetails?: vehicle_inspection_detailsCreateNestedManyWithoutChecklist_optionInput
  }

  export type checklist_optionsUncheckedCreateInput = {
    id?: string
    name: string
    category_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inspectionDetails?: vehicle_inspection_detailsUncheckedCreateNestedManyWithoutChecklist_optionInput
  }

  export type checklist_optionsUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: checklist_categoriesUpdateOneRequiredWithoutOptionsNestedInput
    inspectionDetails?: vehicle_inspection_detailsUpdateManyWithoutChecklist_optionNestedInput
  }

  export type checklist_optionsUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspectionDetails?: vehicle_inspection_detailsUncheckedUpdateManyWithoutChecklist_optionNestedInput
  }

  export type checklist_optionsCreateManyInput = {
    id?: string
    name: string
    category_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type checklist_optionsUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checklist_optionsUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicleCreateInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUpdateInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleCreateManyInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicleUpdateManyMutationInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicleUncheckedUpdateManyInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresCreateInput = {
    id?: string
    feature_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutFeaturesInput
  }

  export type vehicle_featuresUncheckedCreateInput = {
    id?: string
    vehicle_id: string
    feature_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_featuresUpdateInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutFeaturesNestedInput
  }

  export type vehicle_featuresUncheckedUpdateInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresCreateManyInput = {
    id?: string
    vehicle_id: string
    feature_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_featuresUpdateManyMutationInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresUncheckedUpdateManyInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_imagesCreateInput = {
    id?: string
    image_url: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutImagesInput
  }

  export type vehicle_imagesUncheckedCreateInput = {
    id?: string
    vehicle_id: string
    image_url: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_imagesUpdateInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutImagesNestedInput
  }

  export type vehicle_imagesUncheckedUpdateInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_imagesCreateManyInput = {
    id?: string
    vehicle_id: string
    image_url: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_imagesUpdateManyMutationInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_imagesUncheckedUpdateManyInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availabilityCreateInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutAvailabilityInput
  }

  export type vehicle_availabilityUncheckedCreateInput = {
    id?: string
    vehicle_id: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availabilityUpdateInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutAvailabilityNestedInput
  }

  export type vehicle_availabilityUncheckedUpdateInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availabilityCreateManyInput = {
    id?: string
    vehicle_id: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availabilityUpdateManyMutationInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availabilityUncheckedUpdateManyInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availability_historyCreateInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutAvailability_historyInput
  }

  export type vehicle_availability_historyUncheckedCreateInput = {
    id?: string
    vehicle_id: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availability_historyUpdateInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutAvailability_historyNestedInput
  }

  export type vehicle_availability_historyUncheckedUpdateInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availability_historyCreateManyInput = {
    id?: string
    vehicle_id: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availability_historyUpdateManyMutationInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availability_historyUncheckedUpdateManyInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspectionCreateInput = {
    id?: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutInspectionsInput
    details?: vehicle_inspection_detailsCreateNestedManyWithoutVehicle_inspectionInput
    vehicle_bookings?: vehicle_bookingsCreateNestedOneWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionUncheckedCreateInput = {
    id?: string
    vehicle_id: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookingsId?: string | null
    details?: vehicle_inspection_detailsUncheckedCreateNestedManyWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionUpdateInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutInspectionsNestedInput
    details?: vehicle_inspection_detailsUpdateManyWithoutVehicle_inspectionNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateOneWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionUncheckedUpdateInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookingsId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: vehicle_inspection_detailsUncheckedUpdateManyWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionCreateManyInput = {
    id?: string
    vehicle_id: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookingsId?: string | null
  }

  export type vehicle_inspectionUpdateManyMutationInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspectionUncheckedUpdateManyInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookingsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicle_inspection_detailsCreateInput = {
    id?: string
    rating: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checklist_option: checklist_optionsCreateNestedOneWithoutInspectionDetailsInput
    vehicle_inspection: vehicle_inspectionCreateNestedOneWithoutDetailsInput
  }

  export type vehicle_inspection_detailsUncheckedCreateInput = {
    id?: string
    checklist_option_id: string
    rating: number
    description: string
    vehicle_inspection_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspection_detailsUpdateInput = {
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklist_option?: checklist_optionsUpdateOneRequiredWithoutInspectionDetailsNestedInput
    vehicle_inspection?: vehicle_inspectionUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type vehicle_inspection_detailsUncheckedUpdateInput = {
    checklist_option_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vehicle_inspection_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsCreateManyInput = {
    id?: string
    checklist_option_id: string
    rating: number
    description: string
    vehicle_inspection_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspection_detailsUpdateManyMutationInput = {
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsUncheckedUpdateManyInput = {
    checklist_option_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vehicle_inspection_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_pricesCreateInput = {
    id?: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutPricesInput
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_priceInput
  }

  export type vehicle_pricesUncheckedCreateInput = {
    id?: string
    vehicle_id: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_priceInput
  }

  export type vehicle_pricesUpdateInput = {
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutPricesNestedInput
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_priceNestedInput
  }

  export type vehicle_pricesUncheckedUpdateInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_priceNestedInput
  }

  export type vehicle_pricesCreateManyInput = {
    id?: string
    vehicle_id: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_pricesUpdateManyMutationInput = {
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_pricesUncheckedUpdateManyInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerCreateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutCustomersInput
    state: statesCreateNestedOneWithoutCustomersInput
    vehicle_bookings?: vehicle_bookingsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutCustomersNestedInput
    state?: statesUpdateOneRequiredWithoutCustomersNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerCreateManyInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersCreateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutProvidersInput
    state: statesCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    cityId: string
    stateId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type providersUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutProvidersNestedInput
    state?: statesUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersCreateManyInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    cityId: string
    stateId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type providersUpdateManyMutationInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersUncheckedUpdateManyInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookingsCreateInput = {
    id?: string
    booking_number: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutBookingsInput
    customer: customerCreateNestedOneWithoutVehicle_bookingsInput
    vehicle_inspection?: vehicle_inspectionCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUncheckedCreateInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUpdateInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutBookingsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookingsNestedInput
    vehicle_inspection?: vehicle_inspectionUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsCreateManyInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookingsUpdateManyMutationInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookingsUncheckedUpdateManyInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsCreateInput = {
    id?: string
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleCreateNestedOneWithoutBooking_logsInput
    vehicle_booking?: vehicle_bookingsCreateNestedOneWithoutBooking_logsInput
    customer?: customerCreateNestedOneWithoutVehicle_bookings_logsInput
  }

  export type vehicle_bookings_logsUncheckedCreateInput = {
    id?: string
    vehicle_id?: string | null
    vehicle_booking_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    customer_id?: string | null
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsUpdateInput = {
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneWithoutBooking_logsNestedInput
    vehicle_booking?: vehicle_bookingsUpdateOneWithoutBooking_logsNestedInput
    customer?: customerUpdateOneWithoutVehicle_bookings_logsNestedInput
  }

  export type vehicle_bookings_logsUncheckedUpdateInput = {
    vehicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsCreateManyInput = {
    id?: string
    vehicle_id?: string | null
    vehicle_booking_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    customer_id?: string | null
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsUpdateManyMutationInput = {
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUncheckedUpdateManyInput = {
    vehicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_billsCreateInput = {
    id?: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_booking: vehicle_bookingsCreateNestedOneWithoutBillsInput
    vehicle_price: vehicle_pricesCreateNestedOneWithoutBillsInput
    customer: customerCreateNestedOneWithoutVehicle_bookings_billsInput
    bills_payment?: bills_paymentCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsUncheckedCreateInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills_payment?: bills_paymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsUpdateInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_booking?: vehicle_bookingsUpdateOneRequiredWithoutBillsNestedInput
    vehicle_price?: vehicle_pricesUpdateOneRequiredWithoutBillsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookings_billsNestedInput
    bills_payment?: bills_paymentUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills_payment?: bills_paymentUncheckedUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsCreateManyInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_billsUpdateManyMutationInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_billsUncheckedUpdateManyInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bills_paymentCreateInput = {
    id?: string
    amount: number
    payment_method: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bill: vehicle_bookings_billsCreateNestedOneWithoutBills_paymentInput
  }

  export type bills_paymentUncheckedCreateInput = {
    id?: string
    bill_id: string
    amount: number
    payment_method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bills_paymentUpdateInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bill?: vehicle_bookings_billsUpdateOneRequiredWithoutBills_paymentNestedInput
  }

  export type bills_paymentUncheckedUpdateInput = {
    bill_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bills_paymentCreateManyInput = {
    id?: string
    bill_id: string
    amount: number
    payment_method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bills_paymentUpdateManyMutationInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bills_paymentUncheckedUpdateManyInput = {
    bill_id?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type EnumroleFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    not?: NestedEnumroleFilter<$PrismaModel> | $Enums.role
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type usersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type usersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    username?: SortOrder
    role_id?: SortOrder
    is_active?: SortOrder
    password?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type EnumroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    not?: NestedEnumroleWithAggregatesFilter<$PrismaModel> | $Enums.role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleFilter<$PrismaModel>
    _max?: NestedEnumroleFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type ModelsListRelationFilter = {
    every?: modelsWhereInput
    some?: modelsWhereInput
    none?: modelsWhereInput
  }

  export type VariantsListRelationFilter = {
    every?: variantsWhereInput
    some?: variantsWhereInput
    none?: variantsWhereInput
  }

  export type VehicleListRelationFilter = {
    every?: vehicleWhereInput
    some?: vehicleWhereInput
    none?: vehicleWhereInput
  }

  export type modelsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type variantsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicleOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type brandsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type brandsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type BrandsScalarRelationFilter = {
    is?: brandsWhereInput
    isNot?: brandsWhereInput
  }

  export type modelsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type modelsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type modelsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type ModelsScalarRelationFilter = {
    is?: modelsWhereInput
    isNot?: modelsWhereInput
  }

  export type BrandsNullableScalarRelationFilter = {
    is?: brandsWhereInput | null
    isNot?: brandsWhereInput | null
  }

  export type variantsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type variantsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type variantsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    model_id?: SortOrder
    brand_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type CitiesListRelationFilter = {
    every?: citiesWhereInput
    some?: citiesWhereInput
    none?: citiesWhereInput
  }

  export type CustomerListRelationFilter = {
    every?: customerWhereInput
    some?: customerWhereInput
    none?: customerWhereInput
  }

  export type ProvidersListRelationFilter = {
    every?: providersWhereInput
    some?: providersWhereInput
    none?: providersWhereInput
  }

  export type citiesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type customerOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type providersOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type statesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type statesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StatesScalarRelationFilter = {
    is?: statesWhereInput
    isNot?: statesWhereInput
  }

  export type citiesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type citiesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type citiesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    stateId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Checklist_optionsListRelationFilter = {
    every?: checklist_optionsWhereInput
    some?: checklist_optionsWhereInput
    none?: checklist_optionsWhereInput
  }

  export type checklist_optionsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type checklist_categoriesCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type checklist_categoriesMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type checklist_categoriesMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Checklist_categoriesScalarRelationFilter = {
    is?: checklist_categoriesWhereInput
    isNot?: checklist_categoriesWhereInput
  }

  export type Vehicle_inspection_detailsListRelationFilter = {
    every?: vehicle_inspection_detailsWhereInput
    some?: vehicle_inspection_detailsWhereInput
    none?: vehicle_inspection_detailsWhereInput
  }

  export type vehicle_inspection_detailsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type checklist_optionsCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type checklist_optionsMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type checklist_optionsMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    category_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type VariantsScalarRelationFilter = {
    is?: variantsWhereInput
    isNot?: variantsWhereInput
  }

  export type Vehicle_featuresListRelationFilter = {
    every?: vehicle_featuresWhereInput
    some?: vehicle_featuresWhereInput
    none?: vehicle_featuresWhereInput
  }

  export type Vehicle_imagesListRelationFilter = {
    every?: vehicle_imagesWhereInput
    some?: vehicle_imagesWhereInput
    none?: vehicle_imagesWhereInput
  }

  export type Vehicle_availabilityListRelationFilter = {
    every?: vehicle_availabilityWhereInput
    some?: vehicle_availabilityWhereInput
    none?: vehicle_availabilityWhereInput
  }

  export type Vehicle_availability_historyListRelationFilter = {
    every?: vehicle_availability_historyWhereInput
    some?: vehicle_availability_historyWhereInput
    none?: vehicle_availability_historyWhereInput
  }

  export type Vehicle_inspectionListRelationFilter = {
    every?: vehicle_inspectionWhereInput
    some?: vehicle_inspectionWhereInput
    none?: vehicle_inspectionWhereInput
  }

  export type Vehicle_pricesListRelationFilter = {
    every?: vehicle_pricesWhereInput
    some?: vehicle_pricesWhereInput
    none?: vehicle_pricesWhereInput
  }

  export type Vehicle_bookingsListRelationFilter = {
    every?: vehicle_bookingsWhereInput
    some?: vehicle_bookingsWhereInput
    none?: vehicle_bookingsWhereInput
  }

  export type Vehicle_bookings_logsListRelationFilter = {
    every?: vehicle_bookings_logsWhereInput
    some?: vehicle_bookings_logsWhereInput
    none?: vehicle_bookings_logsWhereInput
  }

  export type vehicle_featuresOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_imagesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_availabilityOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_availability_historyOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_inspectionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_pricesOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_bookingsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_bookings_logsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicleCountOrderByAggregateInput = {
    id?: SortOrder
    registration_number?: SortOrder
    owner_name?: SortOrder
    insurance_company?: SortOrder
    insurance_number?: SortOrder
    chassis_number?: SortOrder
    rc_image?: SortOrder
    insurance_image?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    kms_driven?: SortOrder
    color?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicleAvgOrderByAggregateInput = {
    kms_driven?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
  }

  export type vehicleMaxOrderByAggregateInput = {
    id?: SortOrder
    registration_number?: SortOrder
    owner_name?: SortOrder
    insurance_company?: SortOrder
    insurance_number?: SortOrder
    chassis_number?: SortOrder
    rc_image?: SortOrder
    insurance_image?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    kms_driven?: SortOrder
    color?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicleMinOrderByAggregateInput = {
    id?: SortOrder
    registration_number?: SortOrder
    owner_name?: SortOrder
    insurance_company?: SortOrder
    insurance_number?: SortOrder
    chassis_number?: SortOrder
    rc_image?: SortOrder
    insurance_image?: SortOrder
    brand_id?: SortOrder
    model_id?: SortOrder
    variant_id?: SortOrder
    kms_driven?: SortOrder
    color?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicleSumOrderByAggregateInput = {
    kms_driven?: SortOrder
    mileage?: SortOrder
    engine_capacity?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type VehicleScalarRelationFilter = {
    is?: vehicleWhereInput
    isNot?: vehicleWhereInput
  }

  export type vehicle_featuresCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    feature_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_featuresMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    feature_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_featuresMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    feature_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_imagesCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    image_url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_imagesMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    image_url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_imagesMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    image_url?: SortOrder
    description?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_availabilityCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_availabilityMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_availabilityMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_availability_historyCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_availability_historyMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_availability_historyMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Vehicle_bookingsNullableScalarRelationFilter = {
    is?: vehicle_bookingsWhereInput | null
    isNot?: vehicle_bookingsWhereInput | null
  }

  export type vehicle_inspectionCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    inspection_date?: SortOrder
    inspector_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle_bookingsId?: SortOrder
  }

  export type vehicle_inspectionMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    inspection_date?: SortOrder
    inspector_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle_bookingsId?: SortOrder
  }

  export type vehicle_inspectionMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    inspection_date?: SortOrder
    inspector_name?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    vehicle_bookingsId?: SortOrder
  }

  export type Checklist_optionsScalarRelationFilter = {
    is?: checklist_optionsWhereInput
    isNot?: checklist_optionsWhereInput
  }

  export type Vehicle_inspectionScalarRelationFilter = {
    is?: vehicle_inspectionWhereInput
    isNot?: vehicle_inspectionWhereInput
  }

  export type vehicle_inspection_detailsCountOrderByAggregateInput = {
    id?: SortOrder
    checklist_option_id?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    vehicle_inspection_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_inspection_detailsAvgOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type vehicle_inspection_detailsMaxOrderByAggregateInput = {
    id?: SortOrder
    checklist_option_id?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    vehicle_inspection_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_inspection_detailsMinOrderByAggregateInput = {
    id?: SortOrder
    checklist_option_id?: SortOrder
    rating?: SortOrder
    description?: SortOrder
    vehicle_inspection_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_inspection_detailsSumOrderByAggregateInput = {
    rating?: SortOrder
  }

  export type Vehicle_bookings_billsListRelationFilter = {
    every?: vehicle_bookings_billsWhereInput
    some?: vehicle_bookings_billsWhereInput
    none?: vehicle_bookings_billsWhereInput
  }

  export type vehicle_bookings_billsOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_pricesCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    is_unlimited_allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_pricesAvgOrderByAggregateInput = {
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
  }

  export type vehicle_pricesMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    is_unlimited_allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_pricesMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    is_unlimited_allowed?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_pricesSumOrderByAggregateInput = {
    base_price_per_day?: SortOrder
    hr_included?: SortOrder
    km_included?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
  }

  export type CitiesScalarRelationFilter = {
    is?: citiesWhereInput
    isNot?: citiesWhereInput
  }

  export type customerCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    city_id?: SortOrder
    state_id?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    driving_license_number?: SortOrder
    driving_license_front_image?: SortOrder
    driving_license_back_image?: SortOrder
    profile_image?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    city_id?: SortOrder
    state_id?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    driving_license_number?: SortOrder
    driving_license_front_image?: SortOrder
    driving_license_back_image?: SortOrder
    profile_image?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type customerMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    city_id?: SortOrder
    state_id?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    driving_license_number?: SortOrder
    driving_license_front_image?: SortOrder
    driving_license_back_image?: SortOrder
    profile_image?: SortOrder
    is_active?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type providersCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    pan_number?: SortOrder
    pan_image?: SortOrder
    profile_image?: SortOrder
    is_approved?: SortOrder
    is_active?: SortOrder
    rejection_reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type providersMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    pan_number?: SortOrder
    pan_image?: SortOrder
    profile_image?: SortOrder
    is_approved?: SortOrder
    is_active?: SortOrder
    rejection_reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type providersMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    email_id?: SortOrder
    mobile_number?: SortOrder
    alternate_mobile_number?: SortOrder
    address?: SortOrder
    cityId?: SortOrder
    stateId?: SortOrder
    pin_code?: SortOrder
    adhaar_number?: SortOrder
    adhar_front_image?: SortOrder
    adhar_back_image?: SortOrder
    pan_number?: SortOrder
    pan_image?: SortOrder
    profile_image?: SortOrder
    is_approved?: SortOrder
    is_active?: SortOrder
    rejection_reason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type CustomerScalarRelationFilter = {
    is?: customerWhereInput
    isNot?: customerWhereInput
  }

  export type vehicle_bookingsCountOrderByAggregateInput = {
    id?: SortOrder
    booking_number?: SortOrder
    vehicle_id?: SortOrder
    customer_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    booking_status_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookingsMaxOrderByAggregateInput = {
    id?: SortOrder
    booking_number?: SortOrder
    vehicle_id?: SortOrder
    customer_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    booking_status_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookingsMinOrderByAggregateInput = {
    id?: SortOrder
    booking_number?: SortOrder
    vehicle_id?: SortOrder
    customer_id?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    booking_status_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type VehicleNullableScalarRelationFilter = {
    is?: vehicleWhereInput | null
    isNot?: vehicleWhereInput | null
  }

  export type CustomerNullableScalarRelationFilter = {
    is?: customerWhereInput | null
    isNot?: customerWhereInput | null
  }

  export type vehicle_bookings_logsCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    vehicle_booking_id?: SortOrder
    booking_number?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    customer_id?: SortOrder
    booking_status_id?: SortOrder
    logged_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookings_logsMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    vehicle_booking_id?: SortOrder
    booking_number?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    customer_id?: SortOrder
    booking_status_id?: SortOrder
    logged_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookings_logsMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_id?: SortOrder
    vehicle_booking_id?: SortOrder
    booking_number?: SortOrder
    start_time?: SortOrder
    end_time?: SortOrder
    customer_id?: SortOrder
    booking_status_id?: SortOrder
    logged_time?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type Vehicle_bookingsScalarRelationFilter = {
    is?: vehicle_bookingsWhereInput
    isNot?: vehicle_bookingsWhereInput
  }

  export type Vehicle_pricesScalarRelationFilter = {
    is?: vehicle_pricesWhereInput
    isNot?: vehicle_pricesWhereInput
  }

  export type Bills_paymentListRelationFilter = {
    every?: bills_paymentWhereInput
    some?: bills_paymentWhereInput
    none?: bills_paymentWhereInput
  }

  export type bills_paymentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type vehicle_bookings_billsCountOrderByAggregateInput = {
    id?: SortOrder
    vehicle_booking_id?: SortOrder
    base_price?: SortOrder
    vehicle_price_id?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookings_billsAvgOrderByAggregateInput = {
    base_price?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
  }

  export type vehicle_bookings_billsMaxOrderByAggregateInput = {
    id?: SortOrder
    vehicle_booking_id?: SortOrder
    base_price?: SortOrder
    vehicle_price_id?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookings_billsMinOrderByAggregateInput = {
    id?: SortOrder
    vehicle_booking_id?: SortOrder
    base_price?: SortOrder
    vehicle_price_id?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
    customer_id?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type vehicle_bookings_billsSumOrderByAggregateInput = {
    base_price?: SortOrder
    total_price?: SortOrder
    extra_km_charge?: SortOrder
    extra_hr_charge?: SortOrder
  }

  export type Vehicle_bookings_billsScalarRelationFilter = {
    is?: vehicle_bookings_billsWhereInput
    isNot?: vehicle_bookings_billsWhereInput
  }

  export type bills_paymentCountOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bills_paymentAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type bills_paymentMaxOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bills_paymentMinOrderByAggregateInput = {
    id?: SortOrder
    bill_id?: SortOrder
    amount?: SortOrder
    payment_method?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type bills_paymentSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type EnumroleFieldUpdateOperationsInput = {
    set?: $Enums.role
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type modelsCreateNestedManyWithoutBrandInput = {
    create?: XOR<modelsCreateWithoutBrandInput, modelsUncheckedCreateWithoutBrandInput> | modelsCreateWithoutBrandInput[] | modelsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandInput | modelsCreateOrConnectWithoutBrandInput[]
    createMany?: modelsCreateManyBrandInputEnvelope
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
  }

  export type variantsCreateNestedManyWithoutBrandInput = {
    create?: XOR<variantsCreateWithoutBrandInput, variantsUncheckedCreateWithoutBrandInput> | variantsCreateWithoutBrandInput[] | variantsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutBrandInput | variantsCreateOrConnectWithoutBrandInput[]
    createMany?: variantsCreateManyBrandInputEnvelope
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
  }

  export type vehicleCreateNestedManyWithoutBrandInput = {
    create?: XOR<vehicleCreateWithoutBrandInput, vehicleUncheckedCreateWithoutBrandInput> | vehicleCreateWithoutBrandInput[] | vehicleUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutBrandInput | vehicleCreateOrConnectWithoutBrandInput[]
    createMany?: vehicleCreateManyBrandInputEnvelope
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
  }

  export type modelsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<modelsCreateWithoutBrandInput, modelsUncheckedCreateWithoutBrandInput> | modelsCreateWithoutBrandInput[] | modelsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandInput | modelsCreateOrConnectWithoutBrandInput[]
    createMany?: modelsCreateManyBrandInputEnvelope
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
  }

  export type variantsUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<variantsCreateWithoutBrandInput, variantsUncheckedCreateWithoutBrandInput> | variantsCreateWithoutBrandInput[] | variantsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutBrandInput | variantsCreateOrConnectWithoutBrandInput[]
    createMany?: variantsCreateManyBrandInputEnvelope
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
  }

  export type vehicleUncheckedCreateNestedManyWithoutBrandInput = {
    create?: XOR<vehicleCreateWithoutBrandInput, vehicleUncheckedCreateWithoutBrandInput> | vehicleCreateWithoutBrandInput[] | vehicleUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutBrandInput | vehicleCreateOrConnectWithoutBrandInput[]
    createMany?: vehicleCreateManyBrandInputEnvelope
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
  }

  export type modelsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<modelsCreateWithoutBrandInput, modelsUncheckedCreateWithoutBrandInput> | modelsCreateWithoutBrandInput[] | modelsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandInput | modelsCreateOrConnectWithoutBrandInput[]
    upsert?: modelsUpsertWithWhereUniqueWithoutBrandInput | modelsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: modelsCreateManyBrandInputEnvelope
    set?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    disconnect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    delete?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    update?: modelsUpdateWithWhereUniqueWithoutBrandInput | modelsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: modelsUpdateManyWithWhereWithoutBrandInput | modelsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: modelsScalarWhereInput | modelsScalarWhereInput[]
  }

  export type variantsUpdateManyWithoutBrandNestedInput = {
    create?: XOR<variantsCreateWithoutBrandInput, variantsUncheckedCreateWithoutBrandInput> | variantsCreateWithoutBrandInput[] | variantsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutBrandInput | variantsCreateOrConnectWithoutBrandInput[]
    upsert?: variantsUpsertWithWhereUniqueWithoutBrandInput | variantsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: variantsCreateManyBrandInputEnvelope
    set?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    disconnect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    delete?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    update?: variantsUpdateWithWhereUniqueWithoutBrandInput | variantsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: variantsUpdateManyWithWhereWithoutBrandInput | variantsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: variantsScalarWhereInput | variantsScalarWhereInput[]
  }

  export type vehicleUpdateManyWithoutBrandNestedInput = {
    create?: XOR<vehicleCreateWithoutBrandInput, vehicleUncheckedCreateWithoutBrandInput> | vehicleCreateWithoutBrandInput[] | vehicleUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutBrandInput | vehicleCreateOrConnectWithoutBrandInput[]
    upsert?: vehicleUpsertWithWhereUniqueWithoutBrandInput | vehicleUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: vehicleCreateManyBrandInputEnvelope
    set?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    disconnect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    delete?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    update?: vehicleUpdateWithWhereUniqueWithoutBrandInput | vehicleUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: vehicleUpdateManyWithWhereWithoutBrandInput | vehicleUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
  }

  export type modelsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<modelsCreateWithoutBrandInput, modelsUncheckedCreateWithoutBrandInput> | modelsCreateWithoutBrandInput[] | modelsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: modelsCreateOrConnectWithoutBrandInput | modelsCreateOrConnectWithoutBrandInput[]
    upsert?: modelsUpsertWithWhereUniqueWithoutBrandInput | modelsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: modelsCreateManyBrandInputEnvelope
    set?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    disconnect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    delete?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    connect?: modelsWhereUniqueInput | modelsWhereUniqueInput[]
    update?: modelsUpdateWithWhereUniqueWithoutBrandInput | modelsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: modelsUpdateManyWithWhereWithoutBrandInput | modelsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: modelsScalarWhereInput | modelsScalarWhereInput[]
  }

  export type variantsUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<variantsCreateWithoutBrandInput, variantsUncheckedCreateWithoutBrandInput> | variantsCreateWithoutBrandInput[] | variantsUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutBrandInput | variantsCreateOrConnectWithoutBrandInput[]
    upsert?: variantsUpsertWithWhereUniqueWithoutBrandInput | variantsUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: variantsCreateManyBrandInputEnvelope
    set?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    disconnect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    delete?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    update?: variantsUpdateWithWhereUniqueWithoutBrandInput | variantsUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: variantsUpdateManyWithWhereWithoutBrandInput | variantsUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: variantsScalarWhereInput | variantsScalarWhereInput[]
  }

  export type vehicleUncheckedUpdateManyWithoutBrandNestedInput = {
    create?: XOR<vehicleCreateWithoutBrandInput, vehicleUncheckedCreateWithoutBrandInput> | vehicleCreateWithoutBrandInput[] | vehicleUncheckedCreateWithoutBrandInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutBrandInput | vehicleCreateOrConnectWithoutBrandInput[]
    upsert?: vehicleUpsertWithWhereUniqueWithoutBrandInput | vehicleUpsertWithWhereUniqueWithoutBrandInput[]
    createMany?: vehicleCreateManyBrandInputEnvelope
    set?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    disconnect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    delete?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    update?: vehicleUpdateWithWhereUniqueWithoutBrandInput | vehicleUpdateWithWhereUniqueWithoutBrandInput[]
    updateMany?: vehicleUpdateManyWithWhereWithoutBrandInput | vehicleUpdateManyWithWhereWithoutBrandInput[]
    deleteMany?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
  }

  export type brandsCreateNestedOneWithoutModelsInput = {
    create?: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutModelsInput
    connect?: brandsWhereUniqueInput
  }

  export type variantsCreateNestedManyWithoutModelInput = {
    create?: XOR<variantsCreateWithoutModelInput, variantsUncheckedCreateWithoutModelInput> | variantsCreateWithoutModelInput[] | variantsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelInput | variantsCreateOrConnectWithoutModelInput[]
    createMany?: variantsCreateManyModelInputEnvelope
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
  }

  export type vehicleCreateNestedManyWithoutModelInput = {
    create?: XOR<vehicleCreateWithoutModelInput, vehicleUncheckedCreateWithoutModelInput> | vehicleCreateWithoutModelInput[] | vehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutModelInput | vehicleCreateOrConnectWithoutModelInput[]
    createMany?: vehicleCreateManyModelInputEnvelope
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
  }

  export type variantsUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<variantsCreateWithoutModelInput, variantsUncheckedCreateWithoutModelInput> | variantsCreateWithoutModelInput[] | variantsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelInput | variantsCreateOrConnectWithoutModelInput[]
    createMany?: variantsCreateManyModelInputEnvelope
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
  }

  export type vehicleUncheckedCreateNestedManyWithoutModelInput = {
    create?: XOR<vehicleCreateWithoutModelInput, vehicleUncheckedCreateWithoutModelInput> | vehicleCreateWithoutModelInput[] | vehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutModelInput | vehicleCreateOrConnectWithoutModelInput[]
    createMany?: vehicleCreateManyModelInputEnvelope
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
  }

  export type brandsUpdateOneRequiredWithoutModelsNestedInput = {
    create?: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutModelsInput
    upsert?: brandsUpsertWithoutModelsInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutModelsInput, brandsUpdateWithoutModelsInput>, brandsUncheckedUpdateWithoutModelsInput>
  }

  export type variantsUpdateManyWithoutModelNestedInput = {
    create?: XOR<variantsCreateWithoutModelInput, variantsUncheckedCreateWithoutModelInput> | variantsCreateWithoutModelInput[] | variantsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelInput | variantsCreateOrConnectWithoutModelInput[]
    upsert?: variantsUpsertWithWhereUniqueWithoutModelInput | variantsUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: variantsCreateManyModelInputEnvelope
    set?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    disconnect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    delete?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    update?: variantsUpdateWithWhereUniqueWithoutModelInput | variantsUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: variantsUpdateManyWithWhereWithoutModelInput | variantsUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: variantsScalarWhereInput | variantsScalarWhereInput[]
  }

  export type vehicleUpdateManyWithoutModelNestedInput = {
    create?: XOR<vehicleCreateWithoutModelInput, vehicleUncheckedCreateWithoutModelInput> | vehicleCreateWithoutModelInput[] | vehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutModelInput | vehicleCreateOrConnectWithoutModelInput[]
    upsert?: vehicleUpsertWithWhereUniqueWithoutModelInput | vehicleUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: vehicleCreateManyModelInputEnvelope
    set?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    disconnect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    delete?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    update?: vehicleUpdateWithWhereUniqueWithoutModelInput | vehicleUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: vehicleUpdateManyWithWhereWithoutModelInput | vehicleUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
  }

  export type variantsUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<variantsCreateWithoutModelInput, variantsUncheckedCreateWithoutModelInput> | variantsCreateWithoutModelInput[] | variantsUncheckedCreateWithoutModelInput[]
    connectOrCreate?: variantsCreateOrConnectWithoutModelInput | variantsCreateOrConnectWithoutModelInput[]
    upsert?: variantsUpsertWithWhereUniqueWithoutModelInput | variantsUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: variantsCreateManyModelInputEnvelope
    set?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    disconnect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    delete?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    connect?: variantsWhereUniqueInput | variantsWhereUniqueInput[]
    update?: variantsUpdateWithWhereUniqueWithoutModelInput | variantsUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: variantsUpdateManyWithWhereWithoutModelInput | variantsUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: variantsScalarWhereInput | variantsScalarWhereInput[]
  }

  export type vehicleUncheckedUpdateManyWithoutModelNestedInput = {
    create?: XOR<vehicleCreateWithoutModelInput, vehicleUncheckedCreateWithoutModelInput> | vehicleCreateWithoutModelInput[] | vehicleUncheckedCreateWithoutModelInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutModelInput | vehicleCreateOrConnectWithoutModelInput[]
    upsert?: vehicleUpsertWithWhereUniqueWithoutModelInput | vehicleUpsertWithWhereUniqueWithoutModelInput[]
    createMany?: vehicleCreateManyModelInputEnvelope
    set?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    disconnect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    delete?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    update?: vehicleUpdateWithWhereUniqueWithoutModelInput | vehicleUpdateWithWhereUniqueWithoutModelInput[]
    updateMany?: vehicleUpdateManyWithWhereWithoutModelInput | vehicleUpdateManyWithWhereWithoutModelInput[]
    deleteMany?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
  }

  export type modelsCreateNestedOneWithoutVariantsInput = {
    create?: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: modelsCreateOrConnectWithoutVariantsInput
    connect?: modelsWhereUniqueInput
  }

  export type brandsCreateNestedOneWithoutVariantsInput = {
    create?: XOR<brandsCreateWithoutVariantsInput, brandsUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutVariantsInput
    connect?: brandsWhereUniqueInput
  }

  export type vehicleCreateNestedManyWithoutVariantInput = {
    create?: XOR<vehicleCreateWithoutVariantInput, vehicleUncheckedCreateWithoutVariantInput> | vehicleCreateWithoutVariantInput[] | vehicleUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutVariantInput | vehicleCreateOrConnectWithoutVariantInput[]
    createMany?: vehicleCreateManyVariantInputEnvelope
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
  }

  export type vehicleUncheckedCreateNestedManyWithoutVariantInput = {
    create?: XOR<vehicleCreateWithoutVariantInput, vehicleUncheckedCreateWithoutVariantInput> | vehicleCreateWithoutVariantInput[] | vehicleUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutVariantInput | vehicleCreateOrConnectWithoutVariantInput[]
    createMany?: vehicleCreateManyVariantInputEnvelope
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
  }

  export type modelsUpdateOneRequiredWithoutVariantsNestedInput = {
    create?: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: modelsCreateOrConnectWithoutVariantsInput
    upsert?: modelsUpsertWithoutVariantsInput
    connect?: modelsWhereUniqueInput
    update?: XOR<XOR<modelsUpdateToOneWithWhereWithoutVariantsInput, modelsUpdateWithoutVariantsInput>, modelsUncheckedUpdateWithoutVariantsInput>
  }

  export type brandsUpdateOneWithoutVariantsNestedInput = {
    create?: XOR<brandsCreateWithoutVariantsInput, brandsUncheckedCreateWithoutVariantsInput>
    connectOrCreate?: brandsCreateOrConnectWithoutVariantsInput
    upsert?: brandsUpsertWithoutVariantsInput
    disconnect?: boolean
    delete?: brandsWhereInput | boolean
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutVariantsInput, brandsUpdateWithoutVariantsInput>, brandsUncheckedUpdateWithoutVariantsInput>
  }

  export type vehicleUpdateManyWithoutVariantNestedInput = {
    create?: XOR<vehicleCreateWithoutVariantInput, vehicleUncheckedCreateWithoutVariantInput> | vehicleCreateWithoutVariantInput[] | vehicleUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutVariantInput | vehicleCreateOrConnectWithoutVariantInput[]
    upsert?: vehicleUpsertWithWhereUniqueWithoutVariantInput | vehicleUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: vehicleCreateManyVariantInputEnvelope
    set?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    disconnect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    delete?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    update?: vehicleUpdateWithWhereUniqueWithoutVariantInput | vehicleUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: vehicleUpdateManyWithWhereWithoutVariantInput | vehicleUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
    unset?: boolean
  }

  export type vehicleUncheckedUpdateManyWithoutVariantNestedInput = {
    create?: XOR<vehicleCreateWithoutVariantInput, vehicleUncheckedCreateWithoutVariantInput> | vehicleCreateWithoutVariantInput[] | vehicleUncheckedCreateWithoutVariantInput[]
    connectOrCreate?: vehicleCreateOrConnectWithoutVariantInput | vehicleCreateOrConnectWithoutVariantInput[]
    upsert?: vehicleUpsertWithWhereUniqueWithoutVariantInput | vehicleUpsertWithWhereUniqueWithoutVariantInput[]
    createMany?: vehicleCreateManyVariantInputEnvelope
    set?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    disconnect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    delete?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    connect?: vehicleWhereUniqueInput | vehicleWhereUniqueInput[]
    update?: vehicleUpdateWithWhereUniqueWithoutVariantInput | vehicleUpdateWithWhereUniqueWithoutVariantInput[]
    updateMany?: vehicleUpdateManyWithWhereWithoutVariantInput | vehicleUpdateManyWithWhereWithoutVariantInput[]
    deleteMany?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
  }

  export type citiesCreateNestedManyWithoutStateInput = {
    create?: XOR<citiesCreateWithoutStateInput, citiesUncheckedCreateWithoutStateInput> | citiesCreateWithoutStateInput[] | citiesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: citiesCreateOrConnectWithoutStateInput | citiesCreateOrConnectWithoutStateInput[]
    createMany?: citiesCreateManyStateInputEnvelope
    connect?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
  }

  export type customerCreateNestedManyWithoutStateInput = {
    create?: XOR<customerCreateWithoutStateInput, customerUncheckedCreateWithoutStateInput> | customerCreateWithoutStateInput[] | customerUncheckedCreateWithoutStateInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStateInput | customerCreateOrConnectWithoutStateInput[]
    createMany?: customerCreateManyStateInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type providersCreateNestedManyWithoutStateInput = {
    create?: XOR<providersCreateWithoutStateInput, providersUncheckedCreateWithoutStateInput> | providersCreateWithoutStateInput[] | providersUncheckedCreateWithoutStateInput[]
    connectOrCreate?: providersCreateOrConnectWithoutStateInput | providersCreateOrConnectWithoutStateInput[]
    createMany?: providersCreateManyStateInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type citiesUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<citiesCreateWithoutStateInput, citiesUncheckedCreateWithoutStateInput> | citiesCreateWithoutStateInput[] | citiesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: citiesCreateOrConnectWithoutStateInput | citiesCreateOrConnectWithoutStateInput[]
    createMany?: citiesCreateManyStateInputEnvelope
    connect?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<customerCreateWithoutStateInput, customerUncheckedCreateWithoutStateInput> | customerCreateWithoutStateInput[] | customerUncheckedCreateWithoutStateInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStateInput | customerCreateOrConnectWithoutStateInput[]
    createMany?: customerCreateManyStateInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type providersUncheckedCreateNestedManyWithoutStateInput = {
    create?: XOR<providersCreateWithoutStateInput, providersUncheckedCreateWithoutStateInput> | providersCreateWithoutStateInput[] | providersUncheckedCreateWithoutStateInput[]
    connectOrCreate?: providersCreateOrConnectWithoutStateInput | providersCreateOrConnectWithoutStateInput[]
    createMany?: providersCreateManyStateInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type citiesUpdateManyWithoutStateNestedInput = {
    create?: XOR<citiesCreateWithoutStateInput, citiesUncheckedCreateWithoutStateInput> | citiesCreateWithoutStateInput[] | citiesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: citiesCreateOrConnectWithoutStateInput | citiesCreateOrConnectWithoutStateInput[]
    upsert?: citiesUpsertWithWhereUniqueWithoutStateInput | citiesUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: citiesCreateManyStateInputEnvelope
    set?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    disconnect?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    delete?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    connect?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    update?: citiesUpdateWithWhereUniqueWithoutStateInput | citiesUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: citiesUpdateManyWithWhereWithoutStateInput | citiesUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: citiesScalarWhereInput | citiesScalarWhereInput[]
  }

  export type customerUpdateManyWithoutStateNestedInput = {
    create?: XOR<customerCreateWithoutStateInput, customerUncheckedCreateWithoutStateInput> | customerCreateWithoutStateInput[] | customerUncheckedCreateWithoutStateInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStateInput | customerCreateOrConnectWithoutStateInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutStateInput | customerUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: customerCreateManyStateInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutStateInput | customerUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: customerUpdateManyWithWhereWithoutStateInput | customerUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type providersUpdateManyWithoutStateNestedInput = {
    create?: XOR<providersCreateWithoutStateInput, providersUncheckedCreateWithoutStateInput> | providersCreateWithoutStateInput[] | providersUncheckedCreateWithoutStateInput[]
    connectOrCreate?: providersCreateOrConnectWithoutStateInput | providersCreateOrConnectWithoutStateInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutStateInput | providersUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: providersCreateManyStateInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutStateInput | providersUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: providersUpdateManyWithWhereWithoutStateInput | providersUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type citiesUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<citiesCreateWithoutStateInput, citiesUncheckedCreateWithoutStateInput> | citiesCreateWithoutStateInput[] | citiesUncheckedCreateWithoutStateInput[]
    connectOrCreate?: citiesCreateOrConnectWithoutStateInput | citiesCreateOrConnectWithoutStateInput[]
    upsert?: citiesUpsertWithWhereUniqueWithoutStateInput | citiesUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: citiesCreateManyStateInputEnvelope
    set?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    disconnect?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    delete?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    connect?: citiesWhereUniqueInput | citiesWhereUniqueInput[]
    update?: citiesUpdateWithWhereUniqueWithoutStateInput | citiesUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: citiesUpdateManyWithWhereWithoutStateInput | citiesUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: citiesScalarWhereInput | citiesScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<customerCreateWithoutStateInput, customerUncheckedCreateWithoutStateInput> | customerCreateWithoutStateInput[] | customerUncheckedCreateWithoutStateInput[]
    connectOrCreate?: customerCreateOrConnectWithoutStateInput | customerCreateOrConnectWithoutStateInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutStateInput | customerUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: customerCreateManyStateInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutStateInput | customerUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: customerUpdateManyWithWhereWithoutStateInput | customerUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type providersUncheckedUpdateManyWithoutStateNestedInput = {
    create?: XOR<providersCreateWithoutStateInput, providersUncheckedCreateWithoutStateInput> | providersCreateWithoutStateInput[] | providersUncheckedCreateWithoutStateInput[]
    connectOrCreate?: providersCreateOrConnectWithoutStateInput | providersCreateOrConnectWithoutStateInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutStateInput | providersUpsertWithWhereUniqueWithoutStateInput[]
    createMany?: providersCreateManyStateInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutStateInput | providersUpdateWithWhereUniqueWithoutStateInput[]
    updateMany?: providersUpdateManyWithWhereWithoutStateInput | providersUpdateManyWithWhereWithoutStateInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type statesCreateNestedOneWithoutCitiesInput = {
    create?: XOR<statesCreateWithoutCitiesInput, statesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: statesCreateOrConnectWithoutCitiesInput
    connect?: statesWhereUniqueInput
  }

  export type customerCreateNestedManyWithoutCityInput = {
    create?: XOR<customerCreateWithoutCityInput, customerUncheckedCreateWithoutCityInput> | customerCreateWithoutCityInput[] | customerUncheckedCreateWithoutCityInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCityInput | customerCreateOrConnectWithoutCityInput[]
    createMany?: customerCreateManyCityInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type providersCreateNestedManyWithoutCityInput = {
    create?: XOR<providersCreateWithoutCityInput, providersUncheckedCreateWithoutCityInput> | providersCreateWithoutCityInput[] | providersUncheckedCreateWithoutCityInput[]
    connectOrCreate?: providersCreateOrConnectWithoutCityInput | providersCreateOrConnectWithoutCityInput[]
    createMany?: providersCreateManyCityInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type customerUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<customerCreateWithoutCityInput, customerUncheckedCreateWithoutCityInput> | customerCreateWithoutCityInput[] | customerUncheckedCreateWithoutCityInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCityInput | customerCreateOrConnectWithoutCityInput[]
    createMany?: customerCreateManyCityInputEnvelope
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
  }

  export type providersUncheckedCreateNestedManyWithoutCityInput = {
    create?: XOR<providersCreateWithoutCityInput, providersUncheckedCreateWithoutCityInput> | providersCreateWithoutCityInput[] | providersUncheckedCreateWithoutCityInput[]
    connectOrCreate?: providersCreateOrConnectWithoutCityInput | providersCreateOrConnectWithoutCityInput[]
    createMany?: providersCreateManyCityInputEnvelope
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
  }

  export type statesUpdateOneRequiredWithoutCitiesNestedInput = {
    create?: XOR<statesCreateWithoutCitiesInput, statesUncheckedCreateWithoutCitiesInput>
    connectOrCreate?: statesCreateOrConnectWithoutCitiesInput
    upsert?: statesUpsertWithoutCitiesInput
    connect?: statesWhereUniqueInput
    update?: XOR<XOR<statesUpdateToOneWithWhereWithoutCitiesInput, statesUpdateWithoutCitiesInput>, statesUncheckedUpdateWithoutCitiesInput>
  }

  export type customerUpdateManyWithoutCityNestedInput = {
    create?: XOR<customerCreateWithoutCityInput, customerUncheckedCreateWithoutCityInput> | customerCreateWithoutCityInput[] | customerUncheckedCreateWithoutCityInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCityInput | customerCreateOrConnectWithoutCityInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutCityInput | customerUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: customerCreateManyCityInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutCityInput | customerUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: customerUpdateManyWithWhereWithoutCityInput | customerUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type providersUpdateManyWithoutCityNestedInput = {
    create?: XOR<providersCreateWithoutCityInput, providersUncheckedCreateWithoutCityInput> | providersCreateWithoutCityInput[] | providersUncheckedCreateWithoutCityInput[]
    connectOrCreate?: providersCreateOrConnectWithoutCityInput | providersCreateOrConnectWithoutCityInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutCityInput | providersUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: providersCreateManyCityInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutCityInput | providersUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: providersUpdateManyWithWhereWithoutCityInput | providersUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type customerUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<customerCreateWithoutCityInput, customerUncheckedCreateWithoutCityInput> | customerCreateWithoutCityInput[] | customerUncheckedCreateWithoutCityInput[]
    connectOrCreate?: customerCreateOrConnectWithoutCityInput | customerCreateOrConnectWithoutCityInput[]
    upsert?: customerUpsertWithWhereUniqueWithoutCityInput | customerUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: customerCreateManyCityInputEnvelope
    set?: customerWhereUniqueInput | customerWhereUniqueInput[]
    disconnect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    delete?: customerWhereUniqueInput | customerWhereUniqueInput[]
    connect?: customerWhereUniqueInput | customerWhereUniqueInput[]
    update?: customerUpdateWithWhereUniqueWithoutCityInput | customerUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: customerUpdateManyWithWhereWithoutCityInput | customerUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: customerScalarWhereInput | customerScalarWhereInput[]
  }

  export type providersUncheckedUpdateManyWithoutCityNestedInput = {
    create?: XOR<providersCreateWithoutCityInput, providersUncheckedCreateWithoutCityInput> | providersCreateWithoutCityInput[] | providersUncheckedCreateWithoutCityInput[]
    connectOrCreate?: providersCreateOrConnectWithoutCityInput | providersCreateOrConnectWithoutCityInput[]
    upsert?: providersUpsertWithWhereUniqueWithoutCityInput | providersUpsertWithWhereUniqueWithoutCityInput[]
    createMany?: providersCreateManyCityInputEnvelope
    set?: providersWhereUniqueInput | providersWhereUniqueInput[]
    disconnect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    delete?: providersWhereUniqueInput | providersWhereUniqueInput[]
    connect?: providersWhereUniqueInput | providersWhereUniqueInput[]
    update?: providersUpdateWithWhereUniqueWithoutCityInput | providersUpdateWithWhereUniqueWithoutCityInput[]
    updateMany?: providersUpdateManyWithWhereWithoutCityInput | providersUpdateManyWithWhereWithoutCityInput[]
    deleteMany?: providersScalarWhereInput | providersScalarWhereInput[]
  }

  export type checklist_optionsCreateNestedManyWithoutCategoryInput = {
    create?: XOR<checklist_optionsCreateWithoutCategoryInput, checklist_optionsUncheckedCreateWithoutCategoryInput> | checklist_optionsCreateWithoutCategoryInput[] | checklist_optionsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: checklist_optionsCreateOrConnectWithoutCategoryInput | checklist_optionsCreateOrConnectWithoutCategoryInput[]
    createMany?: checklist_optionsCreateManyCategoryInputEnvelope
    connect?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
  }

  export type checklist_optionsUncheckedCreateNestedManyWithoutCategoryInput = {
    create?: XOR<checklist_optionsCreateWithoutCategoryInput, checklist_optionsUncheckedCreateWithoutCategoryInput> | checklist_optionsCreateWithoutCategoryInput[] | checklist_optionsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: checklist_optionsCreateOrConnectWithoutCategoryInput | checklist_optionsCreateOrConnectWithoutCategoryInput[]
    createMany?: checklist_optionsCreateManyCategoryInputEnvelope
    connect?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
  }

  export type checklist_optionsUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<checklist_optionsCreateWithoutCategoryInput, checklist_optionsUncheckedCreateWithoutCategoryInput> | checklist_optionsCreateWithoutCategoryInput[] | checklist_optionsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: checklist_optionsCreateOrConnectWithoutCategoryInput | checklist_optionsCreateOrConnectWithoutCategoryInput[]
    upsert?: checklist_optionsUpsertWithWhereUniqueWithoutCategoryInput | checklist_optionsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: checklist_optionsCreateManyCategoryInputEnvelope
    set?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    disconnect?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    delete?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    connect?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    update?: checklist_optionsUpdateWithWhereUniqueWithoutCategoryInput | checklist_optionsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: checklist_optionsUpdateManyWithWhereWithoutCategoryInput | checklist_optionsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: checklist_optionsScalarWhereInput | checklist_optionsScalarWhereInput[]
  }

  export type checklist_optionsUncheckedUpdateManyWithoutCategoryNestedInput = {
    create?: XOR<checklist_optionsCreateWithoutCategoryInput, checklist_optionsUncheckedCreateWithoutCategoryInput> | checklist_optionsCreateWithoutCategoryInput[] | checklist_optionsUncheckedCreateWithoutCategoryInput[]
    connectOrCreate?: checklist_optionsCreateOrConnectWithoutCategoryInput | checklist_optionsCreateOrConnectWithoutCategoryInput[]
    upsert?: checklist_optionsUpsertWithWhereUniqueWithoutCategoryInput | checklist_optionsUpsertWithWhereUniqueWithoutCategoryInput[]
    createMany?: checklist_optionsCreateManyCategoryInputEnvelope
    set?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    disconnect?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    delete?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    connect?: checklist_optionsWhereUniqueInput | checklist_optionsWhereUniqueInput[]
    update?: checklist_optionsUpdateWithWhereUniqueWithoutCategoryInput | checklist_optionsUpdateWithWhereUniqueWithoutCategoryInput[]
    updateMany?: checklist_optionsUpdateManyWithWhereWithoutCategoryInput | checklist_optionsUpdateManyWithWhereWithoutCategoryInput[]
    deleteMany?: checklist_optionsScalarWhereInput | checklist_optionsScalarWhereInput[]
  }

  export type checklist_categoriesCreateNestedOneWithoutOptionsInput = {
    create?: XOR<checklist_categoriesCreateWithoutOptionsInput, checklist_categoriesUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: checklist_categoriesCreateOrConnectWithoutOptionsInput
    connect?: checklist_categoriesWhereUniqueInput
  }

  export type vehicle_inspection_detailsCreateNestedManyWithoutChecklist_optionInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput> | vehicle_inspection_detailsCreateWithoutChecklist_optionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput | vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput[]
    createMany?: vehicle_inspection_detailsCreateManyChecklist_optionInputEnvelope
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
  }

  export type vehicle_inspection_detailsUncheckedCreateNestedManyWithoutChecklist_optionInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput> | vehicle_inspection_detailsCreateWithoutChecklist_optionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput | vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput[]
    createMany?: vehicle_inspection_detailsCreateManyChecklist_optionInputEnvelope
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
  }

  export type checklist_categoriesUpdateOneRequiredWithoutOptionsNestedInput = {
    create?: XOR<checklist_categoriesCreateWithoutOptionsInput, checklist_categoriesUncheckedCreateWithoutOptionsInput>
    connectOrCreate?: checklist_categoriesCreateOrConnectWithoutOptionsInput
    upsert?: checklist_categoriesUpsertWithoutOptionsInput
    connect?: checklist_categoriesWhereUniqueInput
    update?: XOR<XOR<checklist_categoriesUpdateToOneWithWhereWithoutOptionsInput, checklist_categoriesUpdateWithoutOptionsInput>, checklist_categoriesUncheckedUpdateWithoutOptionsInput>
  }

  export type vehicle_inspection_detailsUpdateManyWithoutChecklist_optionNestedInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput> | vehicle_inspection_detailsCreateWithoutChecklist_optionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput | vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput[]
    upsert?: vehicle_inspection_detailsUpsertWithWhereUniqueWithoutChecklist_optionInput | vehicle_inspection_detailsUpsertWithWhereUniqueWithoutChecklist_optionInput[]
    createMany?: vehicle_inspection_detailsCreateManyChecklist_optionInputEnvelope
    set?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    disconnect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    delete?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    update?: vehicle_inspection_detailsUpdateWithWhereUniqueWithoutChecklist_optionInput | vehicle_inspection_detailsUpdateWithWhereUniqueWithoutChecklist_optionInput[]
    updateMany?: vehicle_inspection_detailsUpdateManyWithWhereWithoutChecklist_optionInput | vehicle_inspection_detailsUpdateManyWithWhereWithoutChecklist_optionInput[]
    deleteMany?: vehicle_inspection_detailsScalarWhereInput | vehicle_inspection_detailsScalarWhereInput[]
  }

  export type vehicle_inspection_detailsUncheckedUpdateManyWithoutChecklist_optionNestedInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput> | vehicle_inspection_detailsCreateWithoutChecklist_optionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput | vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput[]
    upsert?: vehicle_inspection_detailsUpsertWithWhereUniqueWithoutChecklist_optionInput | vehicle_inspection_detailsUpsertWithWhereUniqueWithoutChecklist_optionInput[]
    createMany?: vehicle_inspection_detailsCreateManyChecklist_optionInputEnvelope
    set?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    disconnect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    delete?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    update?: vehicle_inspection_detailsUpdateWithWhereUniqueWithoutChecklist_optionInput | vehicle_inspection_detailsUpdateWithWhereUniqueWithoutChecklist_optionInput[]
    updateMany?: vehicle_inspection_detailsUpdateManyWithWhereWithoutChecklist_optionInput | vehicle_inspection_detailsUpdateManyWithWhereWithoutChecklist_optionInput[]
    deleteMany?: vehicle_inspection_detailsScalarWhereInput | vehicle_inspection_detailsScalarWhereInput[]
  }

  export type brandsCreateNestedOneWithoutVehicleInput = {
    create?: XOR<brandsCreateWithoutVehicleInput, brandsUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: brandsCreateOrConnectWithoutVehicleInput
    connect?: brandsWhereUniqueInput
  }

  export type modelsCreateNestedOneWithoutVehicleInput = {
    create?: XOR<modelsCreateWithoutVehicleInput, modelsUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: modelsCreateOrConnectWithoutVehicleInput
    connect?: modelsWhereUniqueInput
  }

  export type variantsCreateNestedOneWithoutVehicleInput = {
    create?: XOR<variantsCreateWithoutVehicleInput, variantsUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: variantsCreateOrConnectWithoutVehicleInput
    connect?: variantsWhereUniqueInput
  }

  export type vehicle_featuresCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_featuresCreateWithoutVehicleInput, vehicle_featuresUncheckedCreateWithoutVehicleInput> | vehicle_featuresCreateWithoutVehicleInput[] | vehicle_featuresUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_featuresCreateOrConnectWithoutVehicleInput | vehicle_featuresCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_featuresCreateManyVehicleInputEnvelope
    connect?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
  }

  export type vehicle_imagesCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_imagesCreateWithoutVehicleInput, vehicle_imagesUncheckedCreateWithoutVehicleInput> | vehicle_imagesCreateWithoutVehicleInput[] | vehicle_imagesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_imagesCreateOrConnectWithoutVehicleInput | vehicle_imagesCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_imagesCreateManyVehicleInputEnvelope
    connect?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
  }

  export type vehicle_availabilityCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_availabilityCreateWithoutVehicleInput, vehicle_availabilityUncheckedCreateWithoutVehicleInput> | vehicle_availabilityCreateWithoutVehicleInput[] | vehicle_availabilityUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availabilityCreateOrConnectWithoutVehicleInput | vehicle_availabilityCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_availabilityCreateManyVehicleInputEnvelope
    connect?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
  }

  export type vehicle_availability_historyCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_availability_historyCreateWithoutVehicleInput, vehicle_availability_historyUncheckedCreateWithoutVehicleInput> | vehicle_availability_historyCreateWithoutVehicleInput[] | vehicle_availability_historyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availability_historyCreateOrConnectWithoutVehicleInput | vehicle_availability_historyCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_availability_historyCreateManyVehicleInputEnvelope
    connect?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
  }

  export type vehicle_inspectionCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicleInput, vehicle_inspectionUncheckedCreateWithoutVehicleInput> | vehicle_inspectionCreateWithoutVehicleInput[] | vehicle_inspectionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicleInput | vehicle_inspectionCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_inspectionCreateManyVehicleInputEnvelope
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
  }

  export type vehicle_pricesCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_pricesCreateWithoutVehicleInput, vehicle_pricesUncheckedCreateWithoutVehicleInput> | vehicle_pricesCreateWithoutVehicleInput[] | vehicle_pricesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_pricesCreateOrConnectWithoutVehicleInput | vehicle_pricesCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_pricesCreateManyVehicleInputEnvelope
    connect?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
  }

  export type vehicle_bookingsCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_bookingsCreateWithoutVehicleInput, vehicle_bookingsUncheckedCreateWithoutVehicleInput> | vehicle_bookingsCreateWithoutVehicleInput[] | vehicle_bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutVehicleInput | vehicle_bookingsCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_bookingsCreateManyVehicleInputEnvelope
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
  }

  export type vehicle_bookings_logsCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicleInput, vehicle_bookings_logsUncheckedCreateWithoutVehicleInput> | vehicle_bookings_logsCreateWithoutVehicleInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicleInput | vehicle_bookings_logsCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicleInputEnvelope
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
  }

  export type vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_featuresCreateWithoutVehicleInput, vehicle_featuresUncheckedCreateWithoutVehicleInput> | vehicle_featuresCreateWithoutVehicleInput[] | vehicle_featuresUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_featuresCreateOrConnectWithoutVehicleInput | vehicle_featuresCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_featuresCreateManyVehicleInputEnvelope
    connect?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
  }

  export type vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_imagesCreateWithoutVehicleInput, vehicle_imagesUncheckedCreateWithoutVehicleInput> | vehicle_imagesCreateWithoutVehicleInput[] | vehicle_imagesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_imagesCreateOrConnectWithoutVehicleInput | vehicle_imagesCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_imagesCreateManyVehicleInputEnvelope
    connect?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
  }

  export type vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_availabilityCreateWithoutVehicleInput, vehicle_availabilityUncheckedCreateWithoutVehicleInput> | vehicle_availabilityCreateWithoutVehicleInput[] | vehicle_availabilityUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availabilityCreateOrConnectWithoutVehicleInput | vehicle_availabilityCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_availabilityCreateManyVehicleInputEnvelope
    connect?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
  }

  export type vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_availability_historyCreateWithoutVehicleInput, vehicle_availability_historyUncheckedCreateWithoutVehicleInput> | vehicle_availability_historyCreateWithoutVehicleInput[] | vehicle_availability_historyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availability_historyCreateOrConnectWithoutVehicleInput | vehicle_availability_historyCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_availability_historyCreateManyVehicleInputEnvelope
    connect?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
  }

  export type vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicleInput, vehicle_inspectionUncheckedCreateWithoutVehicleInput> | vehicle_inspectionCreateWithoutVehicleInput[] | vehicle_inspectionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicleInput | vehicle_inspectionCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_inspectionCreateManyVehicleInputEnvelope
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
  }

  export type vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_pricesCreateWithoutVehicleInput, vehicle_pricesUncheckedCreateWithoutVehicleInput> | vehicle_pricesCreateWithoutVehicleInput[] | vehicle_pricesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_pricesCreateOrConnectWithoutVehicleInput | vehicle_pricesCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_pricesCreateManyVehicleInputEnvelope
    connect?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
  }

  export type vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_bookingsCreateWithoutVehicleInput, vehicle_bookingsUncheckedCreateWithoutVehicleInput> | vehicle_bookingsCreateWithoutVehicleInput[] | vehicle_bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutVehicleInput | vehicle_bookingsCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_bookingsCreateManyVehicleInputEnvelope
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
  }

  export type vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicleInput, vehicle_bookings_logsUncheckedCreateWithoutVehicleInput> | vehicle_bookings_logsCreateWithoutVehicleInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicleInput | vehicle_bookings_logsCreateOrConnectWithoutVehicleInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicleInputEnvelope
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type brandsUpdateOneRequiredWithoutVehicleNestedInput = {
    create?: XOR<brandsCreateWithoutVehicleInput, brandsUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: brandsCreateOrConnectWithoutVehicleInput
    upsert?: brandsUpsertWithoutVehicleInput
    connect?: brandsWhereUniqueInput
    update?: XOR<XOR<brandsUpdateToOneWithWhereWithoutVehicleInput, brandsUpdateWithoutVehicleInput>, brandsUncheckedUpdateWithoutVehicleInput>
  }

  export type modelsUpdateOneRequiredWithoutVehicleNestedInput = {
    create?: XOR<modelsCreateWithoutVehicleInput, modelsUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: modelsCreateOrConnectWithoutVehicleInput
    upsert?: modelsUpsertWithoutVehicleInput
    connect?: modelsWhereUniqueInput
    update?: XOR<XOR<modelsUpdateToOneWithWhereWithoutVehicleInput, modelsUpdateWithoutVehicleInput>, modelsUncheckedUpdateWithoutVehicleInput>
  }

  export type variantsUpdateOneRequiredWithoutVehicleNestedInput = {
    create?: XOR<variantsCreateWithoutVehicleInput, variantsUncheckedCreateWithoutVehicleInput>
    connectOrCreate?: variantsCreateOrConnectWithoutVehicleInput
    upsert?: variantsUpsertWithoutVehicleInput
    connect?: variantsWhereUniqueInput
    update?: XOR<XOR<variantsUpdateToOneWithWhereWithoutVehicleInput, variantsUpdateWithoutVehicleInput>, variantsUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_featuresUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_featuresCreateWithoutVehicleInput, vehicle_featuresUncheckedCreateWithoutVehicleInput> | vehicle_featuresCreateWithoutVehicleInput[] | vehicle_featuresUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_featuresCreateOrConnectWithoutVehicleInput | vehicle_featuresCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_featuresUpsertWithWhereUniqueWithoutVehicleInput | vehicle_featuresUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_featuresCreateManyVehicleInputEnvelope
    set?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    disconnect?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    delete?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    connect?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    update?: vehicle_featuresUpdateWithWhereUniqueWithoutVehicleInput | vehicle_featuresUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_featuresUpdateManyWithWhereWithoutVehicleInput | vehicle_featuresUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_featuresScalarWhereInput | vehicle_featuresScalarWhereInput[]
  }

  export type vehicle_imagesUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_imagesCreateWithoutVehicleInput, vehicle_imagesUncheckedCreateWithoutVehicleInput> | vehicle_imagesCreateWithoutVehicleInput[] | vehicle_imagesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_imagesCreateOrConnectWithoutVehicleInput | vehicle_imagesCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_imagesUpsertWithWhereUniqueWithoutVehicleInput | vehicle_imagesUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_imagesCreateManyVehicleInputEnvelope
    set?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    disconnect?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    delete?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    connect?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    update?: vehicle_imagesUpdateWithWhereUniqueWithoutVehicleInput | vehicle_imagesUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_imagesUpdateManyWithWhereWithoutVehicleInput | vehicle_imagesUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_imagesScalarWhereInput | vehicle_imagesScalarWhereInput[]
  }

  export type vehicle_availabilityUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_availabilityCreateWithoutVehicleInput, vehicle_availabilityUncheckedCreateWithoutVehicleInput> | vehicle_availabilityCreateWithoutVehicleInput[] | vehicle_availabilityUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availabilityCreateOrConnectWithoutVehicleInput | vehicle_availabilityCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_availabilityUpsertWithWhereUniqueWithoutVehicleInput | vehicle_availabilityUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_availabilityCreateManyVehicleInputEnvelope
    set?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    disconnect?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    delete?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    connect?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    update?: vehicle_availabilityUpdateWithWhereUniqueWithoutVehicleInput | vehicle_availabilityUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_availabilityUpdateManyWithWhereWithoutVehicleInput | vehicle_availabilityUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_availabilityScalarWhereInput | vehicle_availabilityScalarWhereInput[]
  }

  export type vehicle_availability_historyUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_availability_historyCreateWithoutVehicleInput, vehicle_availability_historyUncheckedCreateWithoutVehicleInput> | vehicle_availability_historyCreateWithoutVehicleInput[] | vehicle_availability_historyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availability_historyCreateOrConnectWithoutVehicleInput | vehicle_availability_historyCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_availability_historyUpsertWithWhereUniqueWithoutVehicleInput | vehicle_availability_historyUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_availability_historyCreateManyVehicleInputEnvelope
    set?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    disconnect?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    delete?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    connect?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    update?: vehicle_availability_historyUpdateWithWhereUniqueWithoutVehicleInput | vehicle_availability_historyUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_availability_historyUpdateManyWithWhereWithoutVehicleInput | vehicle_availability_historyUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_availability_historyScalarWhereInput | vehicle_availability_historyScalarWhereInput[]
  }

  export type vehicle_inspectionUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicleInput, vehicle_inspectionUncheckedCreateWithoutVehicleInput> | vehicle_inspectionCreateWithoutVehicleInput[] | vehicle_inspectionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicleInput | vehicle_inspectionCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_inspectionUpsertWithWhereUniqueWithoutVehicleInput | vehicle_inspectionUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_inspectionCreateManyVehicleInputEnvelope
    set?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    disconnect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    delete?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    update?: vehicle_inspectionUpdateWithWhereUniqueWithoutVehicleInput | vehicle_inspectionUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_inspectionUpdateManyWithWhereWithoutVehicleInput | vehicle_inspectionUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_inspectionScalarWhereInput | vehicle_inspectionScalarWhereInput[]
  }

  export type vehicle_pricesUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_pricesCreateWithoutVehicleInput, vehicle_pricesUncheckedCreateWithoutVehicleInput> | vehicle_pricesCreateWithoutVehicleInput[] | vehicle_pricesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_pricesCreateOrConnectWithoutVehicleInput | vehicle_pricesCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_pricesUpsertWithWhereUniqueWithoutVehicleInput | vehicle_pricesUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_pricesCreateManyVehicleInputEnvelope
    set?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    disconnect?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    delete?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    connect?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    update?: vehicle_pricesUpdateWithWhereUniqueWithoutVehicleInput | vehicle_pricesUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_pricesUpdateManyWithWhereWithoutVehicleInput | vehicle_pricesUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_pricesScalarWhereInput | vehicle_pricesScalarWhereInput[]
  }

  export type vehicle_bookingsUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutVehicleInput, vehicle_bookingsUncheckedCreateWithoutVehicleInput> | vehicle_bookingsCreateWithoutVehicleInput[] | vehicle_bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutVehicleInput | vehicle_bookingsCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_bookingsUpsertWithWhereUniqueWithoutVehicleInput | vehicle_bookingsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_bookingsCreateManyVehicleInputEnvelope
    set?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    disconnect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    delete?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    update?: vehicle_bookingsUpdateWithWhereUniqueWithoutVehicleInput | vehicle_bookingsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_bookingsUpdateManyWithWhereWithoutVehicleInput | vehicle_bookingsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_bookingsScalarWhereInput | vehicle_bookingsScalarWhereInput[]
  }

  export type vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicleInput, vehicle_bookings_logsUncheckedCreateWithoutVehicleInput> | vehicle_bookings_logsCreateWithoutVehicleInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicleInput | vehicle_bookings_logsCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicleInput | vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicleInputEnvelope
    set?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    disconnect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    delete?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    update?: vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicleInput | vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_bookings_logsUpdateManyWithWhereWithoutVehicleInput | vehicle_bookings_logsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
  }

  export type vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_featuresCreateWithoutVehicleInput, vehicle_featuresUncheckedCreateWithoutVehicleInput> | vehicle_featuresCreateWithoutVehicleInput[] | vehicle_featuresUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_featuresCreateOrConnectWithoutVehicleInput | vehicle_featuresCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_featuresUpsertWithWhereUniqueWithoutVehicleInput | vehicle_featuresUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_featuresCreateManyVehicleInputEnvelope
    set?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    disconnect?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    delete?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    connect?: vehicle_featuresWhereUniqueInput | vehicle_featuresWhereUniqueInput[]
    update?: vehicle_featuresUpdateWithWhereUniqueWithoutVehicleInput | vehicle_featuresUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_featuresUpdateManyWithWhereWithoutVehicleInput | vehicle_featuresUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_featuresScalarWhereInput | vehicle_featuresScalarWhereInput[]
  }

  export type vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_imagesCreateWithoutVehicleInput, vehicle_imagesUncheckedCreateWithoutVehicleInput> | vehicle_imagesCreateWithoutVehicleInput[] | vehicle_imagesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_imagesCreateOrConnectWithoutVehicleInput | vehicle_imagesCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_imagesUpsertWithWhereUniqueWithoutVehicleInput | vehicle_imagesUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_imagesCreateManyVehicleInputEnvelope
    set?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    disconnect?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    delete?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    connect?: vehicle_imagesWhereUniqueInput | vehicle_imagesWhereUniqueInput[]
    update?: vehicle_imagesUpdateWithWhereUniqueWithoutVehicleInput | vehicle_imagesUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_imagesUpdateManyWithWhereWithoutVehicleInput | vehicle_imagesUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_imagesScalarWhereInput | vehicle_imagesScalarWhereInput[]
  }

  export type vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_availabilityCreateWithoutVehicleInput, vehicle_availabilityUncheckedCreateWithoutVehicleInput> | vehicle_availabilityCreateWithoutVehicleInput[] | vehicle_availabilityUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availabilityCreateOrConnectWithoutVehicleInput | vehicle_availabilityCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_availabilityUpsertWithWhereUniqueWithoutVehicleInput | vehicle_availabilityUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_availabilityCreateManyVehicleInputEnvelope
    set?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    disconnect?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    delete?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    connect?: vehicle_availabilityWhereUniqueInput | vehicle_availabilityWhereUniqueInput[]
    update?: vehicle_availabilityUpdateWithWhereUniqueWithoutVehicleInput | vehicle_availabilityUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_availabilityUpdateManyWithWhereWithoutVehicleInput | vehicle_availabilityUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_availabilityScalarWhereInput | vehicle_availabilityScalarWhereInput[]
  }

  export type vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_availability_historyCreateWithoutVehicleInput, vehicle_availability_historyUncheckedCreateWithoutVehicleInput> | vehicle_availability_historyCreateWithoutVehicleInput[] | vehicle_availability_historyUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_availability_historyCreateOrConnectWithoutVehicleInput | vehicle_availability_historyCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_availability_historyUpsertWithWhereUniqueWithoutVehicleInput | vehicle_availability_historyUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_availability_historyCreateManyVehicleInputEnvelope
    set?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    disconnect?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    delete?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    connect?: vehicle_availability_historyWhereUniqueInput | vehicle_availability_historyWhereUniqueInput[]
    update?: vehicle_availability_historyUpdateWithWhereUniqueWithoutVehicleInput | vehicle_availability_historyUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_availability_historyUpdateManyWithWhereWithoutVehicleInput | vehicle_availability_historyUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_availability_historyScalarWhereInput | vehicle_availability_historyScalarWhereInput[]
  }

  export type vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicleInput, vehicle_inspectionUncheckedCreateWithoutVehicleInput> | vehicle_inspectionCreateWithoutVehicleInput[] | vehicle_inspectionUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicleInput | vehicle_inspectionCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_inspectionUpsertWithWhereUniqueWithoutVehicleInput | vehicle_inspectionUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_inspectionCreateManyVehicleInputEnvelope
    set?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    disconnect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    delete?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    update?: vehicle_inspectionUpdateWithWhereUniqueWithoutVehicleInput | vehicle_inspectionUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_inspectionUpdateManyWithWhereWithoutVehicleInput | vehicle_inspectionUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_inspectionScalarWhereInput | vehicle_inspectionScalarWhereInput[]
  }

  export type vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_pricesCreateWithoutVehicleInput, vehicle_pricesUncheckedCreateWithoutVehicleInput> | vehicle_pricesCreateWithoutVehicleInput[] | vehicle_pricesUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_pricesCreateOrConnectWithoutVehicleInput | vehicle_pricesCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_pricesUpsertWithWhereUniqueWithoutVehicleInput | vehicle_pricesUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_pricesCreateManyVehicleInputEnvelope
    set?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    disconnect?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    delete?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    connect?: vehicle_pricesWhereUniqueInput | vehicle_pricesWhereUniqueInput[]
    update?: vehicle_pricesUpdateWithWhereUniqueWithoutVehicleInput | vehicle_pricesUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_pricesUpdateManyWithWhereWithoutVehicleInput | vehicle_pricesUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_pricesScalarWhereInput | vehicle_pricesScalarWhereInput[]
  }

  export type vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutVehicleInput, vehicle_bookingsUncheckedCreateWithoutVehicleInput> | vehicle_bookingsCreateWithoutVehicleInput[] | vehicle_bookingsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutVehicleInput | vehicle_bookingsCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_bookingsUpsertWithWhereUniqueWithoutVehicleInput | vehicle_bookingsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_bookingsCreateManyVehicleInputEnvelope
    set?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    disconnect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    delete?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    update?: vehicle_bookingsUpdateWithWhereUniqueWithoutVehicleInput | vehicle_bookingsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_bookingsUpdateManyWithWhereWithoutVehicleInput | vehicle_bookingsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_bookingsScalarWhereInput | vehicle_bookingsScalarWhereInput[]
  }

  export type vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicleInput, vehicle_bookings_logsUncheckedCreateWithoutVehicleInput> | vehicle_bookings_logsCreateWithoutVehicleInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicleInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicleInput | vehicle_bookings_logsCreateOrConnectWithoutVehicleInput[]
    upsert?: vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicleInput | vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicleInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicleInputEnvelope
    set?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    disconnect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    delete?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    update?: vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicleInput | vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicleInput[]
    updateMany?: vehicle_bookings_logsUpdateManyWithWhereWithoutVehicleInput | vehicle_bookings_logsUpdateManyWithWhereWithoutVehicleInput[]
    deleteMany?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
  }

  export type vehicleCreateNestedOneWithoutFeaturesInput = {
    create?: XOR<vehicleCreateWithoutFeaturesInput, vehicleUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutFeaturesInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicleUpdateOneRequiredWithoutFeaturesNestedInput = {
    create?: XOR<vehicleCreateWithoutFeaturesInput, vehicleUncheckedCreateWithoutFeaturesInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutFeaturesInput
    upsert?: vehicleUpsertWithoutFeaturesInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutFeaturesInput, vehicleUpdateWithoutFeaturesInput>, vehicleUncheckedUpdateWithoutFeaturesInput>
  }

  export type vehicleCreateNestedOneWithoutImagesInput = {
    create?: XOR<vehicleCreateWithoutImagesInput, vehicleUncheckedCreateWithoutImagesInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutImagesInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicleUpdateOneRequiredWithoutImagesNestedInput = {
    create?: XOR<vehicleCreateWithoutImagesInput, vehicleUncheckedCreateWithoutImagesInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutImagesInput
    upsert?: vehicleUpsertWithoutImagesInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutImagesInput, vehicleUpdateWithoutImagesInput>, vehicleUncheckedUpdateWithoutImagesInput>
  }

  export type vehicleCreateNestedOneWithoutAvailabilityInput = {
    create?: XOR<vehicleCreateWithoutAvailabilityInput, vehicleUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutAvailabilityInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicleUpdateOneRequiredWithoutAvailabilityNestedInput = {
    create?: XOR<vehicleCreateWithoutAvailabilityInput, vehicleUncheckedCreateWithoutAvailabilityInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutAvailabilityInput
    upsert?: vehicleUpsertWithoutAvailabilityInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutAvailabilityInput, vehicleUpdateWithoutAvailabilityInput>, vehicleUncheckedUpdateWithoutAvailabilityInput>
  }

  export type vehicleCreateNestedOneWithoutAvailability_historyInput = {
    create?: XOR<vehicleCreateWithoutAvailability_historyInput, vehicleUncheckedCreateWithoutAvailability_historyInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutAvailability_historyInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicleUpdateOneRequiredWithoutAvailability_historyNestedInput = {
    create?: XOR<vehicleCreateWithoutAvailability_historyInput, vehicleUncheckedCreateWithoutAvailability_historyInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutAvailability_historyInput
    upsert?: vehicleUpsertWithoutAvailability_historyInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutAvailability_historyInput, vehicleUpdateWithoutAvailability_historyInput>, vehicleUncheckedUpdateWithoutAvailability_historyInput>
  }

  export type vehicleCreateNestedOneWithoutInspectionsInput = {
    create?: XOR<vehicleCreateWithoutInspectionsInput, vehicleUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutInspectionsInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicle_inspection_detailsCreateNestedManyWithoutVehicle_inspectionInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput> | vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput | vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput[]
    createMany?: vehicle_inspection_detailsCreateManyVehicle_inspectionInputEnvelope
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
  }

  export type vehicle_bookingsCreateNestedOneWithoutVehicle_inspectionInput = {
    create?: XOR<vehicle_bookingsCreateWithoutVehicle_inspectionInput, vehicle_bookingsUncheckedCreateWithoutVehicle_inspectionInput>
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutVehicle_inspectionInput
    connect?: vehicle_bookingsWhereUniqueInput
  }

  export type vehicle_inspection_detailsUncheckedCreateNestedManyWithoutVehicle_inspectionInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput> | vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput | vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput[]
    createMany?: vehicle_inspection_detailsCreateManyVehicle_inspectionInputEnvelope
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
  }

  export type vehicleUpdateOneRequiredWithoutInspectionsNestedInput = {
    create?: XOR<vehicleCreateWithoutInspectionsInput, vehicleUncheckedCreateWithoutInspectionsInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutInspectionsInput
    upsert?: vehicleUpsertWithoutInspectionsInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutInspectionsInput, vehicleUpdateWithoutInspectionsInput>, vehicleUncheckedUpdateWithoutInspectionsInput>
  }

  export type vehicle_inspection_detailsUpdateManyWithoutVehicle_inspectionNestedInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput> | vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput | vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput[]
    upsert?: vehicle_inspection_detailsUpsertWithWhereUniqueWithoutVehicle_inspectionInput | vehicle_inspection_detailsUpsertWithWhereUniqueWithoutVehicle_inspectionInput[]
    createMany?: vehicle_inspection_detailsCreateManyVehicle_inspectionInputEnvelope
    set?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    disconnect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    delete?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    update?: vehicle_inspection_detailsUpdateWithWhereUniqueWithoutVehicle_inspectionInput | vehicle_inspection_detailsUpdateWithWhereUniqueWithoutVehicle_inspectionInput[]
    updateMany?: vehicle_inspection_detailsUpdateManyWithWhereWithoutVehicle_inspectionInput | vehicle_inspection_detailsUpdateManyWithWhereWithoutVehicle_inspectionInput[]
    deleteMany?: vehicle_inspection_detailsScalarWhereInput | vehicle_inspection_detailsScalarWhereInput[]
  }

  export type vehicle_bookingsUpdateOneWithoutVehicle_inspectionNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutVehicle_inspectionInput, vehicle_bookingsUncheckedCreateWithoutVehicle_inspectionInput>
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutVehicle_inspectionInput
    upsert?: vehicle_bookingsUpsertWithoutVehicle_inspectionInput
    disconnect?: boolean
    delete?: vehicle_bookingsWhereInput | boolean
    connect?: vehicle_bookingsWhereUniqueInput
    update?: XOR<XOR<vehicle_bookingsUpdateToOneWithWhereWithoutVehicle_inspectionInput, vehicle_bookingsUpdateWithoutVehicle_inspectionInput>, vehicle_bookingsUncheckedUpdateWithoutVehicle_inspectionInput>
  }

  export type vehicle_inspection_detailsUncheckedUpdateManyWithoutVehicle_inspectionNestedInput = {
    create?: XOR<vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput> | vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput[] | vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput[]
    connectOrCreate?: vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput | vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput[]
    upsert?: vehicle_inspection_detailsUpsertWithWhereUniqueWithoutVehicle_inspectionInput | vehicle_inspection_detailsUpsertWithWhereUniqueWithoutVehicle_inspectionInput[]
    createMany?: vehicle_inspection_detailsCreateManyVehicle_inspectionInputEnvelope
    set?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    disconnect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    delete?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    connect?: vehicle_inspection_detailsWhereUniqueInput | vehicle_inspection_detailsWhereUniqueInput[]
    update?: vehicle_inspection_detailsUpdateWithWhereUniqueWithoutVehicle_inspectionInput | vehicle_inspection_detailsUpdateWithWhereUniqueWithoutVehicle_inspectionInput[]
    updateMany?: vehicle_inspection_detailsUpdateManyWithWhereWithoutVehicle_inspectionInput | vehicle_inspection_detailsUpdateManyWithWhereWithoutVehicle_inspectionInput[]
    deleteMany?: vehicle_inspection_detailsScalarWhereInput | vehicle_inspection_detailsScalarWhereInput[]
  }

  export type checklist_optionsCreateNestedOneWithoutInspectionDetailsInput = {
    create?: XOR<checklist_optionsCreateWithoutInspectionDetailsInput, checklist_optionsUncheckedCreateWithoutInspectionDetailsInput>
    connectOrCreate?: checklist_optionsCreateOrConnectWithoutInspectionDetailsInput
    connect?: checklist_optionsWhereUniqueInput
  }

  export type vehicle_inspectionCreateNestedOneWithoutDetailsInput = {
    create?: XOR<vehicle_inspectionCreateWithoutDetailsInput, vehicle_inspectionUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutDetailsInput
    connect?: vehicle_inspectionWhereUniqueInput
  }

  export type checklist_optionsUpdateOneRequiredWithoutInspectionDetailsNestedInput = {
    create?: XOR<checklist_optionsCreateWithoutInspectionDetailsInput, checklist_optionsUncheckedCreateWithoutInspectionDetailsInput>
    connectOrCreate?: checklist_optionsCreateOrConnectWithoutInspectionDetailsInput
    upsert?: checklist_optionsUpsertWithoutInspectionDetailsInput
    connect?: checklist_optionsWhereUniqueInput
    update?: XOR<XOR<checklist_optionsUpdateToOneWithWhereWithoutInspectionDetailsInput, checklist_optionsUpdateWithoutInspectionDetailsInput>, checklist_optionsUncheckedUpdateWithoutInspectionDetailsInput>
  }

  export type vehicle_inspectionUpdateOneRequiredWithoutDetailsNestedInput = {
    create?: XOR<vehicle_inspectionCreateWithoutDetailsInput, vehicle_inspectionUncheckedCreateWithoutDetailsInput>
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutDetailsInput
    upsert?: vehicle_inspectionUpsertWithoutDetailsInput
    connect?: vehicle_inspectionWhereUniqueInput
    update?: XOR<XOR<vehicle_inspectionUpdateToOneWithWhereWithoutDetailsInput, vehicle_inspectionUpdateWithoutDetailsInput>, vehicle_inspectionUncheckedUpdateWithoutDetailsInput>
  }

  export type vehicleCreateNestedOneWithoutPricesInput = {
    create?: XOR<vehicleCreateWithoutPricesInput, vehicleUncheckedCreateWithoutPricesInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutPricesInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicle_bookings_billsCreateNestedManyWithoutVehicle_priceInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput> | vehicle_bookings_billsCreateWithoutVehicle_priceInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_priceInputEnvelope
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
  }

  export type vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_priceInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput> | vehicle_bookings_billsCreateWithoutVehicle_priceInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_priceInputEnvelope
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
  }

  export type vehicleUpdateOneRequiredWithoutPricesNestedInput = {
    create?: XOR<vehicleCreateWithoutPricesInput, vehicleUncheckedCreateWithoutPricesInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutPricesInput
    upsert?: vehicleUpsertWithoutPricesInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutPricesInput, vehicleUpdateWithoutPricesInput>, vehicleUncheckedUpdateWithoutPricesInput>
  }

  export type vehicle_bookings_billsUpdateManyWithoutVehicle_priceNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput> | vehicle_bookings_billsCreateWithoutVehicle_priceInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput[]
    upsert?: vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_priceInput | vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_priceInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_priceInputEnvelope
    set?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    disconnect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    delete?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    update?: vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_priceInput | vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_priceInput[]
    updateMany?: vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_priceInput | vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_priceInput[]
    deleteMany?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
  }

  export type vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_priceNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput> | vehicle_bookings_billsCreateWithoutVehicle_priceInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput[]
    upsert?: vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_priceInput | vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_priceInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_priceInputEnvelope
    set?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    disconnect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    delete?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    update?: vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_priceInput | vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_priceInput[]
    updateMany?: vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_priceInput | vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_priceInput[]
    deleteMany?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
  }

  export type citiesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<citiesCreateWithoutCustomersInput, citiesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: citiesCreateOrConnectWithoutCustomersInput
    connect?: citiesWhereUniqueInput
  }

  export type statesCreateNestedOneWithoutCustomersInput = {
    create?: XOR<statesCreateWithoutCustomersInput, statesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: statesCreateOrConnectWithoutCustomersInput
    connect?: statesWhereUniqueInput
  }

  export type vehicle_bookingsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<vehicle_bookingsCreateWithoutCustomerInput, vehicle_bookingsUncheckedCreateWithoutCustomerInput> | vehicle_bookingsCreateWithoutCustomerInput[] | vehicle_bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutCustomerInput | vehicle_bookingsCreateOrConnectWithoutCustomerInput[]
    createMany?: vehicle_bookingsCreateManyCustomerInputEnvelope
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
  }

  export type vehicle_bookings_logsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutCustomerInput, vehicle_bookings_logsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_logsCreateWithoutCustomerInput[] | vehicle_bookings_logsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutCustomerInput | vehicle_bookings_logsCreateOrConnectWithoutCustomerInput[]
    createMany?: vehicle_bookings_logsCreateManyCustomerInputEnvelope
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
  }

  export type vehicle_bookings_billsCreateNestedManyWithoutCustomerInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutCustomerInput, vehicle_bookings_billsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_billsCreateWithoutCustomerInput[] | vehicle_bookings_billsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutCustomerInput | vehicle_bookings_billsCreateOrConnectWithoutCustomerInput[]
    createMany?: vehicle_bookings_billsCreateManyCustomerInputEnvelope
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
  }

  export type vehicle_bookingsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<vehicle_bookingsCreateWithoutCustomerInput, vehicle_bookingsUncheckedCreateWithoutCustomerInput> | vehicle_bookingsCreateWithoutCustomerInput[] | vehicle_bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutCustomerInput | vehicle_bookingsCreateOrConnectWithoutCustomerInput[]
    createMany?: vehicle_bookingsCreateManyCustomerInputEnvelope
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
  }

  export type vehicle_bookings_logsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutCustomerInput, vehicle_bookings_logsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_logsCreateWithoutCustomerInput[] | vehicle_bookings_logsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutCustomerInput | vehicle_bookings_logsCreateOrConnectWithoutCustomerInput[]
    createMany?: vehicle_bookings_logsCreateManyCustomerInputEnvelope
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
  }

  export type vehicle_bookings_billsUncheckedCreateNestedManyWithoutCustomerInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutCustomerInput, vehicle_bookings_billsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_billsCreateWithoutCustomerInput[] | vehicle_bookings_billsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutCustomerInput | vehicle_bookings_billsCreateOrConnectWithoutCustomerInput[]
    createMany?: vehicle_bookings_billsCreateManyCustomerInputEnvelope
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
  }

  export type citiesUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<citiesCreateWithoutCustomersInput, citiesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: citiesCreateOrConnectWithoutCustomersInput
    upsert?: citiesUpsertWithoutCustomersInput
    connect?: citiesWhereUniqueInput
    update?: XOR<XOR<citiesUpdateToOneWithWhereWithoutCustomersInput, citiesUpdateWithoutCustomersInput>, citiesUncheckedUpdateWithoutCustomersInput>
  }

  export type statesUpdateOneRequiredWithoutCustomersNestedInput = {
    create?: XOR<statesCreateWithoutCustomersInput, statesUncheckedCreateWithoutCustomersInput>
    connectOrCreate?: statesCreateOrConnectWithoutCustomersInput
    upsert?: statesUpsertWithoutCustomersInput
    connect?: statesWhereUniqueInput
    update?: XOR<XOR<statesUpdateToOneWithWhereWithoutCustomersInput, statesUpdateWithoutCustomersInput>, statesUncheckedUpdateWithoutCustomersInput>
  }

  export type vehicle_bookingsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutCustomerInput, vehicle_bookingsUncheckedCreateWithoutCustomerInput> | vehicle_bookingsCreateWithoutCustomerInput[] | vehicle_bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutCustomerInput | vehicle_bookingsCreateOrConnectWithoutCustomerInput[]
    upsert?: vehicle_bookingsUpsertWithWhereUniqueWithoutCustomerInput | vehicle_bookingsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: vehicle_bookingsCreateManyCustomerInputEnvelope
    set?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    disconnect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    delete?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    update?: vehicle_bookingsUpdateWithWhereUniqueWithoutCustomerInput | vehicle_bookingsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: vehicle_bookingsUpdateManyWithWhereWithoutCustomerInput | vehicle_bookingsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: vehicle_bookingsScalarWhereInput | vehicle_bookingsScalarWhereInput[]
  }

  export type vehicle_bookings_logsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutCustomerInput, vehicle_bookings_logsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_logsCreateWithoutCustomerInput[] | vehicle_bookings_logsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutCustomerInput | vehicle_bookings_logsCreateOrConnectWithoutCustomerInput[]
    upsert?: vehicle_bookings_logsUpsertWithWhereUniqueWithoutCustomerInput | vehicle_bookings_logsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: vehicle_bookings_logsCreateManyCustomerInputEnvelope
    set?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    disconnect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    delete?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    update?: vehicle_bookings_logsUpdateWithWhereUniqueWithoutCustomerInput | vehicle_bookings_logsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: vehicle_bookings_logsUpdateManyWithWhereWithoutCustomerInput | vehicle_bookings_logsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
  }

  export type vehicle_bookings_billsUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutCustomerInput, vehicle_bookings_billsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_billsCreateWithoutCustomerInput[] | vehicle_bookings_billsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutCustomerInput | vehicle_bookings_billsCreateOrConnectWithoutCustomerInput[]
    upsert?: vehicle_bookings_billsUpsertWithWhereUniqueWithoutCustomerInput | vehicle_bookings_billsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: vehicle_bookings_billsCreateManyCustomerInputEnvelope
    set?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    disconnect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    delete?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    update?: vehicle_bookings_billsUpdateWithWhereUniqueWithoutCustomerInput | vehicle_bookings_billsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: vehicle_bookings_billsUpdateManyWithWhereWithoutCustomerInput | vehicle_bookings_billsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
  }

  export type vehicle_bookingsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutCustomerInput, vehicle_bookingsUncheckedCreateWithoutCustomerInput> | vehicle_bookingsCreateWithoutCustomerInput[] | vehicle_bookingsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutCustomerInput | vehicle_bookingsCreateOrConnectWithoutCustomerInput[]
    upsert?: vehicle_bookingsUpsertWithWhereUniqueWithoutCustomerInput | vehicle_bookingsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: vehicle_bookingsCreateManyCustomerInputEnvelope
    set?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    disconnect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    delete?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    connect?: vehicle_bookingsWhereUniqueInput | vehicle_bookingsWhereUniqueInput[]
    update?: vehicle_bookingsUpdateWithWhereUniqueWithoutCustomerInput | vehicle_bookingsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: vehicle_bookingsUpdateManyWithWhereWithoutCustomerInput | vehicle_bookingsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: vehicle_bookingsScalarWhereInput | vehicle_bookingsScalarWhereInput[]
  }

  export type vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutCustomerInput, vehicle_bookings_logsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_logsCreateWithoutCustomerInput[] | vehicle_bookings_logsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutCustomerInput | vehicle_bookings_logsCreateOrConnectWithoutCustomerInput[]
    upsert?: vehicle_bookings_logsUpsertWithWhereUniqueWithoutCustomerInput | vehicle_bookings_logsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: vehicle_bookings_logsCreateManyCustomerInputEnvelope
    set?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    disconnect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    delete?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    update?: vehicle_bookings_logsUpdateWithWhereUniqueWithoutCustomerInput | vehicle_bookings_logsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: vehicle_bookings_logsUpdateManyWithWhereWithoutCustomerInput | vehicle_bookings_logsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
  }

  export type vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutCustomerInput, vehicle_bookings_billsUncheckedCreateWithoutCustomerInput> | vehicle_bookings_billsCreateWithoutCustomerInput[] | vehicle_bookings_billsUncheckedCreateWithoutCustomerInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutCustomerInput | vehicle_bookings_billsCreateOrConnectWithoutCustomerInput[]
    upsert?: vehicle_bookings_billsUpsertWithWhereUniqueWithoutCustomerInput | vehicle_bookings_billsUpsertWithWhereUniqueWithoutCustomerInput[]
    createMany?: vehicle_bookings_billsCreateManyCustomerInputEnvelope
    set?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    disconnect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    delete?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    update?: vehicle_bookings_billsUpdateWithWhereUniqueWithoutCustomerInput | vehicle_bookings_billsUpdateWithWhereUniqueWithoutCustomerInput[]
    updateMany?: vehicle_bookings_billsUpdateManyWithWhereWithoutCustomerInput | vehicle_bookings_billsUpdateManyWithWhereWithoutCustomerInput[]
    deleteMany?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
  }

  export type citiesCreateNestedOneWithoutProvidersInput = {
    create?: XOR<citiesCreateWithoutProvidersInput, citiesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: citiesCreateOrConnectWithoutProvidersInput
    connect?: citiesWhereUniqueInput
  }

  export type statesCreateNestedOneWithoutProvidersInput = {
    create?: XOR<statesCreateWithoutProvidersInput, statesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: statesCreateOrConnectWithoutProvidersInput
    connect?: statesWhereUniqueInput
  }

  export type citiesUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<citiesCreateWithoutProvidersInput, citiesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: citiesCreateOrConnectWithoutProvidersInput
    upsert?: citiesUpsertWithoutProvidersInput
    connect?: citiesWhereUniqueInput
    update?: XOR<XOR<citiesUpdateToOneWithWhereWithoutProvidersInput, citiesUpdateWithoutProvidersInput>, citiesUncheckedUpdateWithoutProvidersInput>
  }

  export type statesUpdateOneRequiredWithoutProvidersNestedInput = {
    create?: XOR<statesCreateWithoutProvidersInput, statesUncheckedCreateWithoutProvidersInput>
    connectOrCreate?: statesCreateOrConnectWithoutProvidersInput
    upsert?: statesUpsertWithoutProvidersInput
    connect?: statesWhereUniqueInput
    update?: XOR<XOR<statesUpdateToOneWithWhereWithoutProvidersInput, statesUpdateWithoutProvidersInput>, statesUncheckedUpdateWithoutProvidersInput>
  }

  export type vehicleCreateNestedOneWithoutBookingsInput = {
    create?: XOR<vehicleCreateWithoutBookingsInput, vehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutBookingsInput
    connect?: vehicleWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutVehicle_bookingsInput = {
    create?: XOR<customerCreateWithoutVehicle_bookingsInput, customerUncheckedCreateWithoutVehicle_bookingsInput>
    connectOrCreate?: customerCreateOrConnectWithoutVehicle_bookingsInput
    connect?: customerWhereUniqueInput
  }

  export type vehicle_inspectionCreateNestedManyWithoutVehicle_bookingsInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput> | vehicle_inspectionCreateWithoutVehicle_bookingsInput[] | vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput | vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput[]
    createMany?: vehicle_inspectionCreateManyVehicle_bookingsInputEnvelope
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
  }

  export type vehicle_bookings_logsCreateNestedManyWithoutVehicle_bookingInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_logsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicle_bookingInputEnvelope
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
  }

  export type vehicle_bookings_billsCreateNestedManyWithoutVehicle_bookingInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_billsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_bookingInputEnvelope
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
  }

  export type vehicle_inspectionUncheckedCreateNestedManyWithoutVehicle_bookingsInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput> | vehicle_inspectionCreateWithoutVehicle_bookingsInput[] | vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput | vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput[]
    createMany?: vehicle_inspectionCreateManyVehicle_bookingsInputEnvelope
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
  }

  export type vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicle_bookingInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_logsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicle_bookingInputEnvelope
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
  }

  export type vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_bookingInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_billsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_bookingInputEnvelope
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
  }

  export type vehicleUpdateOneRequiredWithoutBookingsNestedInput = {
    create?: XOR<vehicleCreateWithoutBookingsInput, vehicleUncheckedCreateWithoutBookingsInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutBookingsInput
    upsert?: vehicleUpsertWithoutBookingsInput
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutBookingsInput, vehicleUpdateWithoutBookingsInput>, vehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type customerUpdateOneRequiredWithoutVehicle_bookingsNestedInput = {
    create?: XOR<customerCreateWithoutVehicle_bookingsInput, customerUncheckedCreateWithoutVehicle_bookingsInput>
    connectOrCreate?: customerCreateOrConnectWithoutVehicle_bookingsInput
    upsert?: customerUpsertWithoutVehicle_bookingsInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutVehicle_bookingsInput, customerUpdateWithoutVehicle_bookingsInput>, customerUncheckedUpdateWithoutVehicle_bookingsInput>
  }

  export type vehicle_inspectionUpdateManyWithoutVehicle_bookingsNestedInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput> | vehicle_inspectionCreateWithoutVehicle_bookingsInput[] | vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput | vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput[]
    upsert?: vehicle_inspectionUpsertWithWhereUniqueWithoutVehicle_bookingsInput | vehicle_inspectionUpsertWithWhereUniqueWithoutVehicle_bookingsInput[]
    createMany?: vehicle_inspectionCreateManyVehicle_bookingsInputEnvelope
    set?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    disconnect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    delete?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    update?: vehicle_inspectionUpdateWithWhereUniqueWithoutVehicle_bookingsInput | vehicle_inspectionUpdateWithWhereUniqueWithoutVehicle_bookingsInput[]
    updateMany?: vehicle_inspectionUpdateManyWithWhereWithoutVehicle_bookingsInput | vehicle_inspectionUpdateManyWithWhereWithoutVehicle_bookingsInput[]
    deleteMany?: vehicle_inspectionScalarWhereInput | vehicle_inspectionScalarWhereInput[]
  }

  export type vehicle_bookings_logsUpdateManyWithoutVehicle_bookingNestedInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_logsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput[]
    upsert?: vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicle_bookingInputEnvelope
    set?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    disconnect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    delete?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    update?: vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicle_bookingInput[]
    updateMany?: vehicle_bookings_logsUpdateManyWithWhereWithoutVehicle_bookingInput | vehicle_bookings_logsUpdateManyWithWhereWithoutVehicle_bookingInput[]
    deleteMany?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
  }

  export type vehicle_bookings_billsUpdateManyWithoutVehicle_bookingNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_billsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput[]
    upsert?: vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_bookingInputEnvelope
    set?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    disconnect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    delete?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    update?: vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_bookingInput[]
    updateMany?: vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_bookingInput | vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_bookingInput[]
    deleteMany?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
  }

  export type vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsNestedInput = {
    create?: XOR<vehicle_inspectionCreateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput> | vehicle_inspectionCreateWithoutVehicle_bookingsInput[] | vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput[]
    connectOrCreate?: vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput | vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput[]
    upsert?: vehicle_inspectionUpsertWithWhereUniqueWithoutVehicle_bookingsInput | vehicle_inspectionUpsertWithWhereUniqueWithoutVehicle_bookingsInput[]
    createMany?: vehicle_inspectionCreateManyVehicle_bookingsInputEnvelope
    set?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    disconnect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    delete?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    connect?: vehicle_inspectionWhereUniqueInput | vehicle_inspectionWhereUniqueInput[]
    update?: vehicle_inspectionUpdateWithWhereUniqueWithoutVehicle_bookingsInput | vehicle_inspectionUpdateWithWhereUniqueWithoutVehicle_bookingsInput[]
    updateMany?: vehicle_inspectionUpdateManyWithWhereWithoutVehicle_bookingsInput | vehicle_inspectionUpdateManyWithWhereWithoutVehicle_bookingsInput[]
    deleteMany?: vehicle_inspectionScalarWhereInput | vehicle_inspectionScalarWhereInput[]
  }

  export type vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingNestedInput = {
    create?: XOR<vehicle_bookings_logsCreateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_logsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput[]
    upsert?: vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_logsCreateManyVehicle_bookingInputEnvelope
    set?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    disconnect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    delete?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    connect?: vehicle_bookings_logsWhereUniqueInput | vehicle_bookings_logsWhereUniqueInput[]
    update?: vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicle_bookingInput[]
    updateMany?: vehicle_bookings_logsUpdateManyWithWhereWithoutVehicle_bookingInput | vehicle_bookings_logsUpdateManyWithWhereWithoutVehicle_bookingInput[]
    deleteMany?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
  }

  export type vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput> | vehicle_bookings_billsCreateWithoutVehicle_bookingInput[] | vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput[]
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput | vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput[]
    upsert?: vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_bookingInput[]
    createMany?: vehicle_bookings_billsCreateManyVehicle_bookingInputEnvelope
    set?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    disconnect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    delete?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    connect?: vehicle_bookings_billsWhereUniqueInput | vehicle_bookings_billsWhereUniqueInput[]
    update?: vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_bookingInput | vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_bookingInput[]
    updateMany?: vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_bookingInput | vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_bookingInput[]
    deleteMany?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
  }

  export type vehicleCreateNestedOneWithoutBooking_logsInput = {
    create?: XOR<vehicleCreateWithoutBooking_logsInput, vehicleUncheckedCreateWithoutBooking_logsInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutBooking_logsInput
    connect?: vehicleWhereUniqueInput
  }

  export type vehicle_bookingsCreateNestedOneWithoutBooking_logsInput = {
    create?: XOR<vehicle_bookingsCreateWithoutBooking_logsInput, vehicle_bookingsUncheckedCreateWithoutBooking_logsInput>
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutBooking_logsInput
    connect?: vehicle_bookingsWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutVehicle_bookings_logsInput = {
    create?: XOR<customerCreateWithoutVehicle_bookings_logsInput, customerUncheckedCreateWithoutVehicle_bookings_logsInput>
    connectOrCreate?: customerCreateOrConnectWithoutVehicle_bookings_logsInput
    connect?: customerWhereUniqueInput
  }

  export type vehicleUpdateOneWithoutBooking_logsNestedInput = {
    create?: XOR<vehicleCreateWithoutBooking_logsInput, vehicleUncheckedCreateWithoutBooking_logsInput>
    connectOrCreate?: vehicleCreateOrConnectWithoutBooking_logsInput
    upsert?: vehicleUpsertWithoutBooking_logsInput
    disconnect?: boolean
    delete?: vehicleWhereInput | boolean
    connect?: vehicleWhereUniqueInput
    update?: XOR<XOR<vehicleUpdateToOneWithWhereWithoutBooking_logsInput, vehicleUpdateWithoutBooking_logsInput>, vehicleUncheckedUpdateWithoutBooking_logsInput>
  }

  export type vehicle_bookingsUpdateOneWithoutBooking_logsNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutBooking_logsInput, vehicle_bookingsUncheckedCreateWithoutBooking_logsInput>
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutBooking_logsInput
    upsert?: vehicle_bookingsUpsertWithoutBooking_logsInput
    disconnect?: boolean
    delete?: vehicle_bookingsWhereInput | boolean
    connect?: vehicle_bookingsWhereUniqueInput
    update?: XOR<XOR<vehicle_bookingsUpdateToOneWithWhereWithoutBooking_logsInput, vehicle_bookingsUpdateWithoutBooking_logsInput>, vehicle_bookingsUncheckedUpdateWithoutBooking_logsInput>
  }

  export type customerUpdateOneWithoutVehicle_bookings_logsNestedInput = {
    create?: XOR<customerCreateWithoutVehicle_bookings_logsInput, customerUncheckedCreateWithoutVehicle_bookings_logsInput>
    connectOrCreate?: customerCreateOrConnectWithoutVehicle_bookings_logsInput
    upsert?: customerUpsertWithoutVehicle_bookings_logsInput
    disconnect?: boolean
    delete?: customerWhereInput | boolean
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutVehicle_bookings_logsInput, customerUpdateWithoutVehicle_bookings_logsInput>, customerUncheckedUpdateWithoutVehicle_bookings_logsInput>
  }

  export type vehicle_bookingsCreateNestedOneWithoutBillsInput = {
    create?: XOR<vehicle_bookingsCreateWithoutBillsInput, vehicle_bookingsUncheckedCreateWithoutBillsInput>
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutBillsInput
    connect?: vehicle_bookingsWhereUniqueInput
  }

  export type vehicle_pricesCreateNestedOneWithoutBillsInput = {
    create?: XOR<vehicle_pricesCreateWithoutBillsInput, vehicle_pricesUncheckedCreateWithoutBillsInput>
    connectOrCreate?: vehicle_pricesCreateOrConnectWithoutBillsInput
    connect?: vehicle_pricesWhereUniqueInput
  }

  export type customerCreateNestedOneWithoutVehicle_bookings_billsInput = {
    create?: XOR<customerCreateWithoutVehicle_bookings_billsInput, customerUncheckedCreateWithoutVehicle_bookings_billsInput>
    connectOrCreate?: customerCreateOrConnectWithoutVehicle_bookings_billsInput
    connect?: customerWhereUniqueInput
  }

  export type bills_paymentCreateNestedManyWithoutBillInput = {
    create?: XOR<bills_paymentCreateWithoutBillInput, bills_paymentUncheckedCreateWithoutBillInput> | bills_paymentCreateWithoutBillInput[] | bills_paymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: bills_paymentCreateOrConnectWithoutBillInput | bills_paymentCreateOrConnectWithoutBillInput[]
    createMany?: bills_paymentCreateManyBillInputEnvelope
    connect?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
  }

  export type bills_paymentUncheckedCreateNestedManyWithoutBillInput = {
    create?: XOR<bills_paymentCreateWithoutBillInput, bills_paymentUncheckedCreateWithoutBillInput> | bills_paymentCreateWithoutBillInput[] | bills_paymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: bills_paymentCreateOrConnectWithoutBillInput | bills_paymentCreateOrConnectWithoutBillInput[]
    createMany?: bills_paymentCreateManyBillInputEnvelope
    connect?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
  }

  export type vehicle_bookingsUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<vehicle_bookingsCreateWithoutBillsInput, vehicle_bookingsUncheckedCreateWithoutBillsInput>
    connectOrCreate?: vehicle_bookingsCreateOrConnectWithoutBillsInput
    upsert?: vehicle_bookingsUpsertWithoutBillsInput
    connect?: vehicle_bookingsWhereUniqueInput
    update?: XOR<XOR<vehicle_bookingsUpdateToOneWithWhereWithoutBillsInput, vehicle_bookingsUpdateWithoutBillsInput>, vehicle_bookingsUncheckedUpdateWithoutBillsInput>
  }

  export type vehicle_pricesUpdateOneRequiredWithoutBillsNestedInput = {
    create?: XOR<vehicle_pricesCreateWithoutBillsInput, vehicle_pricesUncheckedCreateWithoutBillsInput>
    connectOrCreate?: vehicle_pricesCreateOrConnectWithoutBillsInput
    upsert?: vehicle_pricesUpsertWithoutBillsInput
    connect?: vehicle_pricesWhereUniqueInput
    update?: XOR<XOR<vehicle_pricesUpdateToOneWithWhereWithoutBillsInput, vehicle_pricesUpdateWithoutBillsInput>, vehicle_pricesUncheckedUpdateWithoutBillsInput>
  }

  export type customerUpdateOneRequiredWithoutVehicle_bookings_billsNestedInput = {
    create?: XOR<customerCreateWithoutVehicle_bookings_billsInput, customerUncheckedCreateWithoutVehicle_bookings_billsInput>
    connectOrCreate?: customerCreateOrConnectWithoutVehicle_bookings_billsInput
    upsert?: customerUpsertWithoutVehicle_bookings_billsInput
    connect?: customerWhereUniqueInput
    update?: XOR<XOR<customerUpdateToOneWithWhereWithoutVehicle_bookings_billsInput, customerUpdateWithoutVehicle_bookings_billsInput>, customerUncheckedUpdateWithoutVehicle_bookings_billsInput>
  }

  export type bills_paymentUpdateManyWithoutBillNestedInput = {
    create?: XOR<bills_paymentCreateWithoutBillInput, bills_paymentUncheckedCreateWithoutBillInput> | bills_paymentCreateWithoutBillInput[] | bills_paymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: bills_paymentCreateOrConnectWithoutBillInput | bills_paymentCreateOrConnectWithoutBillInput[]
    upsert?: bills_paymentUpsertWithWhereUniqueWithoutBillInput | bills_paymentUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: bills_paymentCreateManyBillInputEnvelope
    set?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    disconnect?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    delete?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    connect?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    update?: bills_paymentUpdateWithWhereUniqueWithoutBillInput | bills_paymentUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: bills_paymentUpdateManyWithWhereWithoutBillInput | bills_paymentUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: bills_paymentScalarWhereInput | bills_paymentScalarWhereInput[]
  }

  export type bills_paymentUncheckedUpdateManyWithoutBillNestedInput = {
    create?: XOR<bills_paymentCreateWithoutBillInput, bills_paymentUncheckedCreateWithoutBillInput> | bills_paymentCreateWithoutBillInput[] | bills_paymentUncheckedCreateWithoutBillInput[]
    connectOrCreate?: bills_paymentCreateOrConnectWithoutBillInput | bills_paymentCreateOrConnectWithoutBillInput[]
    upsert?: bills_paymentUpsertWithWhereUniqueWithoutBillInput | bills_paymentUpsertWithWhereUniqueWithoutBillInput[]
    createMany?: bills_paymentCreateManyBillInputEnvelope
    set?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    disconnect?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    delete?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    connect?: bills_paymentWhereUniqueInput | bills_paymentWhereUniqueInput[]
    update?: bills_paymentUpdateWithWhereUniqueWithoutBillInput | bills_paymentUpdateWithWhereUniqueWithoutBillInput[]
    updateMany?: bills_paymentUpdateManyWithWhereWithoutBillInput | bills_paymentUpdateManyWithWhereWithoutBillInput[]
    deleteMany?: bills_paymentScalarWhereInput | bills_paymentScalarWhereInput[]
  }

  export type vehicle_bookings_billsCreateNestedOneWithoutBills_paymentInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutBills_paymentInput, vehicle_bookings_billsUncheckedCreateWithoutBills_paymentInput>
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutBills_paymentInput
    connect?: vehicle_bookings_billsWhereUniqueInput
  }

  export type vehicle_bookings_billsUpdateOneRequiredWithoutBills_paymentNestedInput = {
    create?: XOR<vehicle_bookings_billsCreateWithoutBills_paymentInput, vehicle_bookings_billsUncheckedCreateWithoutBills_paymentInput>
    connectOrCreate?: vehicle_bookings_billsCreateOrConnectWithoutBills_paymentInput
    upsert?: vehicle_bookings_billsUpsertWithoutBills_paymentInput
    connect?: vehicle_bookings_billsWhereUniqueInput
    update?: XOR<XOR<vehicle_bookings_billsUpdateToOneWithWhereWithoutBills_paymentInput, vehicle_bookings_billsUpdateWithoutBills_paymentInput>, vehicle_bookings_billsUncheckedUpdateWithoutBills_paymentInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedEnumroleFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    not?: NestedEnumroleFilter<$PrismaModel> | $Enums.role
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedEnumroleWithAggregatesFilter<$PrismaModel = never> = {
    equals?: $Enums.role | EnumroleFieldRefInput<$PrismaModel>
    in?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    notIn?: $Enums.role[] | ListEnumroleFieldRefInput<$PrismaModel>
    not?: NestedEnumroleWithAggregatesFilter<$PrismaModel> | $Enums.role
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedEnumroleFilter<$PrismaModel>
    _max?: NestedEnumroleFilter<$PrismaModel>
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
    isSet?: boolean
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
    isSet?: boolean
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
    isSet?: boolean
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type modelsCreateWithoutBrandInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: variantsCreateNestedManyWithoutModelInput
    vehicle?: vehicleCreateNestedManyWithoutModelInput
  }

  export type modelsUncheckedCreateWithoutBrandInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: variantsUncheckedCreateNestedManyWithoutModelInput
    vehicle?: vehicleUncheckedCreateNestedManyWithoutModelInput
  }

  export type modelsCreateOrConnectWithoutBrandInput = {
    where: modelsWhereUniqueInput
    create: XOR<modelsCreateWithoutBrandInput, modelsUncheckedCreateWithoutBrandInput>
  }

  export type modelsCreateManyBrandInputEnvelope = {
    data: modelsCreateManyBrandInput | modelsCreateManyBrandInput[]
  }

  export type variantsCreateWithoutBrandInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    model: modelsCreateNestedOneWithoutVariantsInput
    vehicle?: vehicleCreateNestedManyWithoutVariantInput
  }

  export type variantsUncheckedCreateWithoutBrandInput = {
    id?: string
    name: string
    model_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleUncheckedCreateNestedManyWithoutVariantInput
  }

  export type variantsCreateOrConnectWithoutBrandInput = {
    where: variantsWhereUniqueInput
    create: XOR<variantsCreateWithoutBrandInput, variantsUncheckedCreateWithoutBrandInput>
  }

  export type variantsCreateManyBrandInputEnvelope = {
    data: variantsCreateManyBrandInput | variantsCreateManyBrandInput[]
  }

  export type vehicleCreateWithoutBrandInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutBrandInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutBrandInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutBrandInput, vehicleUncheckedCreateWithoutBrandInput>
  }

  export type vehicleCreateManyBrandInputEnvelope = {
    data: vehicleCreateManyBrandInput | vehicleCreateManyBrandInput[]
  }

  export type modelsUpsertWithWhereUniqueWithoutBrandInput = {
    where: modelsWhereUniqueInput
    update: XOR<modelsUpdateWithoutBrandInput, modelsUncheckedUpdateWithoutBrandInput>
    create: XOR<modelsCreateWithoutBrandInput, modelsUncheckedCreateWithoutBrandInput>
  }

  export type modelsUpdateWithWhereUniqueWithoutBrandInput = {
    where: modelsWhereUniqueInput
    data: XOR<modelsUpdateWithoutBrandInput, modelsUncheckedUpdateWithoutBrandInput>
  }

  export type modelsUpdateManyWithWhereWithoutBrandInput = {
    where: modelsScalarWhereInput
    data: XOR<modelsUpdateManyMutationInput, modelsUncheckedUpdateManyWithoutBrandInput>
  }

  export type modelsScalarWhereInput = {
    AND?: modelsScalarWhereInput | modelsScalarWhereInput[]
    OR?: modelsScalarWhereInput[]
    NOT?: modelsScalarWhereInput | modelsScalarWhereInput[]
    id?: StringFilter<"models"> | string
    name?: StringFilter<"models"> | string
    brand_id?: StringFilter<"models"> | string
    createdAt?: DateTimeFilter<"models"> | Date | string
    updatedAt?: DateTimeFilter<"models"> | Date | string
  }

  export type variantsUpsertWithWhereUniqueWithoutBrandInput = {
    where: variantsWhereUniqueInput
    update: XOR<variantsUpdateWithoutBrandInput, variantsUncheckedUpdateWithoutBrandInput>
    create: XOR<variantsCreateWithoutBrandInput, variantsUncheckedCreateWithoutBrandInput>
  }

  export type variantsUpdateWithWhereUniqueWithoutBrandInput = {
    where: variantsWhereUniqueInput
    data: XOR<variantsUpdateWithoutBrandInput, variantsUncheckedUpdateWithoutBrandInput>
  }

  export type variantsUpdateManyWithWhereWithoutBrandInput = {
    where: variantsScalarWhereInput
    data: XOR<variantsUpdateManyMutationInput, variantsUncheckedUpdateManyWithoutBrandInput>
  }

  export type variantsScalarWhereInput = {
    AND?: variantsScalarWhereInput | variantsScalarWhereInput[]
    OR?: variantsScalarWhereInput[]
    NOT?: variantsScalarWhereInput | variantsScalarWhereInput[]
    id?: StringFilter<"variants"> | string
    name?: StringFilter<"variants"> | string
    model_id?: StringFilter<"variants"> | string
    brand_id?: StringNullableFilter<"variants"> | string | null
    createdAt?: DateTimeFilter<"variants"> | Date | string
    updatedAt?: DateTimeFilter<"variants"> | Date | string
  }

  export type vehicleUpsertWithWhereUniqueWithoutBrandInput = {
    where: vehicleWhereUniqueInput
    update: XOR<vehicleUpdateWithoutBrandInput, vehicleUncheckedUpdateWithoutBrandInput>
    create: XOR<vehicleCreateWithoutBrandInput, vehicleUncheckedCreateWithoutBrandInput>
  }

  export type vehicleUpdateWithWhereUniqueWithoutBrandInput = {
    where: vehicleWhereUniqueInput
    data: XOR<vehicleUpdateWithoutBrandInput, vehicleUncheckedUpdateWithoutBrandInput>
  }

  export type vehicleUpdateManyWithWhereWithoutBrandInput = {
    where: vehicleScalarWhereInput
    data: XOR<vehicleUpdateManyMutationInput, vehicleUncheckedUpdateManyWithoutBrandInput>
  }

  export type vehicleScalarWhereInput = {
    AND?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
    OR?: vehicleScalarWhereInput[]
    NOT?: vehicleScalarWhereInput | vehicleScalarWhereInput[]
    id?: StringFilter<"vehicle"> | string
    registration_number?: StringFilter<"vehicle"> | string
    owner_name?: StringFilter<"vehicle"> | string
    insurance_company?: StringFilter<"vehicle"> | string
    insurance_number?: StringFilter<"vehicle"> | string
    chassis_number?: StringFilter<"vehicle"> | string
    rc_image?: StringFilter<"vehicle"> | string
    insurance_image?: StringFilter<"vehicle"> | string
    brand_id?: StringFilter<"vehicle"> | string
    model_id?: StringFilter<"vehicle"> | string
    variant_id?: StringFilter<"vehicle"> | string
    kms_driven?: IntFilter<"vehicle"> | number
    color?: StringFilter<"vehicle"> | string
    mileage?: FloatFilter<"vehicle"> | number
    engine_capacity?: IntFilter<"vehicle"> | number
    createdAt?: DateTimeFilter<"vehicle"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle"> | Date | string
  }

  export type brandsCreateWithoutModelsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: variantsCreateNestedManyWithoutBrandInput
    vehicle?: vehicleCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateWithoutModelsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: variantsUncheckedCreateNestedManyWithoutBrandInput
    vehicle?: vehicleUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsCreateOrConnectWithoutModelsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
  }

  export type variantsCreateWithoutModelInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand?: brandsCreateNestedOneWithoutVariantsInput
    vehicle?: vehicleCreateNestedManyWithoutVariantInput
  }

  export type variantsUncheckedCreateWithoutModelInput = {
    id?: string
    name: string
    brand_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleUncheckedCreateNestedManyWithoutVariantInput
  }

  export type variantsCreateOrConnectWithoutModelInput = {
    where: variantsWhereUniqueInput
    create: XOR<variantsCreateWithoutModelInput, variantsUncheckedCreateWithoutModelInput>
  }

  export type variantsCreateManyModelInputEnvelope = {
    data: variantsCreateManyModelInput | variantsCreateManyModelInput[]
  }

  export type vehicleCreateWithoutModelInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutModelInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutModelInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutModelInput, vehicleUncheckedCreateWithoutModelInput>
  }

  export type vehicleCreateManyModelInputEnvelope = {
    data: vehicleCreateManyModelInput | vehicleCreateManyModelInput[]
  }

  export type brandsUpsertWithoutModelsInput = {
    update: XOR<brandsUpdateWithoutModelsInput, brandsUncheckedUpdateWithoutModelsInput>
    create: XOR<brandsCreateWithoutModelsInput, brandsUncheckedCreateWithoutModelsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutModelsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutModelsInput, brandsUncheckedUpdateWithoutModelsInput>
  }

  export type brandsUpdateWithoutModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUpdateManyWithoutBrandNestedInput
    vehicle?: vehicleUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutModelsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUncheckedUpdateManyWithoutBrandNestedInput
    vehicle?: vehicleUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type variantsUpsertWithWhereUniqueWithoutModelInput = {
    where: variantsWhereUniqueInput
    update: XOR<variantsUpdateWithoutModelInput, variantsUncheckedUpdateWithoutModelInput>
    create: XOR<variantsCreateWithoutModelInput, variantsUncheckedCreateWithoutModelInput>
  }

  export type variantsUpdateWithWhereUniqueWithoutModelInput = {
    where: variantsWhereUniqueInput
    data: XOR<variantsUpdateWithoutModelInput, variantsUncheckedUpdateWithoutModelInput>
  }

  export type variantsUpdateManyWithWhereWithoutModelInput = {
    where: variantsScalarWhereInput
    data: XOR<variantsUpdateManyMutationInput, variantsUncheckedUpdateManyWithoutModelInput>
  }

  export type vehicleUpsertWithWhereUniqueWithoutModelInput = {
    where: vehicleWhereUniqueInput
    update: XOR<vehicleUpdateWithoutModelInput, vehicleUncheckedUpdateWithoutModelInput>
    create: XOR<vehicleCreateWithoutModelInput, vehicleUncheckedCreateWithoutModelInput>
  }

  export type vehicleUpdateWithWhereUniqueWithoutModelInput = {
    where: vehicleWhereUniqueInput
    data: XOR<vehicleUpdateWithoutModelInput, vehicleUncheckedUpdateWithoutModelInput>
  }

  export type vehicleUpdateManyWithWhereWithoutModelInput = {
    where: vehicleScalarWhereInput
    data: XOR<vehicleUpdateManyMutationInput, vehicleUncheckedUpdateManyWithoutModelInput>
  }

  export type modelsCreateWithoutVariantsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutModelsInput
    vehicle?: vehicleCreateNestedManyWithoutModelInput
  }

  export type modelsUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    brand_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleUncheckedCreateNestedManyWithoutModelInput
  }

  export type modelsCreateOrConnectWithoutVariantsInput = {
    where: modelsWhereUniqueInput
    create: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
  }

  export type brandsCreateWithoutVariantsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: modelsCreateNestedManyWithoutBrandInput
    vehicle?: vehicleCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateWithoutVariantsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: modelsUncheckedCreateNestedManyWithoutBrandInput
    vehicle?: vehicleUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsCreateOrConnectWithoutVariantsInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutVariantsInput, brandsUncheckedCreateWithoutVariantsInput>
  }

  export type vehicleCreateWithoutVariantInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutVariantInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutVariantInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutVariantInput, vehicleUncheckedCreateWithoutVariantInput>
  }

  export type vehicleCreateManyVariantInputEnvelope = {
    data: vehicleCreateManyVariantInput | vehicleCreateManyVariantInput[]
  }

  export type modelsUpsertWithoutVariantsInput = {
    update: XOR<modelsUpdateWithoutVariantsInput, modelsUncheckedUpdateWithoutVariantsInput>
    create: XOR<modelsCreateWithoutVariantsInput, modelsUncheckedCreateWithoutVariantsInput>
    where?: modelsWhereInput
  }

  export type modelsUpdateToOneWithWhereWithoutVariantsInput = {
    where?: modelsWhereInput
    data: XOR<modelsUpdateWithoutVariantsInput, modelsUncheckedUpdateWithoutVariantsInput>
  }

  export type modelsUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutModelsNestedInput
    vehicle?: vehicleUpdateManyWithoutModelNestedInput
  }

  export type modelsUncheckedUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUncheckedUpdateManyWithoutModelNestedInput
  }

  export type brandsUpsertWithoutVariantsInput = {
    update: XOR<brandsUpdateWithoutVariantsInput, brandsUncheckedUpdateWithoutVariantsInput>
    create: XOR<brandsCreateWithoutVariantsInput, brandsUncheckedCreateWithoutVariantsInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutVariantsInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutVariantsInput, brandsUncheckedUpdateWithoutVariantsInput>
  }

  export type brandsUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUpdateManyWithoutBrandNestedInput
    vehicle?: vehicleUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutVariantsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUncheckedUpdateManyWithoutBrandNestedInput
    vehicle?: vehicleUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type vehicleUpsertWithWhereUniqueWithoutVariantInput = {
    where: vehicleWhereUniqueInput
    update: XOR<vehicleUpdateWithoutVariantInput, vehicleUncheckedUpdateWithoutVariantInput>
    create: XOR<vehicleCreateWithoutVariantInput, vehicleUncheckedCreateWithoutVariantInput>
  }

  export type vehicleUpdateWithWhereUniqueWithoutVariantInput = {
    where: vehicleWhereUniqueInput
    data: XOR<vehicleUpdateWithoutVariantInput, vehicleUncheckedUpdateWithoutVariantInput>
  }

  export type vehicleUpdateManyWithWhereWithoutVariantInput = {
    where: vehicleScalarWhereInput
    data: XOR<vehicleUpdateManyMutationInput, vehicleUncheckedUpdateManyWithoutVariantInput>
  }

  export type citiesCreateWithoutStateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: customerCreateNestedManyWithoutCityInput
    providers?: providersCreateNestedManyWithoutCityInput
  }

  export type citiesUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: customerUncheckedCreateNestedManyWithoutCityInput
    providers?: providersUncheckedCreateNestedManyWithoutCityInput
  }

  export type citiesCreateOrConnectWithoutStateInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutStateInput, citiesUncheckedCreateWithoutStateInput>
  }

  export type citiesCreateManyStateInputEnvelope = {
    data: citiesCreateManyStateInput | citiesCreateManyStateInput[]
  }

  export type customerCreateWithoutStateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutCustomersInput
    vehicle_bookings?: vehicle_bookingsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutStateInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutStateInput, customerUncheckedCreateWithoutStateInput>
  }

  export type customerCreateManyStateInputEnvelope = {
    data: customerCreateManyStateInput | customerCreateManyStateInput[]
  }

  export type providersCreateWithoutStateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutStateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    cityId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type providersCreateOrConnectWithoutStateInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutStateInput, providersUncheckedCreateWithoutStateInput>
  }

  export type providersCreateManyStateInputEnvelope = {
    data: providersCreateManyStateInput | providersCreateManyStateInput[]
  }

  export type citiesUpsertWithWhereUniqueWithoutStateInput = {
    where: citiesWhereUniqueInput
    update: XOR<citiesUpdateWithoutStateInput, citiesUncheckedUpdateWithoutStateInput>
    create: XOR<citiesCreateWithoutStateInput, citiesUncheckedCreateWithoutStateInput>
  }

  export type citiesUpdateWithWhereUniqueWithoutStateInput = {
    where: citiesWhereUniqueInput
    data: XOR<citiesUpdateWithoutStateInput, citiesUncheckedUpdateWithoutStateInput>
  }

  export type citiesUpdateManyWithWhereWithoutStateInput = {
    where: citiesScalarWhereInput
    data: XOR<citiesUpdateManyMutationInput, citiesUncheckedUpdateManyWithoutStateInput>
  }

  export type citiesScalarWhereInput = {
    AND?: citiesScalarWhereInput | citiesScalarWhereInput[]
    OR?: citiesScalarWhereInput[]
    NOT?: citiesScalarWhereInput | citiesScalarWhereInput[]
    id?: StringFilter<"cities"> | string
    name?: StringFilter<"cities"> | string
    stateId?: StringFilter<"cities"> | string
    createdAt?: DateTimeFilter<"cities"> | Date | string
    updatedAt?: DateTimeFilter<"cities"> | Date | string
  }

  export type customerUpsertWithWhereUniqueWithoutStateInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutStateInput, customerUncheckedUpdateWithoutStateInput>
    create: XOR<customerCreateWithoutStateInput, customerUncheckedCreateWithoutStateInput>
  }

  export type customerUpdateWithWhereUniqueWithoutStateInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutStateInput, customerUncheckedUpdateWithoutStateInput>
  }

  export type customerUpdateManyWithWhereWithoutStateInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutStateInput>
  }

  export type customerScalarWhereInput = {
    AND?: customerScalarWhereInput | customerScalarWhereInput[]
    OR?: customerScalarWhereInput[]
    NOT?: customerScalarWhereInput | customerScalarWhereInput[]
    id?: StringFilter<"customer"> | string
    name?: StringFilter<"customer"> | string
    email_id?: StringFilter<"customer"> | string
    mobile_number?: StringFilter<"customer"> | string
    alternate_mobile_number?: StringNullableFilter<"customer"> | string | null
    address?: StringFilter<"customer"> | string
    city_id?: StringFilter<"customer"> | string
    state_id?: StringFilter<"customer"> | string
    pin_code?: StringFilter<"customer"> | string
    adhaar_number?: StringFilter<"customer"> | string
    adhar_front_image?: StringFilter<"customer"> | string
    adhar_back_image?: StringFilter<"customer"> | string
    driving_license_number?: StringFilter<"customer"> | string
    driving_license_front_image?: StringFilter<"customer"> | string
    driving_license_back_image?: StringFilter<"customer"> | string
    profile_image?: StringNullableFilter<"customer"> | string | null
    is_active?: BoolFilter<"customer"> | boolean
    createdAt?: DateTimeFilter<"customer"> | Date | string
    updatedAt?: DateTimeFilter<"customer"> | Date | string
  }

  export type providersUpsertWithWhereUniqueWithoutStateInput = {
    where: providersWhereUniqueInput
    update: XOR<providersUpdateWithoutStateInput, providersUncheckedUpdateWithoutStateInput>
    create: XOR<providersCreateWithoutStateInput, providersUncheckedCreateWithoutStateInput>
  }

  export type providersUpdateWithWhereUniqueWithoutStateInput = {
    where: providersWhereUniqueInput
    data: XOR<providersUpdateWithoutStateInput, providersUncheckedUpdateWithoutStateInput>
  }

  export type providersUpdateManyWithWhereWithoutStateInput = {
    where: providersScalarWhereInput
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyWithoutStateInput>
  }

  export type providersScalarWhereInput = {
    AND?: providersScalarWhereInput | providersScalarWhereInput[]
    OR?: providersScalarWhereInput[]
    NOT?: providersScalarWhereInput | providersScalarWhereInput[]
    id?: StringFilter<"providers"> | string
    name?: StringFilter<"providers"> | string
    email_id?: StringFilter<"providers"> | string
    mobile_number?: StringFilter<"providers"> | string
    alternate_mobile_number?: StringNullableFilter<"providers"> | string | null
    address?: StringFilter<"providers"> | string
    cityId?: StringFilter<"providers"> | string
    stateId?: StringFilter<"providers"> | string
    pin_code?: StringFilter<"providers"> | string
    adhaar_number?: StringFilter<"providers"> | string
    adhar_front_image?: StringFilter<"providers"> | string
    adhar_back_image?: StringFilter<"providers"> | string
    pan_number?: StringFilter<"providers"> | string
    pan_image?: StringFilter<"providers"> | string
    profile_image?: StringNullableFilter<"providers"> | string | null
    is_approved?: BoolFilter<"providers"> | boolean
    is_active?: BoolFilter<"providers"> | boolean
    rejection_reason?: StringNullableFilter<"providers"> | string | null
    createdAt?: DateTimeFilter<"providers"> | Date | string
    updatedAt?: DateTimeFilter<"providers"> | Date | string
  }

  export type statesCreateWithoutCitiesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: customerCreateNestedManyWithoutStateInput
    providers?: providersCreateNestedManyWithoutStateInput
  }

  export type statesUncheckedCreateWithoutCitiesInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: customerUncheckedCreateNestedManyWithoutStateInput
    providers?: providersUncheckedCreateNestedManyWithoutStateInput
  }

  export type statesCreateOrConnectWithoutCitiesInput = {
    where: statesWhereUniqueInput
    create: XOR<statesCreateWithoutCitiesInput, statesUncheckedCreateWithoutCitiesInput>
  }

  export type customerCreateWithoutCityInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    state: statesCreateNestedOneWithoutCustomersInput
    vehicle_bookings?: vehicle_bookingsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutCityInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutCityInput, customerUncheckedCreateWithoutCityInput>
  }

  export type customerCreateManyCityInputEnvelope = {
    data: customerCreateManyCityInput | customerCreateManyCityInput[]
  }

  export type providersCreateWithoutCityInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    state: statesCreateNestedOneWithoutProvidersInput
  }

  export type providersUncheckedCreateWithoutCityInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    stateId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type providersCreateOrConnectWithoutCityInput = {
    where: providersWhereUniqueInput
    create: XOR<providersCreateWithoutCityInput, providersUncheckedCreateWithoutCityInput>
  }

  export type providersCreateManyCityInputEnvelope = {
    data: providersCreateManyCityInput | providersCreateManyCityInput[]
  }

  export type statesUpsertWithoutCitiesInput = {
    update: XOR<statesUpdateWithoutCitiesInput, statesUncheckedUpdateWithoutCitiesInput>
    create: XOR<statesCreateWithoutCitiesInput, statesUncheckedCreateWithoutCitiesInput>
    where?: statesWhereInput
  }

  export type statesUpdateToOneWithWhereWithoutCitiesInput = {
    where?: statesWhereInput
    data: XOR<statesUpdateWithoutCitiesInput, statesUncheckedUpdateWithoutCitiesInput>
  }

  export type statesUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customerUpdateManyWithoutStateNestedInput
    providers?: providersUpdateManyWithoutStateNestedInput
  }

  export type statesUncheckedUpdateWithoutCitiesInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customerUncheckedUpdateManyWithoutStateNestedInput
    providers?: providersUncheckedUpdateManyWithoutStateNestedInput
  }

  export type customerUpsertWithWhereUniqueWithoutCityInput = {
    where: customerWhereUniqueInput
    update: XOR<customerUpdateWithoutCityInput, customerUncheckedUpdateWithoutCityInput>
    create: XOR<customerCreateWithoutCityInput, customerUncheckedCreateWithoutCityInput>
  }

  export type customerUpdateWithWhereUniqueWithoutCityInput = {
    where: customerWhereUniqueInput
    data: XOR<customerUpdateWithoutCityInput, customerUncheckedUpdateWithoutCityInput>
  }

  export type customerUpdateManyWithWhereWithoutCityInput = {
    where: customerScalarWhereInput
    data: XOR<customerUpdateManyMutationInput, customerUncheckedUpdateManyWithoutCityInput>
  }

  export type providersUpsertWithWhereUniqueWithoutCityInput = {
    where: providersWhereUniqueInput
    update: XOR<providersUpdateWithoutCityInput, providersUncheckedUpdateWithoutCityInput>
    create: XOR<providersCreateWithoutCityInput, providersUncheckedCreateWithoutCityInput>
  }

  export type providersUpdateWithWhereUniqueWithoutCityInput = {
    where: providersWhereUniqueInput
    data: XOR<providersUpdateWithoutCityInput, providersUncheckedUpdateWithoutCityInput>
  }

  export type providersUpdateManyWithWhereWithoutCityInput = {
    where: providersScalarWhereInput
    data: XOR<providersUpdateManyMutationInput, providersUncheckedUpdateManyWithoutCityInput>
  }

  export type checklist_optionsCreateWithoutCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inspectionDetails?: vehicle_inspection_detailsCreateNestedManyWithoutChecklist_optionInput
  }

  export type checklist_optionsUncheckedCreateWithoutCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    inspectionDetails?: vehicle_inspection_detailsUncheckedCreateNestedManyWithoutChecklist_optionInput
  }

  export type checklist_optionsCreateOrConnectWithoutCategoryInput = {
    where: checklist_optionsWhereUniqueInput
    create: XOR<checklist_optionsCreateWithoutCategoryInput, checklist_optionsUncheckedCreateWithoutCategoryInput>
  }

  export type checklist_optionsCreateManyCategoryInputEnvelope = {
    data: checklist_optionsCreateManyCategoryInput | checklist_optionsCreateManyCategoryInput[]
  }

  export type checklist_optionsUpsertWithWhereUniqueWithoutCategoryInput = {
    where: checklist_optionsWhereUniqueInput
    update: XOR<checklist_optionsUpdateWithoutCategoryInput, checklist_optionsUncheckedUpdateWithoutCategoryInput>
    create: XOR<checklist_optionsCreateWithoutCategoryInput, checklist_optionsUncheckedCreateWithoutCategoryInput>
  }

  export type checklist_optionsUpdateWithWhereUniqueWithoutCategoryInput = {
    where: checklist_optionsWhereUniqueInput
    data: XOR<checklist_optionsUpdateWithoutCategoryInput, checklist_optionsUncheckedUpdateWithoutCategoryInput>
  }

  export type checklist_optionsUpdateManyWithWhereWithoutCategoryInput = {
    where: checklist_optionsScalarWhereInput
    data: XOR<checklist_optionsUpdateManyMutationInput, checklist_optionsUncheckedUpdateManyWithoutCategoryInput>
  }

  export type checklist_optionsScalarWhereInput = {
    AND?: checklist_optionsScalarWhereInput | checklist_optionsScalarWhereInput[]
    OR?: checklist_optionsScalarWhereInput[]
    NOT?: checklist_optionsScalarWhereInput | checklist_optionsScalarWhereInput[]
    id?: StringFilter<"checklist_options"> | string
    name?: StringFilter<"checklist_options"> | string
    category_id?: StringFilter<"checklist_options"> | string
    createdAt?: DateTimeFilter<"checklist_options"> | Date | string
    updatedAt?: DateTimeFilter<"checklist_options"> | Date | string
  }

  export type checklist_categoriesCreateWithoutOptionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type checklist_categoriesUncheckedCreateWithoutOptionsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type checklist_categoriesCreateOrConnectWithoutOptionsInput = {
    where: checklist_categoriesWhereUniqueInput
    create: XOR<checklist_categoriesCreateWithoutOptionsInput, checklist_categoriesUncheckedCreateWithoutOptionsInput>
  }

  export type vehicle_inspection_detailsCreateWithoutChecklist_optionInput = {
    id?: string
    rating: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_inspection: vehicle_inspectionCreateNestedOneWithoutDetailsInput
  }

  export type vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput = {
    id?: string
    rating: number
    description: string
    vehicle_inspection_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspection_detailsCreateOrConnectWithoutChecklist_optionInput = {
    where: vehicle_inspection_detailsWhereUniqueInput
    create: XOR<vehicle_inspection_detailsCreateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput>
  }

  export type vehicle_inspection_detailsCreateManyChecklist_optionInputEnvelope = {
    data: vehicle_inspection_detailsCreateManyChecklist_optionInput | vehicle_inspection_detailsCreateManyChecklist_optionInput[]
  }

  export type checklist_categoriesUpsertWithoutOptionsInput = {
    update: XOR<checklist_categoriesUpdateWithoutOptionsInput, checklist_categoriesUncheckedUpdateWithoutOptionsInput>
    create: XOR<checklist_categoriesCreateWithoutOptionsInput, checklist_categoriesUncheckedCreateWithoutOptionsInput>
    where?: checklist_categoriesWhereInput
  }

  export type checklist_categoriesUpdateToOneWithWhereWithoutOptionsInput = {
    where?: checklist_categoriesWhereInput
    data: XOR<checklist_categoriesUpdateWithoutOptionsInput, checklist_categoriesUncheckedUpdateWithoutOptionsInput>
  }

  export type checklist_categoriesUpdateWithoutOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checklist_categoriesUncheckedUpdateWithoutOptionsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsUpsertWithWhereUniqueWithoutChecklist_optionInput = {
    where: vehicle_inspection_detailsWhereUniqueInput
    update: XOR<vehicle_inspection_detailsUpdateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedUpdateWithoutChecklist_optionInput>
    create: XOR<vehicle_inspection_detailsCreateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedCreateWithoutChecklist_optionInput>
  }

  export type vehicle_inspection_detailsUpdateWithWhereUniqueWithoutChecklist_optionInput = {
    where: vehicle_inspection_detailsWhereUniqueInput
    data: XOR<vehicle_inspection_detailsUpdateWithoutChecklist_optionInput, vehicle_inspection_detailsUncheckedUpdateWithoutChecklist_optionInput>
  }

  export type vehicle_inspection_detailsUpdateManyWithWhereWithoutChecklist_optionInput = {
    where: vehicle_inspection_detailsScalarWhereInput
    data: XOR<vehicle_inspection_detailsUpdateManyMutationInput, vehicle_inspection_detailsUncheckedUpdateManyWithoutChecklist_optionInput>
  }

  export type vehicle_inspection_detailsScalarWhereInput = {
    AND?: vehicle_inspection_detailsScalarWhereInput | vehicle_inspection_detailsScalarWhereInput[]
    OR?: vehicle_inspection_detailsScalarWhereInput[]
    NOT?: vehicle_inspection_detailsScalarWhereInput | vehicle_inspection_detailsScalarWhereInput[]
    id?: StringFilter<"vehicle_inspection_details"> | string
    checklist_option_id?: StringFilter<"vehicle_inspection_details"> | string
    rating?: IntFilter<"vehicle_inspection_details"> | number
    description?: StringFilter<"vehicle_inspection_details"> | string
    vehicle_inspection_id?: StringFilter<"vehicle_inspection_details"> | string
    createdAt?: DateTimeFilter<"vehicle_inspection_details"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_inspection_details"> | Date | string
  }

  export type brandsCreateWithoutVehicleInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: modelsCreateNestedManyWithoutBrandInput
    variants?: variantsCreateNestedManyWithoutBrandInput
  }

  export type brandsUncheckedCreateWithoutVehicleInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    models?: modelsUncheckedCreateNestedManyWithoutBrandInput
    variants?: variantsUncheckedCreateNestedManyWithoutBrandInput
  }

  export type brandsCreateOrConnectWithoutVehicleInput = {
    where: brandsWhereUniqueInput
    create: XOR<brandsCreateWithoutVehicleInput, brandsUncheckedCreateWithoutVehicleInput>
  }

  export type modelsCreateWithoutVehicleInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutModelsInput
    variants?: variantsCreateNestedManyWithoutModelInput
  }

  export type modelsUncheckedCreateWithoutVehicleInput = {
    id?: string
    name: string
    brand_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    variants?: variantsUncheckedCreateNestedManyWithoutModelInput
  }

  export type modelsCreateOrConnectWithoutVehicleInput = {
    where: modelsWhereUniqueInput
    create: XOR<modelsCreateWithoutVehicleInput, modelsUncheckedCreateWithoutVehicleInput>
  }

  export type variantsCreateWithoutVehicleInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    model: modelsCreateNestedOneWithoutVariantsInput
    brand?: brandsCreateNestedOneWithoutVariantsInput
  }

  export type variantsUncheckedCreateWithoutVehicleInput = {
    id?: string
    name: string
    model_id: string
    brand_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type variantsCreateOrConnectWithoutVehicleInput = {
    where: variantsWhereUniqueInput
    create: XOR<variantsCreateWithoutVehicleInput, variantsUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_featuresCreateWithoutVehicleInput = {
    id?: string
    feature_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_featuresUncheckedCreateWithoutVehicleInput = {
    id?: string
    feature_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_featuresCreateOrConnectWithoutVehicleInput = {
    where: vehicle_featuresWhereUniqueInput
    create: XOR<vehicle_featuresCreateWithoutVehicleInput, vehicle_featuresUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_featuresCreateManyVehicleInputEnvelope = {
    data: vehicle_featuresCreateManyVehicleInput | vehicle_featuresCreateManyVehicleInput[]
  }

  export type vehicle_imagesCreateWithoutVehicleInput = {
    id?: string
    image_url: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_imagesUncheckedCreateWithoutVehicleInput = {
    id?: string
    image_url: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_imagesCreateOrConnectWithoutVehicleInput = {
    where: vehicle_imagesWhereUniqueInput
    create: XOR<vehicle_imagesCreateWithoutVehicleInput, vehicle_imagesUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_imagesCreateManyVehicleInputEnvelope = {
    data: vehicle_imagesCreateManyVehicleInput | vehicle_imagesCreateManyVehicleInput[]
  }

  export type vehicle_availabilityCreateWithoutVehicleInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availabilityUncheckedCreateWithoutVehicleInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availabilityCreateOrConnectWithoutVehicleInput = {
    where: vehicle_availabilityWhereUniqueInput
    create: XOR<vehicle_availabilityCreateWithoutVehicleInput, vehicle_availabilityUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_availabilityCreateManyVehicleInputEnvelope = {
    data: vehicle_availabilityCreateManyVehicleInput | vehicle_availabilityCreateManyVehicleInput[]
  }

  export type vehicle_availability_historyCreateWithoutVehicleInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availability_historyUncheckedCreateWithoutVehicleInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availability_historyCreateOrConnectWithoutVehicleInput = {
    where: vehicle_availability_historyWhereUniqueInput
    create: XOR<vehicle_availability_historyCreateWithoutVehicleInput, vehicle_availability_historyUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_availability_historyCreateManyVehicleInputEnvelope = {
    data: vehicle_availability_historyCreateManyVehicleInput | vehicle_availability_historyCreateManyVehicleInput[]
  }

  export type vehicle_inspectionCreateWithoutVehicleInput = {
    id?: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: vehicle_inspection_detailsCreateNestedManyWithoutVehicle_inspectionInput
    vehicle_bookings?: vehicle_bookingsCreateNestedOneWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionUncheckedCreateWithoutVehicleInput = {
    id?: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookingsId?: string | null
    details?: vehicle_inspection_detailsUncheckedCreateNestedManyWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionCreateOrConnectWithoutVehicleInput = {
    where: vehicle_inspectionWhereUniqueInput
    create: XOR<vehicle_inspectionCreateWithoutVehicleInput, vehicle_inspectionUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_inspectionCreateManyVehicleInputEnvelope = {
    data: vehicle_inspectionCreateManyVehicleInput | vehicle_inspectionCreateManyVehicleInput[]
  }

  export type vehicle_pricesCreateWithoutVehicleInput = {
    id?: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_priceInput
  }

  export type vehicle_pricesUncheckedCreateWithoutVehicleInput = {
    id?: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_priceInput
  }

  export type vehicle_pricesCreateOrConnectWithoutVehicleInput = {
    where: vehicle_pricesWhereUniqueInput
    create: XOR<vehicle_pricesCreateWithoutVehicleInput, vehicle_pricesUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_pricesCreateManyVehicleInputEnvelope = {
    data: vehicle_pricesCreateManyVehicleInput | vehicle_pricesCreateManyVehicleInput[]
  }

  export type vehicle_bookingsCreateWithoutVehicleInput = {
    id?: string
    booking_number: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    customer: customerCreateNestedOneWithoutVehicle_bookingsInput
    vehicle_inspection?: vehicle_inspectionCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUncheckedCreateWithoutVehicleInput = {
    id?: string
    booking_number: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsCreateOrConnectWithoutVehicleInput = {
    where: vehicle_bookingsWhereUniqueInput
    create: XOR<vehicle_bookingsCreateWithoutVehicleInput, vehicle_bookingsUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_bookingsCreateManyVehicleInputEnvelope = {
    data: vehicle_bookingsCreateManyVehicleInput | vehicle_bookingsCreateManyVehicleInput[]
  }

  export type vehicle_bookings_logsCreateWithoutVehicleInput = {
    id?: string
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_booking?: vehicle_bookingsCreateNestedOneWithoutBooking_logsInput
    customer?: customerCreateNestedOneWithoutVehicle_bookings_logsInput
  }

  export type vehicle_bookings_logsUncheckedCreateWithoutVehicleInput = {
    id?: string
    vehicle_booking_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    customer_id?: string | null
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsCreateOrConnectWithoutVehicleInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    create: XOR<vehicle_bookings_logsCreateWithoutVehicleInput, vehicle_bookings_logsUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_bookings_logsCreateManyVehicleInputEnvelope = {
    data: vehicle_bookings_logsCreateManyVehicleInput | vehicle_bookings_logsCreateManyVehicleInput[]
  }

  export type brandsUpsertWithoutVehicleInput = {
    update: XOR<brandsUpdateWithoutVehicleInput, brandsUncheckedUpdateWithoutVehicleInput>
    create: XOR<brandsCreateWithoutVehicleInput, brandsUncheckedCreateWithoutVehicleInput>
    where?: brandsWhereInput
  }

  export type brandsUpdateToOneWithWhereWithoutVehicleInput = {
    where?: brandsWhereInput
    data: XOR<brandsUpdateWithoutVehicleInput, brandsUncheckedUpdateWithoutVehicleInput>
  }

  export type brandsUpdateWithoutVehicleInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUpdateManyWithoutBrandNestedInput
    variants?: variantsUpdateManyWithoutBrandNestedInput
  }

  export type brandsUncheckedUpdateWithoutVehicleInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    models?: modelsUncheckedUpdateManyWithoutBrandNestedInput
    variants?: variantsUncheckedUpdateManyWithoutBrandNestedInput
  }

  export type modelsUpsertWithoutVehicleInput = {
    update: XOR<modelsUpdateWithoutVehicleInput, modelsUncheckedUpdateWithoutVehicleInput>
    create: XOR<modelsCreateWithoutVehicleInput, modelsUncheckedCreateWithoutVehicleInput>
    where?: modelsWhereInput
  }

  export type modelsUpdateToOneWithWhereWithoutVehicleInput = {
    where?: modelsWhereInput
    data: XOR<modelsUpdateWithoutVehicleInput, modelsUncheckedUpdateWithoutVehicleInput>
  }

  export type modelsUpdateWithoutVehicleInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutModelsNestedInput
    variants?: variantsUpdateManyWithoutModelNestedInput
  }

  export type modelsUncheckedUpdateWithoutVehicleInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUncheckedUpdateManyWithoutModelNestedInput
  }

  export type variantsUpsertWithoutVehicleInput = {
    update: XOR<variantsUpdateWithoutVehicleInput, variantsUncheckedUpdateWithoutVehicleInput>
    create: XOR<variantsCreateWithoutVehicleInput, variantsUncheckedCreateWithoutVehicleInput>
    where?: variantsWhereInput
  }

  export type variantsUpdateToOneWithWhereWithoutVehicleInput = {
    where?: variantsWhereInput
    data: XOR<variantsUpdateWithoutVehicleInput, variantsUncheckedUpdateWithoutVehicleInput>
  }

  export type variantsUpdateWithoutVehicleInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: modelsUpdateOneRequiredWithoutVariantsNestedInput
    brand?: brandsUpdateOneWithoutVariantsNestedInput
  }

  export type variantsUncheckedUpdateWithoutVehicleInput = {
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_featuresWhereUniqueInput
    update: XOR<vehicle_featuresUpdateWithoutVehicleInput, vehicle_featuresUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_featuresCreateWithoutVehicleInput, vehicle_featuresUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_featuresUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_featuresWhereUniqueInput
    data: XOR<vehicle_featuresUpdateWithoutVehicleInput, vehicle_featuresUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_featuresUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_featuresScalarWhereInput
    data: XOR<vehicle_featuresUpdateManyMutationInput, vehicle_featuresUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_featuresScalarWhereInput = {
    AND?: vehicle_featuresScalarWhereInput | vehicle_featuresScalarWhereInput[]
    OR?: vehicle_featuresScalarWhereInput[]
    NOT?: vehicle_featuresScalarWhereInput | vehicle_featuresScalarWhereInput[]
    id?: StringFilter<"vehicle_features"> | string
    vehicle_id?: StringFilter<"vehicle_features"> | string
    feature_name?: StringFilter<"vehicle_features"> | string
    createdAt?: DateTimeFilter<"vehicle_features"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_features"> | Date | string
  }

  export type vehicle_imagesUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_imagesWhereUniqueInput
    update: XOR<vehicle_imagesUpdateWithoutVehicleInput, vehicle_imagesUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_imagesCreateWithoutVehicleInput, vehicle_imagesUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_imagesUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_imagesWhereUniqueInput
    data: XOR<vehicle_imagesUpdateWithoutVehicleInput, vehicle_imagesUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_imagesUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_imagesScalarWhereInput
    data: XOR<vehicle_imagesUpdateManyMutationInput, vehicle_imagesUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_imagesScalarWhereInput = {
    AND?: vehicle_imagesScalarWhereInput | vehicle_imagesScalarWhereInput[]
    OR?: vehicle_imagesScalarWhereInput[]
    NOT?: vehicle_imagesScalarWhereInput | vehicle_imagesScalarWhereInput[]
    id?: StringFilter<"vehicle_images"> | string
    vehicle_id?: StringFilter<"vehicle_images"> | string
    image_url?: StringFilter<"vehicle_images"> | string
    description?: StringFilter<"vehicle_images"> | string
    createdAt?: DateTimeFilter<"vehicle_images"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_images"> | Date | string
  }

  export type vehicle_availabilityUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_availabilityWhereUniqueInput
    update: XOR<vehicle_availabilityUpdateWithoutVehicleInput, vehicle_availabilityUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_availabilityCreateWithoutVehicleInput, vehicle_availabilityUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_availabilityUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_availabilityWhereUniqueInput
    data: XOR<vehicle_availabilityUpdateWithoutVehicleInput, vehicle_availabilityUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_availabilityUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_availabilityScalarWhereInput
    data: XOR<vehicle_availabilityUpdateManyMutationInput, vehicle_availabilityUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_availabilityScalarWhereInput = {
    AND?: vehicle_availabilityScalarWhereInput | vehicle_availabilityScalarWhereInput[]
    OR?: vehicle_availabilityScalarWhereInput[]
    NOT?: vehicle_availabilityScalarWhereInput | vehicle_availabilityScalarWhereInput[]
    id?: StringFilter<"vehicle_availability"> | string
    vehicle_id?: StringFilter<"vehicle_availability"> | string
    start_time?: DateTimeFilter<"vehicle_availability"> | Date | string
    end_time?: DateTimeFilter<"vehicle_availability"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_availability"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_availability"> | Date | string
  }

  export type vehicle_availability_historyUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_availability_historyWhereUniqueInput
    update: XOR<vehicle_availability_historyUpdateWithoutVehicleInput, vehicle_availability_historyUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_availability_historyCreateWithoutVehicleInput, vehicle_availability_historyUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_availability_historyUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_availability_historyWhereUniqueInput
    data: XOR<vehicle_availability_historyUpdateWithoutVehicleInput, vehicle_availability_historyUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_availability_historyUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_availability_historyScalarWhereInput
    data: XOR<vehicle_availability_historyUpdateManyMutationInput, vehicle_availability_historyUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_availability_historyScalarWhereInput = {
    AND?: vehicle_availability_historyScalarWhereInput | vehicle_availability_historyScalarWhereInput[]
    OR?: vehicle_availability_historyScalarWhereInput[]
    NOT?: vehicle_availability_historyScalarWhereInput | vehicle_availability_historyScalarWhereInput[]
    id?: StringFilter<"vehicle_availability_history"> | string
    vehicle_id?: StringFilter<"vehicle_availability_history"> | string
    start_time?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    end_time?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_availability_history"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_availability_history"> | Date | string
  }

  export type vehicle_inspectionUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_inspectionWhereUniqueInput
    update: XOR<vehicle_inspectionUpdateWithoutVehicleInput, vehicle_inspectionUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_inspectionCreateWithoutVehicleInput, vehicle_inspectionUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_inspectionUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_inspectionWhereUniqueInput
    data: XOR<vehicle_inspectionUpdateWithoutVehicleInput, vehicle_inspectionUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_inspectionUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_inspectionScalarWhereInput
    data: XOR<vehicle_inspectionUpdateManyMutationInput, vehicle_inspectionUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_inspectionScalarWhereInput = {
    AND?: vehicle_inspectionScalarWhereInput | vehicle_inspectionScalarWhereInput[]
    OR?: vehicle_inspectionScalarWhereInput[]
    NOT?: vehicle_inspectionScalarWhereInput | vehicle_inspectionScalarWhereInput[]
    id?: StringFilter<"vehicle_inspection"> | string
    vehicle_id?: StringFilter<"vehicle_inspection"> | string
    inspection_date?: DateTimeFilter<"vehicle_inspection"> | Date | string
    inspector_name?: StringFilter<"vehicle_inspection"> | string
    createdAt?: DateTimeFilter<"vehicle_inspection"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_inspection"> | Date | string
    vehicle_bookingsId?: StringNullableFilter<"vehicle_inspection"> | string | null
  }

  export type vehicle_pricesUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_pricesWhereUniqueInput
    update: XOR<vehicle_pricesUpdateWithoutVehicleInput, vehicle_pricesUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_pricesCreateWithoutVehicleInput, vehicle_pricesUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_pricesUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_pricesWhereUniqueInput
    data: XOR<vehicle_pricesUpdateWithoutVehicleInput, vehicle_pricesUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_pricesUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_pricesScalarWhereInput
    data: XOR<vehicle_pricesUpdateManyMutationInput, vehicle_pricesUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_pricesScalarWhereInput = {
    AND?: vehicle_pricesScalarWhereInput | vehicle_pricesScalarWhereInput[]
    OR?: vehicle_pricesScalarWhereInput[]
    NOT?: vehicle_pricesScalarWhereInput | vehicle_pricesScalarWhereInput[]
    id?: StringFilter<"vehicle_prices"> | string
    vehicle_id?: StringFilter<"vehicle_prices"> | string
    base_price_per_day?: FloatFilter<"vehicle_prices"> | number
    hr_included?: IntFilter<"vehicle_prices"> | number
    km_included?: IntFilter<"vehicle_prices"> | number
    extra_km_charge?: FloatFilter<"vehicle_prices"> | number
    extra_hr_charge?: FloatFilter<"vehicle_prices"> | number
    is_unlimited_allowed?: BoolFilter<"vehicle_prices"> | boolean
    createdAt?: DateTimeFilter<"vehicle_prices"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_prices"> | Date | string
  }

  export type vehicle_bookingsUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_bookingsWhereUniqueInput
    update: XOR<vehicle_bookingsUpdateWithoutVehicleInput, vehicle_bookingsUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_bookingsCreateWithoutVehicleInput, vehicle_bookingsUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_bookingsUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_bookingsWhereUniqueInput
    data: XOR<vehicle_bookingsUpdateWithoutVehicleInput, vehicle_bookingsUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_bookingsUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_bookingsScalarWhereInput
    data: XOR<vehicle_bookingsUpdateManyMutationInput, vehicle_bookingsUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_bookingsScalarWhereInput = {
    AND?: vehicle_bookingsScalarWhereInput | vehicle_bookingsScalarWhereInput[]
    OR?: vehicle_bookingsScalarWhereInput[]
    NOT?: vehicle_bookingsScalarWhereInput | vehicle_bookingsScalarWhereInput[]
    id?: StringFilter<"vehicle_bookings"> | string
    booking_number?: StringFilter<"vehicle_bookings"> | string
    vehicle_id?: StringFilter<"vehicle_bookings"> | string
    customer_id?: StringFilter<"vehicle_bookings"> | string
    start_time?: DateTimeFilter<"vehicle_bookings"> | Date | string
    end_time?: DateTimeFilter<"vehicle_bookings"> | Date | string
    booking_status_id?: StringNullableFilter<"vehicle_bookings"> | string | null
    createdAt?: DateTimeFilter<"vehicle_bookings"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings"> | Date | string
  }

  export type vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    update: XOR<vehicle_bookings_logsUpdateWithoutVehicleInput, vehicle_bookings_logsUncheckedUpdateWithoutVehicleInput>
    create: XOR<vehicle_bookings_logsCreateWithoutVehicleInput, vehicle_bookings_logsUncheckedCreateWithoutVehicleInput>
  }

  export type vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicleInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    data: XOR<vehicle_bookings_logsUpdateWithoutVehicleInput, vehicle_bookings_logsUncheckedUpdateWithoutVehicleInput>
  }

  export type vehicle_bookings_logsUpdateManyWithWhereWithoutVehicleInput = {
    where: vehicle_bookings_logsScalarWhereInput
    data: XOR<vehicle_bookings_logsUpdateManyMutationInput, vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleInput>
  }

  export type vehicle_bookings_logsScalarWhereInput = {
    AND?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
    OR?: vehicle_bookings_logsScalarWhereInput[]
    NOT?: vehicle_bookings_logsScalarWhereInput | vehicle_bookings_logsScalarWhereInput[]
    id?: StringFilter<"vehicle_bookings_logs"> | string
    vehicle_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    vehicle_booking_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    booking_number?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    start_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    end_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    customer_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    booking_status_id?: StringNullableFilter<"vehicle_bookings_logs"> | string | null
    logged_time?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    createdAt?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings_logs"> | Date | string
  }

  export type vehicleCreateWithoutFeaturesInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutFeaturesInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutFeaturesInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutFeaturesInput, vehicleUncheckedCreateWithoutFeaturesInput>
  }

  export type vehicleUpsertWithoutFeaturesInput = {
    update: XOR<vehicleUpdateWithoutFeaturesInput, vehicleUncheckedUpdateWithoutFeaturesInput>
    create: XOR<vehicleCreateWithoutFeaturesInput, vehicleUncheckedCreateWithoutFeaturesInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutFeaturesInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutFeaturesInput, vehicleUncheckedUpdateWithoutFeaturesInput>
  }

  export type vehicleUpdateWithoutFeaturesInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutFeaturesInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleCreateWithoutImagesInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutImagesInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutImagesInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutImagesInput, vehicleUncheckedCreateWithoutImagesInput>
  }

  export type vehicleUpsertWithoutImagesInput = {
    update: XOR<vehicleUpdateWithoutImagesInput, vehicleUncheckedUpdateWithoutImagesInput>
    create: XOR<vehicleCreateWithoutImagesInput, vehicleUncheckedCreateWithoutImagesInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutImagesInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutImagesInput, vehicleUncheckedUpdateWithoutImagesInput>
  }

  export type vehicleUpdateWithoutImagesInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutImagesInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleCreateWithoutAvailabilityInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutAvailabilityInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutAvailabilityInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutAvailabilityInput, vehicleUncheckedCreateWithoutAvailabilityInput>
  }

  export type vehicleUpsertWithoutAvailabilityInput = {
    update: XOR<vehicleUpdateWithoutAvailabilityInput, vehicleUncheckedUpdateWithoutAvailabilityInput>
    create: XOR<vehicleCreateWithoutAvailabilityInput, vehicleUncheckedCreateWithoutAvailabilityInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutAvailabilityInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutAvailabilityInput, vehicleUncheckedUpdateWithoutAvailabilityInput>
  }

  export type vehicleUpdateWithoutAvailabilityInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutAvailabilityInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleCreateWithoutAvailability_historyInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutAvailability_historyInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutAvailability_historyInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutAvailability_historyInput, vehicleUncheckedCreateWithoutAvailability_historyInput>
  }

  export type vehicleUpsertWithoutAvailability_historyInput = {
    update: XOR<vehicleUpdateWithoutAvailability_historyInput, vehicleUncheckedUpdateWithoutAvailability_historyInput>
    create: XOR<vehicleCreateWithoutAvailability_historyInput, vehicleUncheckedCreateWithoutAvailability_historyInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutAvailability_historyInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutAvailability_historyInput, vehicleUncheckedUpdateWithoutAvailability_historyInput>
  }

  export type vehicleUpdateWithoutAvailability_historyInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutAvailability_historyInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleCreateWithoutInspectionsInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutInspectionsInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutInspectionsInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutInspectionsInput, vehicleUncheckedCreateWithoutInspectionsInput>
  }

  export type vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput = {
    id?: string
    rating: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
    checklist_option: checklist_optionsCreateNestedOneWithoutInspectionDetailsInput
  }

  export type vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput = {
    id?: string
    checklist_option_id: string
    rating: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspection_detailsCreateOrConnectWithoutVehicle_inspectionInput = {
    where: vehicle_inspection_detailsWhereUniqueInput
    create: XOR<vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput>
  }

  export type vehicle_inspection_detailsCreateManyVehicle_inspectionInputEnvelope = {
    data: vehicle_inspection_detailsCreateManyVehicle_inspectionInput | vehicle_inspection_detailsCreateManyVehicle_inspectionInput[]
  }

  export type vehicle_bookingsCreateWithoutVehicle_inspectionInput = {
    id?: string
    booking_number: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutBookingsInput
    customer: customerCreateNestedOneWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUncheckedCreateWithoutVehicle_inspectionInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsCreateOrConnectWithoutVehicle_inspectionInput = {
    where: vehicle_bookingsWhereUniqueInput
    create: XOR<vehicle_bookingsCreateWithoutVehicle_inspectionInput, vehicle_bookingsUncheckedCreateWithoutVehicle_inspectionInput>
  }

  export type vehicleUpsertWithoutInspectionsInput = {
    update: XOR<vehicleUpdateWithoutInspectionsInput, vehicleUncheckedUpdateWithoutInspectionsInput>
    create: XOR<vehicleCreateWithoutInspectionsInput, vehicleUncheckedCreateWithoutInspectionsInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutInspectionsInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutInspectionsInput, vehicleUncheckedUpdateWithoutInspectionsInput>
  }

  export type vehicleUpdateWithoutInspectionsInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutInspectionsInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicle_inspection_detailsUpsertWithWhereUniqueWithoutVehicle_inspectionInput = {
    where: vehicle_inspection_detailsWhereUniqueInput
    update: XOR<vehicle_inspection_detailsUpdateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedUpdateWithoutVehicle_inspectionInput>
    create: XOR<vehicle_inspection_detailsCreateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedCreateWithoutVehicle_inspectionInput>
  }

  export type vehicle_inspection_detailsUpdateWithWhereUniqueWithoutVehicle_inspectionInput = {
    where: vehicle_inspection_detailsWhereUniqueInput
    data: XOR<vehicle_inspection_detailsUpdateWithoutVehicle_inspectionInput, vehicle_inspection_detailsUncheckedUpdateWithoutVehicle_inspectionInput>
  }

  export type vehicle_inspection_detailsUpdateManyWithWhereWithoutVehicle_inspectionInput = {
    where: vehicle_inspection_detailsScalarWhereInput
    data: XOR<vehicle_inspection_detailsUpdateManyMutationInput, vehicle_inspection_detailsUncheckedUpdateManyWithoutVehicle_inspectionInput>
  }

  export type vehicle_bookingsUpsertWithoutVehicle_inspectionInput = {
    update: XOR<vehicle_bookingsUpdateWithoutVehicle_inspectionInput, vehicle_bookingsUncheckedUpdateWithoutVehicle_inspectionInput>
    create: XOR<vehicle_bookingsCreateWithoutVehicle_inspectionInput, vehicle_bookingsUncheckedCreateWithoutVehicle_inspectionInput>
    where?: vehicle_bookingsWhereInput
  }

  export type vehicle_bookingsUpdateToOneWithWhereWithoutVehicle_inspectionInput = {
    where?: vehicle_bookingsWhereInput
    data: XOR<vehicle_bookingsUpdateWithoutVehicle_inspectionInput, vehicle_bookingsUncheckedUpdateWithoutVehicle_inspectionInput>
  }

  export type vehicle_bookingsUpdateWithoutVehicle_inspectionInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutBookingsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateWithoutVehicle_inspectionInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type checklist_optionsCreateWithoutInspectionDetailsInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    category: checklist_categoriesCreateNestedOneWithoutOptionsInput
  }

  export type checklist_optionsUncheckedCreateWithoutInspectionDetailsInput = {
    id?: string
    name: string
    category_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type checklist_optionsCreateOrConnectWithoutInspectionDetailsInput = {
    where: checklist_optionsWhereUniqueInput
    create: XOR<checklist_optionsCreateWithoutInspectionDetailsInput, checklist_optionsUncheckedCreateWithoutInspectionDetailsInput>
  }

  export type vehicle_inspectionCreateWithoutDetailsInput = {
    id?: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutInspectionsInput
    vehicle_bookings?: vehicle_bookingsCreateNestedOneWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionUncheckedCreateWithoutDetailsInput = {
    id?: string
    vehicle_id: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookingsId?: string | null
  }

  export type vehicle_inspectionCreateOrConnectWithoutDetailsInput = {
    where: vehicle_inspectionWhereUniqueInput
    create: XOR<vehicle_inspectionCreateWithoutDetailsInput, vehicle_inspectionUncheckedCreateWithoutDetailsInput>
  }

  export type checklist_optionsUpsertWithoutInspectionDetailsInput = {
    update: XOR<checklist_optionsUpdateWithoutInspectionDetailsInput, checklist_optionsUncheckedUpdateWithoutInspectionDetailsInput>
    create: XOR<checklist_optionsCreateWithoutInspectionDetailsInput, checklist_optionsUncheckedCreateWithoutInspectionDetailsInput>
    where?: checklist_optionsWhereInput
  }

  export type checklist_optionsUpdateToOneWithWhereWithoutInspectionDetailsInput = {
    where?: checklist_optionsWhereInput
    data: XOR<checklist_optionsUpdateWithoutInspectionDetailsInput, checklist_optionsUncheckedUpdateWithoutInspectionDetailsInput>
  }

  export type checklist_optionsUpdateWithoutInspectionDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    category?: checklist_categoriesUpdateOneRequiredWithoutOptionsNestedInput
  }

  export type checklist_optionsUncheckedUpdateWithoutInspectionDetailsInput = {
    name?: StringFieldUpdateOperationsInput | string
    category_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspectionUpsertWithoutDetailsInput = {
    update: XOR<vehicle_inspectionUpdateWithoutDetailsInput, vehicle_inspectionUncheckedUpdateWithoutDetailsInput>
    create: XOR<vehicle_inspectionCreateWithoutDetailsInput, vehicle_inspectionUncheckedCreateWithoutDetailsInput>
    where?: vehicle_inspectionWhereInput
  }

  export type vehicle_inspectionUpdateToOneWithWhereWithoutDetailsInput = {
    where?: vehicle_inspectionWhereInput
    data: XOR<vehicle_inspectionUpdateWithoutDetailsInput, vehicle_inspectionUncheckedUpdateWithoutDetailsInput>
  }

  export type vehicle_inspectionUpdateWithoutDetailsInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutInspectionsNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateOneWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionUncheckedUpdateWithoutDetailsInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookingsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicleCreateWithoutPricesInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutPricesInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutPricesInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutPricesInput, vehicleUncheckedCreateWithoutPricesInput>
  }

  export type vehicle_bookings_billsCreateWithoutVehicle_priceInput = {
    id?: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_booking: vehicle_bookingsCreateNestedOneWithoutBillsInput
    customer: customerCreateNestedOneWithoutVehicle_bookings_billsInput
    bills_payment?: bills_paymentCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills_payment?: bills_paymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsCreateOrConnectWithoutVehicle_priceInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    create: XOR<vehicle_bookings_billsCreateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput>
  }

  export type vehicle_bookings_billsCreateManyVehicle_priceInputEnvelope = {
    data: vehicle_bookings_billsCreateManyVehicle_priceInput | vehicle_bookings_billsCreateManyVehicle_priceInput[]
  }

  export type vehicleUpsertWithoutPricesInput = {
    update: XOR<vehicleUpdateWithoutPricesInput, vehicleUncheckedUpdateWithoutPricesInput>
    create: XOR<vehicleCreateWithoutPricesInput, vehicleUncheckedCreateWithoutPricesInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutPricesInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutPricesInput, vehicleUncheckedUpdateWithoutPricesInput>
  }

  export type vehicleUpdateWithoutPricesInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutPricesInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_priceInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    update: XOR<vehicle_bookings_billsUpdateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedUpdateWithoutVehicle_priceInput>
    create: XOR<vehicle_bookings_billsCreateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_priceInput>
  }

  export type vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_priceInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    data: XOR<vehicle_bookings_billsUpdateWithoutVehicle_priceInput, vehicle_bookings_billsUncheckedUpdateWithoutVehicle_priceInput>
  }

  export type vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_priceInput = {
    where: vehicle_bookings_billsScalarWhereInput
    data: XOR<vehicle_bookings_billsUpdateManyMutationInput, vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_priceInput>
  }

  export type vehicle_bookings_billsScalarWhereInput = {
    AND?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
    OR?: vehicle_bookings_billsScalarWhereInput[]
    NOT?: vehicle_bookings_billsScalarWhereInput | vehicle_bookings_billsScalarWhereInput[]
    id?: StringFilter<"vehicle_bookings_bills"> | string
    vehicle_booking_id?: StringFilter<"vehicle_bookings_bills"> | string
    base_price?: FloatFilter<"vehicle_bookings_bills"> | number
    vehicle_price_id?: StringFilter<"vehicle_bookings_bills"> | string
    total_price?: FloatFilter<"vehicle_bookings_bills"> | number
    extra_km_charge?: FloatFilter<"vehicle_bookings_bills"> | number
    extra_hr_charge?: FloatFilter<"vehicle_bookings_bills"> | number
    customer_id?: StringFilter<"vehicle_bookings_bills"> | string
    createdAt?: DateTimeFilter<"vehicle_bookings_bills"> | Date | string
    updatedAt?: DateTimeFilter<"vehicle_bookings_bills"> | Date | string
  }

  export type citiesCreateWithoutCustomersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    state: statesCreateNestedOneWithoutCitiesInput
    providers?: providersCreateNestedManyWithoutCityInput
  }

  export type citiesUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    providers?: providersUncheckedCreateNestedManyWithoutCityInput
  }

  export type citiesCreateOrConnectWithoutCustomersInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutCustomersInput, citiesUncheckedCreateWithoutCustomersInput>
  }

  export type statesCreateWithoutCustomersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: citiesCreateNestedManyWithoutStateInput
    providers?: providersCreateNestedManyWithoutStateInput
  }

  export type statesUncheckedCreateWithoutCustomersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: citiesUncheckedCreateNestedManyWithoutStateInput
    providers?: providersUncheckedCreateNestedManyWithoutStateInput
  }

  export type statesCreateOrConnectWithoutCustomersInput = {
    where: statesWhereUniqueInput
    create: XOR<statesCreateWithoutCustomersInput, statesUncheckedCreateWithoutCustomersInput>
  }

  export type vehicle_bookingsCreateWithoutCustomerInput = {
    id?: string
    booking_number: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutBookingsInput
    vehicle_inspection?: vehicle_inspectionCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUncheckedCreateWithoutCustomerInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicle_bookingInput
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsCreateOrConnectWithoutCustomerInput = {
    where: vehicle_bookingsWhereUniqueInput
    create: XOR<vehicle_bookingsCreateWithoutCustomerInput, vehicle_bookingsUncheckedCreateWithoutCustomerInput>
  }

  export type vehicle_bookingsCreateManyCustomerInputEnvelope = {
    data: vehicle_bookingsCreateManyCustomerInput | vehicle_bookingsCreateManyCustomerInput[]
  }

  export type vehicle_bookings_logsCreateWithoutCustomerInput = {
    id?: string
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleCreateNestedOneWithoutBooking_logsInput
    vehicle_booking?: vehicle_bookingsCreateNestedOneWithoutBooking_logsInput
  }

  export type vehicle_bookings_logsUncheckedCreateWithoutCustomerInput = {
    id?: string
    vehicle_id?: string | null
    vehicle_booking_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsCreateOrConnectWithoutCustomerInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    create: XOR<vehicle_bookings_logsCreateWithoutCustomerInput, vehicle_bookings_logsUncheckedCreateWithoutCustomerInput>
  }

  export type vehicle_bookings_logsCreateManyCustomerInputEnvelope = {
    data: vehicle_bookings_logsCreateManyCustomerInput | vehicle_bookings_logsCreateManyCustomerInput[]
  }

  export type vehicle_bookings_billsCreateWithoutCustomerInput = {
    id?: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_booking: vehicle_bookingsCreateNestedOneWithoutBillsInput
    vehicle_price: vehicle_pricesCreateNestedOneWithoutBillsInput
    bills_payment?: bills_paymentCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsUncheckedCreateWithoutCustomerInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
    bills_payment?: bills_paymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsCreateOrConnectWithoutCustomerInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    create: XOR<vehicle_bookings_billsCreateWithoutCustomerInput, vehicle_bookings_billsUncheckedCreateWithoutCustomerInput>
  }

  export type vehicle_bookings_billsCreateManyCustomerInputEnvelope = {
    data: vehicle_bookings_billsCreateManyCustomerInput | vehicle_bookings_billsCreateManyCustomerInput[]
  }

  export type citiesUpsertWithoutCustomersInput = {
    update: XOR<citiesUpdateWithoutCustomersInput, citiesUncheckedUpdateWithoutCustomersInput>
    create: XOR<citiesCreateWithoutCustomersInput, citiesUncheckedCreateWithoutCustomersInput>
    where?: citiesWhereInput
  }

  export type citiesUpdateToOneWithWhereWithoutCustomersInput = {
    where?: citiesWhereInput
    data: XOR<citiesUpdateWithoutCustomersInput, citiesUncheckedUpdateWithoutCustomersInput>
  }

  export type citiesUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: statesUpdateOneRequiredWithoutCitiesNestedInput
    providers?: providersUpdateManyWithoutCityNestedInput
  }

  export type citiesUncheckedUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    providers?: providersUncheckedUpdateManyWithoutCityNestedInput
  }

  export type statesUpsertWithoutCustomersInput = {
    update: XOR<statesUpdateWithoutCustomersInput, statesUncheckedUpdateWithoutCustomersInput>
    create: XOR<statesCreateWithoutCustomersInput, statesUncheckedCreateWithoutCustomersInput>
    where?: statesWhereInput
  }

  export type statesUpdateToOneWithWhereWithoutCustomersInput = {
    where?: statesWhereInput
    data: XOR<statesUpdateWithoutCustomersInput, statesUncheckedUpdateWithoutCustomersInput>
  }

  export type statesUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUpdateManyWithoutStateNestedInput
    providers?: providersUpdateManyWithoutStateNestedInput
  }

  export type statesUncheckedUpdateWithoutCustomersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUncheckedUpdateManyWithoutStateNestedInput
    providers?: providersUncheckedUpdateManyWithoutStateNestedInput
  }

  export type vehicle_bookingsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: vehicle_bookingsWhereUniqueInput
    update: XOR<vehicle_bookingsUpdateWithoutCustomerInput, vehicle_bookingsUncheckedUpdateWithoutCustomerInput>
    create: XOR<vehicle_bookingsCreateWithoutCustomerInput, vehicle_bookingsUncheckedCreateWithoutCustomerInput>
  }

  export type vehicle_bookingsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: vehicle_bookingsWhereUniqueInput
    data: XOR<vehicle_bookingsUpdateWithoutCustomerInput, vehicle_bookingsUncheckedUpdateWithoutCustomerInput>
  }

  export type vehicle_bookingsUpdateManyWithWhereWithoutCustomerInput = {
    where: vehicle_bookingsScalarWhereInput
    data: XOR<vehicle_bookingsUpdateManyMutationInput, vehicle_bookingsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type vehicle_bookings_logsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    update: XOR<vehicle_bookings_logsUpdateWithoutCustomerInput, vehicle_bookings_logsUncheckedUpdateWithoutCustomerInput>
    create: XOR<vehicle_bookings_logsCreateWithoutCustomerInput, vehicle_bookings_logsUncheckedCreateWithoutCustomerInput>
  }

  export type vehicle_bookings_logsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    data: XOR<vehicle_bookings_logsUpdateWithoutCustomerInput, vehicle_bookings_logsUncheckedUpdateWithoutCustomerInput>
  }

  export type vehicle_bookings_logsUpdateManyWithWhereWithoutCustomerInput = {
    where: vehicle_bookings_logsScalarWhereInput
    data: XOR<vehicle_bookings_logsUpdateManyMutationInput, vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type vehicle_bookings_billsUpsertWithWhereUniqueWithoutCustomerInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    update: XOR<vehicle_bookings_billsUpdateWithoutCustomerInput, vehicle_bookings_billsUncheckedUpdateWithoutCustomerInput>
    create: XOR<vehicle_bookings_billsCreateWithoutCustomerInput, vehicle_bookings_billsUncheckedCreateWithoutCustomerInput>
  }

  export type vehicle_bookings_billsUpdateWithWhereUniqueWithoutCustomerInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    data: XOR<vehicle_bookings_billsUpdateWithoutCustomerInput, vehicle_bookings_billsUncheckedUpdateWithoutCustomerInput>
  }

  export type vehicle_bookings_billsUpdateManyWithWhereWithoutCustomerInput = {
    where: vehicle_bookings_billsScalarWhereInput
    data: XOR<vehicle_bookings_billsUpdateManyMutationInput, vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerInput>
  }

  export type citiesCreateWithoutProvidersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    state: statesCreateNestedOneWithoutCitiesInput
    customers?: customerCreateNestedManyWithoutCityInput
  }

  export type citiesUncheckedCreateWithoutProvidersInput = {
    id?: string
    name: string
    stateId: string
    createdAt?: Date | string
    updatedAt?: Date | string
    customers?: customerUncheckedCreateNestedManyWithoutCityInput
  }

  export type citiesCreateOrConnectWithoutProvidersInput = {
    where: citiesWhereUniqueInput
    create: XOR<citiesCreateWithoutProvidersInput, citiesUncheckedCreateWithoutProvidersInput>
  }

  export type statesCreateWithoutProvidersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: citiesCreateNestedManyWithoutStateInput
    customers?: customerCreateNestedManyWithoutStateInput
  }

  export type statesUncheckedCreateWithoutProvidersInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    cities?: citiesUncheckedCreateNestedManyWithoutStateInput
    customers?: customerUncheckedCreateNestedManyWithoutStateInput
  }

  export type statesCreateOrConnectWithoutProvidersInput = {
    where: statesWhereUniqueInput
    create: XOR<statesCreateWithoutProvidersInput, statesUncheckedCreateWithoutProvidersInput>
  }

  export type citiesUpsertWithoutProvidersInput = {
    update: XOR<citiesUpdateWithoutProvidersInput, citiesUncheckedUpdateWithoutProvidersInput>
    create: XOR<citiesCreateWithoutProvidersInput, citiesUncheckedCreateWithoutProvidersInput>
    where?: citiesWhereInput
  }

  export type citiesUpdateToOneWithWhereWithoutProvidersInput = {
    where?: citiesWhereInput
    data: XOR<citiesUpdateWithoutProvidersInput, citiesUncheckedUpdateWithoutProvidersInput>
  }

  export type citiesUpdateWithoutProvidersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: statesUpdateOneRequiredWithoutCitiesNestedInput
    customers?: customerUpdateManyWithoutCityNestedInput
  }

  export type citiesUncheckedUpdateWithoutProvidersInput = {
    name?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customerUncheckedUpdateManyWithoutCityNestedInput
  }

  export type statesUpsertWithoutProvidersInput = {
    update: XOR<statesUpdateWithoutProvidersInput, statesUncheckedUpdateWithoutProvidersInput>
    create: XOR<statesCreateWithoutProvidersInput, statesUncheckedCreateWithoutProvidersInput>
    where?: statesWhereInput
  }

  export type statesUpdateToOneWithWhereWithoutProvidersInput = {
    where?: statesWhereInput
    data: XOR<statesUpdateWithoutProvidersInput, statesUncheckedUpdateWithoutProvidersInput>
  }

  export type statesUpdateWithoutProvidersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUpdateManyWithoutStateNestedInput
    customers?: customerUpdateManyWithoutStateNestedInput
  }

  export type statesUncheckedUpdateWithoutProvidersInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    cities?: citiesUncheckedUpdateManyWithoutStateNestedInput
    customers?: customerUncheckedUpdateManyWithoutStateNestedInput
  }

  export type vehicleCreateWithoutBookingsInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutBookingsInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutBookingsInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutBookingsInput, vehicleUncheckedCreateWithoutBookingsInput>
  }

  export type customerCreateWithoutVehicle_bookingsInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutCustomersInput
    state: statesCreateNestedOneWithoutCustomersInput
    vehicle_bookings_logs?: vehicle_bookings_logsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutVehicle_bookingsInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutVehicle_bookingsInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutVehicle_bookingsInput, customerUncheckedCreateWithoutVehicle_bookingsInput>
  }

  export type vehicle_inspectionCreateWithoutVehicle_bookingsInput = {
    id?: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutInspectionsInput
    details?: vehicle_inspection_detailsCreateNestedManyWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput = {
    id?: string
    vehicle_id: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    details?: vehicle_inspection_detailsUncheckedCreateNestedManyWithoutVehicle_inspectionInput
  }

  export type vehicle_inspectionCreateOrConnectWithoutVehicle_bookingsInput = {
    where: vehicle_inspectionWhereUniqueInput
    create: XOR<vehicle_inspectionCreateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput>
  }

  export type vehicle_inspectionCreateManyVehicle_bookingsInputEnvelope = {
    data: vehicle_inspectionCreateManyVehicle_bookingsInput | vehicle_inspectionCreateManyVehicle_bookingsInput[]
  }

  export type vehicle_bookings_logsCreateWithoutVehicle_bookingInput = {
    id?: string
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle?: vehicleCreateNestedOneWithoutBooking_logsInput
    customer?: customerCreateNestedOneWithoutVehicle_bookings_logsInput
  }

  export type vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput = {
    id?: string
    vehicle_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    customer_id?: string | null
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsCreateOrConnectWithoutVehicle_bookingInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    create: XOR<vehicle_bookings_logsCreateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_logsCreateManyVehicle_bookingInputEnvelope = {
    data: vehicle_bookings_logsCreateManyVehicle_bookingInput | vehicle_bookings_logsCreateManyVehicle_bookingInput[]
  }

  export type vehicle_bookings_billsCreateWithoutVehicle_bookingInput = {
    id?: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_price: vehicle_pricesCreateNestedOneWithoutBillsInput
    customer: customerCreateNestedOneWithoutVehicle_bookings_billsInput
    bills_payment?: bills_paymentCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput = {
    id?: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
    bills_payment?: bills_paymentUncheckedCreateNestedManyWithoutBillInput
  }

  export type vehicle_bookings_billsCreateOrConnectWithoutVehicle_bookingInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    create: XOR<vehicle_bookings_billsCreateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_billsCreateManyVehicle_bookingInputEnvelope = {
    data: vehicle_bookings_billsCreateManyVehicle_bookingInput | vehicle_bookings_billsCreateManyVehicle_bookingInput[]
  }

  export type vehicleUpsertWithoutBookingsInput = {
    update: XOR<vehicleUpdateWithoutBookingsInput, vehicleUncheckedUpdateWithoutBookingsInput>
    create: XOR<vehicleCreateWithoutBookingsInput, vehicleUncheckedCreateWithoutBookingsInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutBookingsInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutBookingsInput, vehicleUncheckedUpdateWithoutBookingsInput>
  }

  export type vehicleUpdateWithoutBookingsInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutBookingsInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type customerUpsertWithoutVehicle_bookingsInput = {
    update: XOR<customerUpdateWithoutVehicle_bookingsInput, customerUncheckedUpdateWithoutVehicle_bookingsInput>
    create: XOR<customerCreateWithoutVehicle_bookingsInput, customerUncheckedCreateWithoutVehicle_bookingsInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutVehicle_bookingsInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutVehicle_bookingsInput, customerUncheckedUpdateWithoutVehicle_bookingsInput>
  }

  export type customerUpdateWithoutVehicle_bookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutCustomersNestedInput
    state?: statesUpdateOneRequiredWithoutCustomersNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutVehicle_bookingsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type vehicle_inspectionUpsertWithWhereUniqueWithoutVehicle_bookingsInput = {
    where: vehicle_inspectionWhereUniqueInput
    update: XOR<vehicle_inspectionUpdateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedUpdateWithoutVehicle_bookingsInput>
    create: XOR<vehicle_inspectionCreateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedCreateWithoutVehicle_bookingsInput>
  }

  export type vehicle_inspectionUpdateWithWhereUniqueWithoutVehicle_bookingsInput = {
    where: vehicle_inspectionWhereUniqueInput
    data: XOR<vehicle_inspectionUpdateWithoutVehicle_bookingsInput, vehicle_inspectionUncheckedUpdateWithoutVehicle_bookingsInput>
  }

  export type vehicle_inspectionUpdateManyWithWhereWithoutVehicle_bookingsInput = {
    where: vehicle_inspectionScalarWhereInput
    data: XOR<vehicle_inspectionUpdateManyMutationInput, vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsInput>
  }

  export type vehicle_bookings_logsUpsertWithWhereUniqueWithoutVehicle_bookingInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    update: XOR<vehicle_bookings_logsUpdateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedUpdateWithoutVehicle_bookingInput>
    create: XOR<vehicle_bookings_logsCreateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedCreateWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_logsUpdateWithWhereUniqueWithoutVehicle_bookingInput = {
    where: vehicle_bookings_logsWhereUniqueInput
    data: XOR<vehicle_bookings_logsUpdateWithoutVehicle_bookingInput, vehicle_bookings_logsUncheckedUpdateWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_logsUpdateManyWithWhereWithoutVehicle_bookingInput = {
    where: vehicle_bookings_logsScalarWhereInput
    data: XOR<vehicle_bookings_logsUpdateManyMutationInput, vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_billsUpsertWithWhereUniqueWithoutVehicle_bookingInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    update: XOR<vehicle_bookings_billsUpdateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedUpdateWithoutVehicle_bookingInput>
    create: XOR<vehicle_bookings_billsCreateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedCreateWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_billsUpdateWithWhereUniqueWithoutVehicle_bookingInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    data: XOR<vehicle_bookings_billsUpdateWithoutVehicle_bookingInput, vehicle_bookings_billsUncheckedUpdateWithoutVehicle_bookingInput>
  }

  export type vehicle_bookings_billsUpdateManyWithWhereWithoutVehicle_bookingInput = {
    where: vehicle_bookings_billsScalarWhereInput
    data: XOR<vehicle_bookings_billsUpdateManyMutationInput, vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingInput>
  }

  export type vehicleCreateWithoutBooking_logsInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    brand: brandsCreateNestedOneWithoutVehicleInput
    model: modelsCreateNestedOneWithoutVehicleInput
    variant: variantsCreateNestedOneWithoutVehicleInput
    features?: vehicle_featuresCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsCreateNestedManyWithoutVehicleInput
  }

  export type vehicleUncheckedCreateWithoutBooking_logsInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
    features?: vehicle_featuresUncheckedCreateNestedManyWithoutVehicleInput
    images?: vehicle_imagesUncheckedCreateNestedManyWithoutVehicleInput
    availability?: vehicle_availabilityUncheckedCreateNestedManyWithoutVehicleInput
    availability_history?: vehicle_availability_historyUncheckedCreateNestedManyWithoutVehicleInput
    inspections?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicleInput
    prices?: vehicle_pricesUncheckedCreateNestedManyWithoutVehicleInput
    bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutVehicleInput
  }

  export type vehicleCreateOrConnectWithoutBooking_logsInput = {
    where: vehicleWhereUniqueInput
    create: XOR<vehicleCreateWithoutBooking_logsInput, vehicleUncheckedCreateWithoutBooking_logsInput>
  }

  export type vehicle_bookingsCreateWithoutBooking_logsInput = {
    id?: string
    booking_number: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutBookingsInput
    customer: customerCreateNestedOneWithoutVehicle_bookingsInput
    vehicle_inspection?: vehicle_inspectionCreateNestedManyWithoutVehicle_bookingsInput
    bills?: vehicle_bookings_billsCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUncheckedCreateWithoutBooking_logsInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicle_bookingsInput
    bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsCreateOrConnectWithoutBooking_logsInput = {
    where: vehicle_bookingsWhereUniqueInput
    create: XOR<vehicle_bookingsCreateWithoutBooking_logsInput, vehicle_bookingsUncheckedCreateWithoutBooking_logsInput>
  }

  export type customerCreateWithoutVehicle_bookings_logsInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutCustomersInput
    state: statesCreateNestedOneWithoutCustomersInput
    vehicle_bookings?: vehicle_bookingsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutVehicle_bookings_logsInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutVehicle_bookings_logsInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutVehicle_bookings_logsInput, customerUncheckedCreateWithoutVehicle_bookings_logsInput>
  }

  export type vehicleUpsertWithoutBooking_logsInput = {
    update: XOR<vehicleUpdateWithoutBooking_logsInput, vehicleUncheckedUpdateWithoutBooking_logsInput>
    create: XOR<vehicleCreateWithoutBooking_logsInput, vehicleUncheckedCreateWithoutBooking_logsInput>
    where?: vehicleWhereInput
  }

  export type vehicleUpdateToOneWithWhereWithoutBooking_logsInput = {
    where?: vehicleWhereInput
    data: XOR<vehicleUpdateWithoutBooking_logsInput, vehicleUncheckedUpdateWithoutBooking_logsInput>
  }

  export type vehicleUpdateWithoutBooking_logsInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutBooking_logsInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicle_bookingsUpsertWithoutBooking_logsInput = {
    update: XOR<vehicle_bookingsUpdateWithoutBooking_logsInput, vehicle_bookingsUncheckedUpdateWithoutBooking_logsInput>
    create: XOR<vehicle_bookingsCreateWithoutBooking_logsInput, vehicle_bookingsUncheckedCreateWithoutBooking_logsInput>
    where?: vehicle_bookingsWhereInput
  }

  export type vehicle_bookingsUpdateToOneWithWhereWithoutBooking_logsInput = {
    where?: vehicle_bookingsWhereInput
    data: XOR<vehicle_bookingsUpdateWithoutBooking_logsInput, vehicle_bookingsUncheckedUpdateWithoutBooking_logsInput>
  }

  export type vehicle_bookingsUpdateWithoutBooking_logsInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutBookingsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookingsNestedInput
    vehicle_inspection?: vehicle_inspectionUpdateManyWithoutVehicle_bookingsNestedInput
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateWithoutBooking_logsInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsNestedInput
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type customerUpsertWithoutVehicle_bookings_logsInput = {
    update: XOR<customerUpdateWithoutVehicle_bookings_logsInput, customerUncheckedUpdateWithoutVehicle_bookings_logsInput>
    create: XOR<customerCreateWithoutVehicle_bookings_logsInput, customerUncheckedCreateWithoutVehicle_bookings_logsInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutVehicle_bookings_logsInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutVehicle_bookings_logsInput, customerUncheckedUpdateWithoutVehicle_bookings_logsInput>
  }

  export type customerUpdateWithoutVehicle_bookings_logsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutCustomersNestedInput
    state?: statesUpdateOneRequiredWithoutCustomersNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutVehicle_bookings_logsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type vehicle_bookingsCreateWithoutBillsInput = {
    id?: string
    booking_number: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutBookingsInput
    customer: customerCreateNestedOneWithoutVehicle_bookingsInput
    vehicle_inspection?: vehicle_inspectionCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsUncheckedCreateWithoutBillsInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedCreateNestedManyWithoutVehicle_bookingsInput
    booking_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutVehicle_bookingInput
  }

  export type vehicle_bookingsCreateOrConnectWithoutBillsInput = {
    where: vehicle_bookingsWhereUniqueInput
    create: XOR<vehicle_bookingsCreateWithoutBillsInput, vehicle_bookingsUncheckedCreateWithoutBillsInput>
  }

  export type vehicle_pricesCreateWithoutBillsInput = {
    id?: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle: vehicleCreateNestedOneWithoutPricesInput
  }

  export type vehicle_pricesUncheckedCreateWithoutBillsInput = {
    id?: string
    vehicle_id: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_pricesCreateOrConnectWithoutBillsInput = {
    where: vehicle_pricesWhereUniqueInput
    create: XOR<vehicle_pricesCreateWithoutBillsInput, vehicle_pricesUncheckedCreateWithoutBillsInput>
  }

  export type customerCreateWithoutVehicle_bookings_billsInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    city: citiesCreateNestedOneWithoutCustomersInput
    state: statesCreateNestedOneWithoutCustomersInput
    vehicle_bookings?: vehicle_bookingsCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsCreateNestedManyWithoutCustomerInput
  }

  export type customerUncheckedCreateWithoutVehicle_bookings_billsInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedCreateNestedManyWithoutCustomerInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedCreateNestedManyWithoutCustomerInput
  }

  export type customerCreateOrConnectWithoutVehicle_bookings_billsInput = {
    where: customerWhereUniqueInput
    create: XOR<customerCreateWithoutVehicle_bookings_billsInput, customerUncheckedCreateWithoutVehicle_bookings_billsInput>
  }

  export type bills_paymentCreateWithoutBillInput = {
    id?: string
    amount: number
    payment_method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bills_paymentUncheckedCreateWithoutBillInput = {
    id?: string
    amount: number
    payment_method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bills_paymentCreateOrConnectWithoutBillInput = {
    where: bills_paymentWhereUniqueInput
    create: XOR<bills_paymentCreateWithoutBillInput, bills_paymentUncheckedCreateWithoutBillInput>
  }

  export type bills_paymentCreateManyBillInputEnvelope = {
    data: bills_paymentCreateManyBillInput | bills_paymentCreateManyBillInput[]
  }

  export type vehicle_bookingsUpsertWithoutBillsInput = {
    update: XOR<vehicle_bookingsUpdateWithoutBillsInput, vehicle_bookingsUncheckedUpdateWithoutBillsInput>
    create: XOR<vehicle_bookingsCreateWithoutBillsInput, vehicle_bookingsUncheckedCreateWithoutBillsInput>
    where?: vehicle_bookingsWhereInput
  }

  export type vehicle_bookingsUpdateToOneWithWhereWithoutBillsInput = {
    where?: vehicle_bookingsWhereInput
    data: XOR<vehicle_bookingsUpdateWithoutBillsInput, vehicle_bookingsUncheckedUpdateWithoutBillsInput>
  }

  export type vehicle_bookingsUpdateWithoutBillsInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutBookingsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookingsNestedInput
    vehicle_inspection?: vehicle_inspectionUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateWithoutBillsInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_pricesUpsertWithoutBillsInput = {
    update: XOR<vehicle_pricesUpdateWithoutBillsInput, vehicle_pricesUncheckedUpdateWithoutBillsInput>
    create: XOR<vehicle_pricesCreateWithoutBillsInput, vehicle_pricesUncheckedCreateWithoutBillsInput>
    where?: vehicle_pricesWhereInput
  }

  export type vehicle_pricesUpdateToOneWithWhereWithoutBillsInput = {
    where?: vehicle_pricesWhereInput
    data: XOR<vehicle_pricesUpdateWithoutBillsInput, vehicle_pricesUncheckedUpdateWithoutBillsInput>
  }

  export type vehicle_pricesUpdateWithoutBillsInput = {
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutPricesNestedInput
  }

  export type vehicle_pricesUncheckedUpdateWithoutBillsInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUpsertWithoutVehicle_bookings_billsInput = {
    update: XOR<customerUpdateWithoutVehicle_bookings_billsInput, customerUncheckedUpdateWithoutVehicle_bookings_billsInput>
    create: XOR<customerCreateWithoutVehicle_bookings_billsInput, customerUncheckedCreateWithoutVehicle_bookings_billsInput>
    where?: customerWhereInput
  }

  export type customerUpdateToOneWithWhereWithoutVehicle_bookings_billsInput = {
    where?: customerWhereInput
    data: XOR<customerUpdateWithoutVehicle_bookings_billsInput, customerUncheckedUpdateWithoutVehicle_bookings_billsInput>
  }

  export type customerUpdateWithoutVehicle_bookings_billsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutCustomersNestedInput
    state?: statesUpdateOneRequiredWithoutCustomersNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutVehicle_bookings_billsInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type bills_paymentUpsertWithWhereUniqueWithoutBillInput = {
    where: bills_paymentWhereUniqueInput
    update: XOR<bills_paymentUpdateWithoutBillInput, bills_paymentUncheckedUpdateWithoutBillInput>
    create: XOR<bills_paymentCreateWithoutBillInput, bills_paymentUncheckedCreateWithoutBillInput>
  }

  export type bills_paymentUpdateWithWhereUniqueWithoutBillInput = {
    where: bills_paymentWhereUniqueInput
    data: XOR<bills_paymentUpdateWithoutBillInput, bills_paymentUncheckedUpdateWithoutBillInput>
  }

  export type bills_paymentUpdateManyWithWhereWithoutBillInput = {
    where: bills_paymentScalarWhereInput
    data: XOR<bills_paymentUpdateManyMutationInput, bills_paymentUncheckedUpdateManyWithoutBillInput>
  }

  export type bills_paymentScalarWhereInput = {
    AND?: bills_paymentScalarWhereInput | bills_paymentScalarWhereInput[]
    OR?: bills_paymentScalarWhereInput[]
    NOT?: bills_paymentScalarWhereInput | bills_paymentScalarWhereInput[]
    id?: StringFilter<"bills_payment"> | string
    bill_id?: StringFilter<"bills_payment"> | string
    amount?: FloatFilter<"bills_payment"> | number
    payment_method?: StringFilter<"bills_payment"> | string
    createdAt?: DateTimeFilter<"bills_payment"> | Date | string
    updatedAt?: DateTimeFilter<"bills_payment"> | Date | string
  }

  export type vehicle_bookings_billsCreateWithoutBills_paymentInput = {
    id?: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_booking: vehicle_bookingsCreateNestedOneWithoutBillsInput
    vehicle_price: vehicle_pricesCreateNestedOneWithoutBillsInput
    customer: customerCreateNestedOneWithoutVehicle_bookings_billsInput
  }

  export type vehicle_bookings_billsUncheckedCreateWithoutBills_paymentInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_billsCreateOrConnectWithoutBills_paymentInput = {
    where: vehicle_bookings_billsWhereUniqueInput
    create: XOR<vehicle_bookings_billsCreateWithoutBills_paymentInput, vehicle_bookings_billsUncheckedCreateWithoutBills_paymentInput>
  }

  export type vehicle_bookings_billsUpsertWithoutBills_paymentInput = {
    update: XOR<vehicle_bookings_billsUpdateWithoutBills_paymentInput, vehicle_bookings_billsUncheckedUpdateWithoutBills_paymentInput>
    create: XOR<vehicle_bookings_billsCreateWithoutBills_paymentInput, vehicle_bookings_billsUncheckedCreateWithoutBills_paymentInput>
    where?: vehicle_bookings_billsWhereInput
  }

  export type vehicle_bookings_billsUpdateToOneWithWhereWithoutBills_paymentInput = {
    where?: vehicle_bookings_billsWhereInput
    data: XOR<vehicle_bookings_billsUpdateWithoutBills_paymentInput, vehicle_bookings_billsUncheckedUpdateWithoutBills_paymentInput>
  }

  export type vehicle_bookings_billsUpdateWithoutBills_paymentInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_booking?: vehicle_bookingsUpdateOneRequiredWithoutBillsNestedInput
    vehicle_price?: vehicle_pricesUpdateOneRequiredWithoutBillsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookings_billsNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateWithoutBills_paymentInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type modelsCreateManyBrandInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type variantsCreateManyBrandInput = {
    id?: string
    name: string
    model_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicleCreateManyBrandInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    model_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type modelsUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUpdateManyWithoutModelNestedInput
    vehicle?: vehicleUpdateManyWithoutModelNestedInput
  }

  export type modelsUncheckedUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    variants?: variantsUncheckedUpdateManyWithoutModelNestedInput
    vehicle?: vehicleUncheckedUpdateManyWithoutModelNestedInput
  }

  export type modelsUncheckedUpdateManyWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type variantsUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: modelsUpdateOneRequiredWithoutVariantsNestedInput
    vehicle?: vehicleUpdateManyWithoutVariantNestedInput
  }

  export type variantsUncheckedUpdateWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type variantsUncheckedUpdateManyWithoutBrandInput = {
    name?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicleUpdateWithoutBrandInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutBrandInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateManyWithoutBrandInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type variantsCreateManyModelInput = {
    id?: string
    name: string
    brand_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicleCreateManyModelInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    variant_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type variantsUpdateWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneWithoutVariantsNestedInput
    vehicle?: vehicleUpdateManyWithoutVariantNestedInput
  }

  export type variantsUncheckedUpdateWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUncheckedUpdateManyWithoutVariantNestedInput
  }

  export type variantsUncheckedUpdateManyWithoutModelInput = {
    name?: StringFieldUpdateOperationsInput | string
    brand_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicleUpdateWithoutModelInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    variant?: variantsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutModelInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateManyWithoutModelInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    variant_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicleCreateManyVariantInput = {
    id?: string
    registration_number: string
    owner_name: string
    insurance_company: string
    insurance_number: string
    chassis_number: string
    rc_image: string
    insurance_image: string
    brand_id: string
    model_id: string
    kms_driven: number
    color: string
    mileage: number
    engine_capacity: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicleUpdateWithoutVariantInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    brand?: brandsUpdateOneRequiredWithoutVehicleNestedInput
    model?: modelsUpdateOneRequiredWithoutVehicleNestedInput
    features?: vehicle_featuresUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateWithoutVariantInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    features?: vehicle_featuresUncheckedUpdateManyWithoutVehicleNestedInput
    images?: vehicle_imagesUncheckedUpdateManyWithoutVehicleNestedInput
    availability?: vehicle_availabilityUncheckedUpdateManyWithoutVehicleNestedInput
    availability_history?: vehicle_availability_historyUncheckedUpdateManyWithoutVehicleNestedInput
    inspections?: vehicle_inspectionUncheckedUpdateManyWithoutVehicleNestedInput
    prices?: vehicle_pricesUncheckedUpdateManyWithoutVehicleNestedInput
    bookings?: vehicle_bookingsUncheckedUpdateManyWithoutVehicleNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleNestedInput
  }

  export type vehicleUncheckedUpdateManyWithoutVariantInput = {
    registration_number?: StringFieldUpdateOperationsInput | string
    owner_name?: StringFieldUpdateOperationsInput | string
    insurance_company?: StringFieldUpdateOperationsInput | string
    insurance_number?: StringFieldUpdateOperationsInput | string
    chassis_number?: StringFieldUpdateOperationsInput | string
    rc_image?: StringFieldUpdateOperationsInput | string
    insurance_image?: StringFieldUpdateOperationsInput | string
    brand_id?: StringFieldUpdateOperationsInput | string
    model_id?: StringFieldUpdateOperationsInput | string
    kms_driven?: IntFieldUpdateOperationsInput | number
    color?: StringFieldUpdateOperationsInput | string
    mileage?: FloatFieldUpdateOperationsInput | number
    engine_capacity?: IntFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type citiesCreateManyStateInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerCreateManyStateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    city_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type providersCreateManyStateInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    cityId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type citiesUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customerUpdateManyWithoutCityNestedInput
    providers?: providersUpdateManyWithoutCityNestedInput
  }

  export type citiesUncheckedUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customers?: customerUncheckedUpdateManyWithoutCityNestedInput
    providers?: providersUncheckedUpdateManyWithoutCityNestedInput
  }

  export type citiesUncheckedUpdateManyWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutCustomersNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    city_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    city?: citiesUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersUncheckedUpdateManyWithoutStateInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    cityId?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type customerCreateManyCityInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    state_id: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    driving_license_number: string
    driving_license_front_image: string
    driving_license_back_image: string
    profile_image?: string | null
    is_active?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type providersCreateManyCityInput = {
    id?: string
    name: string
    email_id: string
    mobile_number: string
    alternate_mobile_number?: string | null
    address: string
    stateId: string
    pin_code: string
    adhaar_number: string
    adhar_front_image: string
    adhar_back_image: string
    pan_number: string
    pan_image: string
    profile_image?: string | null
    is_approved?: boolean
    is_active?: boolean
    rejection_reason?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type customerUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: statesUpdateOneRequiredWithoutCustomersNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookings?: vehicle_bookingsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerNestedInput
    vehicle_bookings_bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerNestedInput
  }

  export type customerUncheckedUpdateManyWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    state_id?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    driving_license_number?: StringFieldUpdateOperationsInput | string
    driving_license_front_image?: StringFieldUpdateOperationsInput | string
    driving_license_back_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_active?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    state?: statesUpdateOneRequiredWithoutProvidersNestedInput
  }

  export type providersUncheckedUpdateWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type providersUncheckedUpdateManyWithoutCityInput = {
    name?: StringFieldUpdateOperationsInput | string
    email_id?: StringFieldUpdateOperationsInput | string
    mobile_number?: StringFieldUpdateOperationsInput | string
    alternate_mobile_number?: NullableStringFieldUpdateOperationsInput | string | null
    address?: StringFieldUpdateOperationsInput | string
    stateId?: StringFieldUpdateOperationsInput | string
    pin_code?: StringFieldUpdateOperationsInput | string
    adhaar_number?: StringFieldUpdateOperationsInput | string
    adhar_front_image?: StringFieldUpdateOperationsInput | string
    adhar_back_image?: StringFieldUpdateOperationsInput | string
    pan_number?: StringFieldUpdateOperationsInput | string
    pan_image?: StringFieldUpdateOperationsInput | string
    profile_image?: NullableStringFieldUpdateOperationsInput | string | null
    is_approved?: BoolFieldUpdateOperationsInput | boolean
    is_active?: BoolFieldUpdateOperationsInput | boolean
    rejection_reason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type checklist_optionsCreateManyCategoryInput = {
    id?: string
    name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type checklist_optionsUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspectionDetails?: vehicle_inspection_detailsUpdateManyWithoutChecklist_optionNestedInput
  }

  export type checklist_optionsUncheckedUpdateWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    inspectionDetails?: vehicle_inspection_detailsUncheckedUpdateManyWithoutChecklist_optionNestedInput
  }

  export type checklist_optionsUncheckedUpdateManyWithoutCategoryInput = {
    name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsCreateManyChecklist_optionInput = {
    id?: string
    rating: number
    description: string
    vehicle_inspection_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspection_detailsUpdateWithoutChecklist_optionInput = {
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_inspection?: vehicle_inspectionUpdateOneRequiredWithoutDetailsNestedInput
  }

  export type vehicle_inspection_detailsUncheckedUpdateWithoutChecklist_optionInput = {
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vehicle_inspection_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsUncheckedUpdateManyWithoutChecklist_optionInput = {
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    vehicle_inspection_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresCreateManyVehicleInput = {
    id?: string
    feature_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_imagesCreateManyVehicleInput = {
    id?: string
    image_url: string
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availabilityCreateManyVehicleInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_availability_historyCreateManyVehicleInput = {
    id?: string
    start_time: Date | string
    end_time: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspectionCreateManyVehicleInput = {
    id?: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
    vehicle_bookingsId?: string | null
  }

  export type vehicle_pricesCreateManyVehicleInput = {
    id?: string
    base_price_per_day: number
    hr_included: number
    km_included: number
    extra_km_charge: number
    extra_hr_charge: number
    is_unlimited_allowed?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookingsCreateManyVehicleInput = {
    id?: string
    booking_number: string
    customer_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsCreateManyVehicleInput = {
    id?: string
    vehicle_booking_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    customer_id?: string | null
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_featuresUpdateWithoutVehicleInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresUncheckedUpdateWithoutVehicleInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_featuresUncheckedUpdateManyWithoutVehicleInput = {
    feature_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_imagesUpdateWithoutVehicleInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_imagesUncheckedUpdateWithoutVehicleInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_imagesUncheckedUpdateManyWithoutVehicleInput = {
    image_url?: StringFieldUpdateOperationsInput | string
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availabilityUpdateWithoutVehicleInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availabilityUncheckedUpdateWithoutVehicleInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availabilityUncheckedUpdateManyWithoutVehicleInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availability_historyUpdateWithoutVehicleInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availability_historyUncheckedUpdateWithoutVehicleInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_availability_historyUncheckedUpdateManyWithoutVehicleInput = {
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspectionUpdateWithoutVehicleInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: vehicle_inspection_detailsUpdateManyWithoutVehicle_inspectionNestedInput
    vehicle_bookings?: vehicle_bookingsUpdateOneWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionUncheckedUpdateWithoutVehicleInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookingsId?: NullableStringFieldUpdateOperationsInput | string | null
    details?: vehicle_inspection_detailsUncheckedUpdateManyWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionUncheckedUpdateManyWithoutVehicleInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_bookingsId?: NullableStringFieldUpdateOperationsInput | string | null
  }

  export type vehicle_pricesUpdateWithoutVehicleInput = {
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_priceNestedInput
  }

  export type vehicle_pricesUncheckedUpdateWithoutVehicleInput = {
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_priceNestedInput
  }

  export type vehicle_pricesUncheckedUpdateManyWithoutVehicleInput = {
    base_price_per_day?: FloatFieldUpdateOperationsInput | number
    hr_included?: IntFieldUpdateOperationsInput | number
    km_included?: IntFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    is_unlimited_allowed?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookingsUpdateWithoutVehicleInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    customer?: customerUpdateOneRequiredWithoutVehicle_bookingsNestedInput
    vehicle_inspection?: vehicle_inspectionUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateWithoutVehicleInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateManyWithoutVehicleInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    customer_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUpdateWithoutVehicleInput = {
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_booking?: vehicle_bookingsUpdateOneWithoutBooking_logsNestedInput
    customer?: customerUpdateOneWithoutVehicle_bookings_logsNestedInput
  }

  export type vehicle_bookings_logsUncheckedUpdateWithoutVehicleInput = {
    vehicle_booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUncheckedUpdateManyWithoutVehicleInput = {
    vehicle_booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsCreateManyVehicle_inspectionInput = {
    id?: string
    checklist_option_id: string
    rating: number
    description: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspection_detailsUpdateWithoutVehicle_inspectionInput = {
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    checklist_option?: checklist_optionsUpdateOneRequiredWithoutInspectionDetailsNestedInput
  }

  export type vehicle_inspection_detailsUncheckedUpdateWithoutVehicle_inspectionInput = {
    checklist_option_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspection_detailsUncheckedUpdateManyWithoutVehicle_inspectionInput = {
    checklist_option_id?: StringFieldUpdateOperationsInput | string
    rating?: IntFieldUpdateOperationsInput | number
    description?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_billsCreateManyVehicle_priceInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_billsUpdateWithoutVehicle_priceInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_booking?: vehicle_bookingsUpdateOneRequiredWithoutBillsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookings_billsNestedInput
    bills_payment?: bills_paymentUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateWithoutVehicle_priceInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills_payment?: bills_paymentUncheckedUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_priceInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookingsCreateManyCustomerInput = {
    id?: string
    booking_number: string
    vehicle_id: string
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsCreateManyCustomerInput = {
    id?: string
    vehicle_id?: string | null
    vehicle_booking_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_billsCreateManyCustomerInput = {
    id?: string
    vehicle_booking_id: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookingsUpdateWithoutCustomerInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutBookingsNestedInput
    vehicle_inspection?: vehicle_inspectionUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateWithoutCustomerInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_inspection?: vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsNestedInput
    booking_logs?: vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
    bills?: vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingNestedInput
  }

  export type vehicle_bookingsUncheckedUpdateManyWithoutCustomerInput = {
    booking_number?: StringFieldUpdateOperationsInput | string
    vehicle_id?: StringFieldUpdateOperationsInput | string
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUpdateWithoutCustomerInput = {
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneWithoutBooking_logsNestedInput
    vehicle_booking?: vehicle_bookingsUpdateOneWithoutBooking_logsNestedInput
  }

  export type vehicle_bookings_logsUncheckedUpdateWithoutCustomerInput = {
    vehicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUncheckedUpdateManyWithoutCustomerInput = {
    vehicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    vehicle_booking_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_billsUpdateWithoutCustomerInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_booking?: vehicle_bookingsUpdateOneRequiredWithoutBillsNestedInput
    vehicle_price?: vehicle_pricesUpdateOneRequiredWithoutBillsNestedInput
    bills_payment?: bills_paymentUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateWithoutCustomerInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills_payment?: bills_paymentUncheckedUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateManyWithoutCustomerInput = {
    vehicle_booking_id?: StringFieldUpdateOperationsInput | string
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_inspectionCreateManyVehicle_bookingsInput = {
    id?: string
    vehicle_id: string
    inspection_date: Date | string
    inspector_name: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_logsCreateManyVehicle_bookingInput = {
    id?: string
    vehicle_id?: string | null
    booking_number?: string | null
    start_time: Date | string
    end_time: Date | string
    customer_id?: string | null
    booking_status_id?: string | null
    logged_time?: Date | string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_bookings_billsCreateManyVehicle_bookingInput = {
    id?: string
    base_price: number
    vehicle_price_id: string
    total_price: number
    extra_km_charge: number
    extra_hr_charge: number
    customer_id: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type vehicle_inspectionUpdateWithoutVehicle_bookingsInput = {
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneRequiredWithoutInspectionsNestedInput
    details?: vehicle_inspection_detailsUpdateManyWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionUncheckedUpdateWithoutVehicle_bookingsInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    details?: vehicle_inspection_detailsUncheckedUpdateManyWithoutVehicle_inspectionNestedInput
  }

  export type vehicle_inspectionUncheckedUpdateManyWithoutVehicle_bookingsInput = {
    vehicle_id?: StringFieldUpdateOperationsInput | string
    inspection_date?: DateTimeFieldUpdateOperationsInput | Date | string
    inspector_name?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUpdateWithoutVehicle_bookingInput = {
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle?: vehicleUpdateOneWithoutBooking_logsNestedInput
    customer?: customerUpdateOneWithoutVehicle_bookings_logsNestedInput
  }

  export type vehicle_bookings_logsUncheckedUpdateWithoutVehicle_bookingInput = {
    vehicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_logsUncheckedUpdateManyWithoutVehicle_bookingInput = {
    vehicle_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_number?: NullableStringFieldUpdateOperationsInput | string | null
    start_time?: DateTimeFieldUpdateOperationsInput | Date | string
    end_time?: DateTimeFieldUpdateOperationsInput | Date | string
    customer_id?: NullableStringFieldUpdateOperationsInput | string | null
    booking_status_id?: NullableStringFieldUpdateOperationsInput | string | null
    logged_time?: DateTimeFieldUpdateOperationsInput | Date | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type vehicle_bookings_billsUpdateWithoutVehicle_bookingInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    vehicle_price?: vehicle_pricesUpdateOneRequiredWithoutBillsNestedInput
    customer?: customerUpdateOneRequiredWithoutVehicle_bookings_billsNestedInput
    bills_payment?: bills_paymentUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateWithoutVehicle_bookingInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    bills_payment?: bills_paymentUncheckedUpdateManyWithoutBillNestedInput
  }

  export type vehicle_bookings_billsUncheckedUpdateManyWithoutVehicle_bookingInput = {
    base_price?: FloatFieldUpdateOperationsInput | number
    vehicle_price_id?: StringFieldUpdateOperationsInput | string
    total_price?: FloatFieldUpdateOperationsInput | number
    extra_km_charge?: FloatFieldUpdateOperationsInput | number
    extra_hr_charge?: FloatFieldUpdateOperationsInput | number
    customer_id?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bills_paymentCreateManyBillInput = {
    id?: string
    amount: number
    payment_method: string
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type bills_paymentUpdateWithoutBillInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bills_paymentUncheckedUpdateWithoutBillInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type bills_paymentUncheckedUpdateManyWithoutBillInput = {
    amount?: FloatFieldUpdateOperationsInput | number
    payment_method?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}